function random$2(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function isBrowser() {
  return typeof window !== "undefined";
}
function isFunction$8(val) {
  return {}.toString.call(val) === "[object Function]";
}
function isClass(func) {
  return typeof func === "function";
}
function isPromise$3(val) {
  return isInstanceOf$3(val, Promise);
}
function isArray$d(val) {
  return isInstanceOf$3(val, Array);
}
function isObject$4(val) {
  return typeof val == "object" && val != null && !isArray$d(val);
}
function isString$b(val) {
  return typeof val == "string";
}
function isInstanceOf$3(val, _class) {
  return val instanceof _class;
}
function arrayUniq$2(array2) {
  return [...new Set(array2)];
}
function arrayFlat$2(array2) {
  return array2.reduce((acc, val) => acc.concat(val), []);
}
function intersection$1([start1, end1], [start2, end2]) {
  return start1 >= start2 && start1 <= end2 || start2 >= start1 && start2 < end1;
}
function capitalize$3(s2) {
  if (typeof s2 !== "string")
    return "";
  return s2.charAt(0).toUpperCase() + s2.slice(1);
}
function camelToKebab(str2) {
  return str2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function arrayEquals$1(a8, b3) {
  return a8.length === b3.length && a8.every((v2, i2) => v2 === b3[i2]);
}
function applyMixins$8(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
      const baseCtorName = Object.getOwnPropertyDescriptor(baseCtor.prototype, name2);
      if (!baseCtorName) {
        return;
      }
      Object.defineProperty(derivedCtor.prototype, name2, baseCtorName);
    });
  });
}
function generateUID() {
  let firstPart = Math.random() * 46656 | 0;
  let secondPart = Math.random() * 46656 | 0;
  firstPart = ("000" + firstPart.toString(36)).slice(-3);
  secondPart = ("000" + secondPart.toString(36)).slice(-3);
  return firstPart + secondPart;
}
function createConstructor(...propNames) {
  return class {
    constructor(...propValues) {
      propNames.forEach((name2, idx) => {
        this[name2] = propValues[idx];
      });
    }
  };
}
function sharedArrayBuffer() {
  let buffer2;
  if (typeof SharedArrayBuffer != "undefined") {
    buffer2 = SharedArrayBuffer;
  } else {
    buffer2 = ArrayBuffer;
  }
  return buffer2;
}
function toRadians(angle2) {
  return angle2 * (Math.PI / 180);
}
function hexaToNumber(hexa) {
  let val = hexa.replace("#", "");
  let alpha = 1;
  if (val.length === 3) {
    val = val.split("").map((v2) => v2 + v2).join("");
  }
  if (val.length === 8) {
    alpha = parseInt(val.substring(0, 2), 16) / 255;
    val = val.substring(2);
  }
  return {
    value: parseInt(val, 16),
    alpha
  };
}
function extractId$1(path2) {
  const id = path2.match(/([a-zA-Z0-9-_$!]+)\.[a-z0-9]+$/i);
  if (!id)
    return null;
  return id[1];
}
function basename$1(path2) {
  return path2.substring(path2.lastIndexOf("/") + 1);
}
function fps2ms(fps) {
  return 1e3 / fps;
}
function preciseNow() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
function round$1(num, decimals = 100) {
  return Math.round(num * decimals) / decimals;
}
function set$4(obj, path2, value, onlyPlainObject = false) {
  if (Object(obj) !== obj)
    return obj;
  if (!Array.isArray(path2))
    path2 = path2.toString().match(/[^.[\]]+/g) || [];
  path2.slice(0, -1).reduce(
    (a8, c3, i2) => (
      // Iterate all of them except the last one
      Object(a8[c3]) === a8[c3] ? a8[c3] : a8[c3] = Math.abs(path2[i2 + 1]) >> 0 === +path2[i2 + 1] ? onlyPlainObject ? {} : [] : {}
    ),
    // No: assign a new plain object
    obj
  )[path2[path2.length - 1]] = value;
  return obj;
}
function elementToPositionAbsolute$2(element) {
  element.style.position = "absolute";
  element.style.top = "0";
  element.style.left = "0";
  element.style.right = "0";
  element.style.bottom = "0";
  element.style.width = "100%";
  element.style.height = "100%";
}
const Utils$1 = {
  random: random$2,
  isBrowser,
  isPromise: isPromise$3,
  isArray: isArray$d,
  isObject: isObject$4,
  isString: isString$b,
  isFunction: isFunction$8,
  isClass,
  isInstanceOf: isInstanceOf$3,
  arrayUniq: arrayUniq$2,
  arrayFlat: arrayFlat$2,
  arrayEquals: arrayEquals$1,
  intersection: intersection$1,
  applyMixins: applyMixins$8,
  capitalize: capitalize$3,
  sharedArrayBuffer,
  generateUID,
  createConstructor,
  toRadians,
  extractId: extractId$1,
  basename: basename$1,
  fps2ms,
  preciseNow,
  hexaToNumber,
  set: set$4,
  round: round$1,
  camelToKebab,
  elementToPositionAbsolute: elementToPositionAbsolute$2
};
const Utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyMixins: applyMixins$8,
  arrayEquals: arrayEquals$1,
  arrayFlat: arrayFlat$2,
  arrayUniq: arrayUniq$2,
  basename: basename$1,
  camelToKebab,
  capitalize: capitalize$3,
  createConstructor,
  default: Utils$1,
  elementToPositionAbsolute: elementToPositionAbsolute$2,
  extractId: extractId$1,
  fps2ms,
  generateUID,
  hexaToNumber,
  intersection: intersection$1,
  isArray: isArray$d,
  isBrowser,
  isClass,
  isFunction: isFunction$8,
  isInstanceOf: isInstanceOf$3,
  isObject: isObject$4,
  isPromise: isPromise$3,
  isString: isString$b,
  preciseNow,
  random: random$2,
  round: round$1,
  set: set$4,
  sharedArrayBuffer,
  toRadians
}, Symbol.toStringTag, { value: "Module" }));
var HitType;
(function(HitType2) {
  HitType2["Box"] = "box";
  HitType2["Circle"] = "circle";
  HitType2["Polygon"] = "polygon";
})(HitType || (HitType = {}));
var MoveClientMode;
(function(MoveClientMode2) {
  MoveClientMode2[MoveClientMode2["Disabled"] = 0] = "Disabled";
  MoveClientMode2[MoveClientMode2["ByDirection"] = 1] = "ByDirection";
  MoveClientMode2[MoveClientMode2["Drag"] = 2] = "Drag";
})(MoveClientMode || (MoveClientMode = {}));
var Behavior;
(function(Behavior2) {
  Behavior2[Behavior2["Direction"] = 0] = "Direction";
  Behavior2[Behavior2["Target"] = 1] = "Target";
})(Behavior || (Behavior = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["Up"] = 1] = "Up";
  Direction2[Direction2["Down"] = 3] = "Down";
  Direction2[Direction2["Left"] = 4] = "Left";
  Direction2[Direction2["Right"] = 2] = "Right";
  Direction2[Direction2["UpRight"] = 1.5] = "UpRight";
  Direction2[Direction2["DownRight"] = 2.5] = "DownRight";
  Direction2[Direction2["DownLeft"] = 3.5] = "DownLeft";
  Direction2[Direction2["UpLeft"] = 2.5] = "UpLeft";
})(Direction || (Direction = {}));
var PlayerType;
(function(PlayerType2) {
  PlayerType2["Player"] = "player";
  PlayerType2["Event"] = "event";
  PlayerType2["Shape"] = "shape";
})(PlayerType || (PlayerType = {}));
var SocketMethods;
(function(SocketMethods2) {
  SocketMethods2["CameraFollow"] = "cameraFollow";
  SocketMethods2["ShowAnimation"] = "showAnimation";
  SocketMethods2["PlaySound"] = "playSound";
  SocketMethods2["ModeMove"] = "modeMove";
})(SocketMethods || (SocketMethods = {}));
var SocketEvents;
(function(SocketEvents2) {
  SocketEvents2["CallMethod"] = "callMethod";
  SocketEvents2["GameReload"] = "gameReload";
  SocketEvents2["ChangeServer"] = "changeServer";
  SocketEvents2["LoadScene"] = "loadScene";
})(SocketEvents || (SocketEvents = {}));
var Control;
(function(Control2) {
  Control2["Action"] = "action";
  Control2["Attack"] = "attack";
  Control2["Defense"] = "defense";
  Control2["Skill"] = "skill";
  Control2["Back"] = "back";
  Control2[Control2["Up"] = 1] = "Up";
  Control2[Control2["Down"] = 3] = "Down";
  Control2[Control2["Right"] = 2] = "Right";
  Control2[Control2["Left"] = 4] = "Left";
})(Control || (Control = {}));
var Input;
(function(Input2) {
  Input2["Break"] = "break";
  Input2["Backspace"] = "backspace";
  Input2["Tab"] = "tab";
  Input2["Clear"] = "clear";
  Input2["Enter"] = "enter";
  Input2["Shift"] = "shift";
  Input2["Ctrl"] = "ctrl";
  Input2["Alt"] = "alt";
  Input2["Pause"] = "pause/break";
  Input2["CapsLock"] = "caps lock";
  Input2["Escape"] = "escape";
  Input2["Conversion"] = "conversion";
  Input2["NonConversion"] = "non-conversion";
  Input2["Space"] = "space";
  Input2["PageUp"] = "page up";
  Input2["PageDown"] = "page down";
  Input2["End"] = "end";
  Input2["Home"] = "home";
  Input2[Input2["Left"] = 4] = "Left";
  Input2[Input2["Up"] = 1] = "Up";
  Input2[Input2["Right"] = 2] = "Right";
  Input2[Input2["Down"] = 3] = "Down";
  Input2["Select"] = "select";
  Input2["Print"] = "print";
  Input2["Execute"] = "execute";
  Input2["PrintScreen"] = "Print Screen";
  Input2["Insert"] = "insert";
  Input2["Delete"] = "delete";
  Input2["Zero"] = "0";
  Input2["One"] = "1";
  Input2["Two"] = "2";
  Input2["Three"] = "3";
  Input2["Four"] = "4";
  Input2["Five"] = "5";
  Input2["Six"] = "6";
  Input2["Seven"] = "7";
  Input2["Height"] = "8";
  Input2["Nine"] = "9";
  Input2["Equal"] = "=";
  Input2["Semicolon"] = "semicolon (firefox), equals";
  Input2["LessThan"] = "<";
  Input2["Equals"] = "equals (firefox)";
  Input2["Beta"] = "ß";
  Input2["At"] = "@";
  Input2["A"] = "a";
  Input2["B"] = "b";
  Input2["C"] = "c";
  Input2["D"] = "d";
  Input2["E"] = "e";
  Input2["F"] = "f";
  Input2["G"] = "g";
  Input2["H"] = "h";
  Input2["I"] = "i";
  Input2["J"] = "j";
  Input2["K"] = "k";
  Input2["L"] = "l";
  Input2["M"] = "m";
  Input2["N"] = "n";
  Input2["O"] = "o";
  Input2["P"] = "p";
  Input2["Q"] = "q";
  Input2["R"] = "r";
  Input2["S"] = "s";
  Input2["T"] = "t";
  Input2["U"] = "u";
  Input2["V"] = "v";
  Input2["W"] = "w";
  Input2["X"] = "x";
  Input2["Y"] = "y";
  Input2["Z"] = "z";
  Input2["SearchKey"] = "Windows Key / Left ⌘ / Chromebook Search key";
  Input2["NumPad0"] = "numpad 0";
  Input2["NumPad1"] = "numpad 1";
  Input2["NumPad2"] = "numpad 2";
  Input2["NumPad3"] = "numpad 3";
  Input2["NumPad4"] = "numpad 4";
  Input2["NumPad5"] = "numpad 5";
  Input2["NumPad6"] = "numpad 6";
  Input2["NumPad7"] = "numpad 7";
  Input2["NumPad8"] = "numpad 8";
  Input2["NumPad9"] = "numpad 9";
  Input2["Multiply"] = "multiply";
  Input2["Add"] = "add";
  Input2["Subtract"] = "subtract";
  Input2["DecimalPoint"] = "decimal point";
  Input2["Divide"] = "divide";
  Input2["F1"] = "f1";
  Input2["F2"] = "f2";
  Input2["F3"] = "f3";
  Input2["F4"] = "f4";
  Input2["F5"] = "f5";
  Input2["F6"] = "f6";
  Input2["F7"] = "f7";
  Input2["F8"] = "f8";
  Input2["F9"] = "f9";
  Input2["F10"] = "f10";
  Input2["F11"] = "f11";
  Input2["F12"] = "f12";
  Input2["F13"] = "f13";
  Input2["F14"] = "f14";
  Input2["F15"] = "f15";
  Input2["F16"] = "f16";
  Input2["F17"] = "f17";
  Input2["F18"] = "f18";
  Input2["F19"] = "f19";
  Input2["F20"] = "f20";
  Input2["F21"] = "f21";
  Input2["F22"] = "f22";
  Input2["F23"] = "f23";
  Input2["F24"] = "f24";
  Input2["NumLock"] = "num lock";
  Input2["ScrollLock"] = "scroll lock";
  Input2["CircumflexAccent"] = "^";
  Input2["ExclamationMark"] = "!";
  Input2["Hash"] = "#";
  Input2["Dollar"] = "$";
  Input2["AccentU"] = "ù";
  Input2["PageBackward"] = "page backward";
  Input2["PageForWard"] = "page forward";
  Input2["Star"] = "*";
  Input2["DecreaseVolume"] = "decrease volume level";
  Input2["IncreaseVolume"] = "increase volume level";
  Input2["Next"] = "next";
  Input2["Previous"] = "previous";
  Input2["Stop"] = "stop";
  Input2["PlayPause"] = "play/pause";
  Input2["Email"] = "e-mail";
  Input2["SemiColon"] = "semi-colon / ñ";
  Input2["EqualSign"] = "equal sign";
  Input2["Comma"] = "comma";
  Input2["Dash"] = "dash";
  Input2["FowardSlach"] = "forward slash / ç";
  Input2["GraveAccent"] = "grave accent / ñ / æ";
  Input2["OpenBracket"] = "open bracket";
  Input2["BackSlach"] = "back slash";
  Input2["CloseBracket"] = "close bracket / å";
  Input2["SingleQuote"] = "single quote / ø";
  Input2["BackQuote"] = "`";
  Input2["Altgr"] = "altgr";
})(Input || (Input = {}));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f3 = n2.default;
  if (typeof f3 == "function") {
    var a8 = function a9() {
      if (this instanceof a9) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f3, args);
        return new Ctor();
      }
      return f3.apply(this, arguments);
    };
    a8.prototype = f3.prototype;
  } else
    a8 = {};
  Object.defineProperty(a8, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k4) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k4);
    Object.defineProperty(a8, k4, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k4];
      }
    });
  });
  return a8;
}
var SAT$1 = { exports: {} };
(function(module, exports) {
  /** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */
  (function(root2, factory2) {
    {
      module["exports"] = factory2();
    }
  })(commonjsGlobal, function() {
    var SAT2 = {};
    function Vector(x2, y2) {
      this["x"] = x2 || 0;
      this["y"] = y2 || 0;
    }
    SAT2["Vector"] = Vector;
    SAT2["V"] = Vector;
    Vector.prototype["copy"] = Vector.prototype.copy = function(other) {
      this["x"] = other["x"];
      this["y"] = other["y"];
      return this;
    };
    Vector.prototype["clone"] = Vector.prototype.clone = function() {
      return new Vector(this["x"], this["y"]);
    };
    Vector.prototype["perp"] = Vector.prototype.perp = function() {
      var x2 = this["x"];
      this["x"] = this["y"];
      this["y"] = -x2;
      return this;
    };
    Vector.prototype["rotate"] = Vector.prototype.rotate = function(angle2) {
      var x2 = this["x"];
      var y2 = this["y"];
      this["x"] = x2 * Math.cos(angle2) - y2 * Math.sin(angle2);
      this["y"] = x2 * Math.sin(angle2) + y2 * Math.cos(angle2);
      return this;
    };
    Vector.prototype["reverse"] = Vector.prototype.reverse = function() {
      this["x"] = -this["x"];
      this["y"] = -this["y"];
      return this;
    };
    Vector.prototype["normalize"] = Vector.prototype.normalize = function() {
      var d2 = this.len();
      if (d2 > 0) {
        this["x"] = this["x"] / d2;
        this["y"] = this["y"] / d2;
      }
      return this;
    };
    Vector.prototype["add"] = Vector.prototype.add = function(other) {
      this["x"] += other["x"];
      this["y"] += other["y"];
      return this;
    };
    Vector.prototype["sub"] = Vector.prototype.sub = function(other) {
      this["x"] -= other["x"];
      this["y"] -= other["y"];
      return this;
    };
    Vector.prototype["scale"] = Vector.prototype.scale = function(x2, y2) {
      this["x"] *= x2;
      this["y"] *= typeof y2 != "undefined" ? y2 : x2;
      return this;
    };
    Vector.prototype["project"] = Vector.prototype.project = function(other) {
      var amt = this.dot(other) / other.len2();
      this["x"] = amt * other["x"];
      this["y"] = amt * other["y"];
      return this;
    };
    Vector.prototype["projectN"] = Vector.prototype.projectN = function(other) {
      var amt = this.dot(other);
      this["x"] = amt * other["x"];
      this["y"] = amt * other["y"];
      return this;
    };
    Vector.prototype["reflect"] = Vector.prototype.reflect = function(axis) {
      var x2 = this["x"];
      var y2 = this["y"];
      this.project(axis).scale(2);
      this["x"] -= x2;
      this["y"] -= y2;
      return this;
    };
    Vector.prototype["reflectN"] = Vector.prototype.reflectN = function(axis) {
      var x2 = this["x"];
      var y2 = this["y"];
      this.projectN(axis).scale(2);
      this["x"] -= x2;
      this["y"] -= y2;
      return this;
    };
    Vector.prototype["dot"] = Vector.prototype.dot = function(other) {
      return this["x"] * other["x"] + this["y"] * other["y"];
    };
    Vector.prototype["len2"] = Vector.prototype.len2 = function() {
      return this.dot(this);
    };
    Vector.prototype["len"] = Vector.prototype.len = function() {
      return Math.sqrt(this.len2());
    };
    function Circle2(pos, r2) {
      this["pos"] = pos || new Vector();
      this["r"] = r2 || 0;
      this["offset"] = new Vector();
    }
    SAT2["Circle"] = Circle2;
    Circle2.prototype["getAABBAsBox"] = Circle2.prototype.getAABBAsBox = function() {
      var r2 = this["r"];
      var corner = this["pos"].clone().add(this["offset"]).sub(new Vector(r2, r2));
      return new Box(corner, r2 * 2, r2 * 2);
    };
    Circle2.prototype["getAABB"] = Circle2.prototype.getAABB = function() {
      return this.getAABBAsBox().toPolygon();
    };
    Circle2.prototype["setOffset"] = Circle2.prototype.setOffset = function(offset) {
      this["offset"] = offset;
      return this;
    };
    function Polygon2(pos, points) {
      this["pos"] = pos || new Vector();
      this["angle"] = 0;
      this["offset"] = new Vector();
      this.setPoints(points || []);
    }
    SAT2["Polygon"] = Polygon2;
    Polygon2.prototype["setPoints"] = Polygon2.prototype.setPoints = function(points) {
      var lengthChanged = !this["points"] || this["points"].length !== points.length;
      if (lengthChanged) {
        var i3;
        var calcPoints = this["calcPoints"] = [];
        var edges = this["edges"] = [];
        var normals = this["normals"] = [];
        for (i3 = 0; i3 < points.length; i3++) {
          var p1 = points[i3];
          var p2 = i3 < points.length - 1 ? points[i3 + 1] : points[0];
          if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
            points.splice(i3, 1);
            i3 -= 1;
            continue;
          }
          calcPoints.push(new Vector());
          edges.push(new Vector());
          normals.push(new Vector());
        }
      }
      this["points"] = points;
      this._recalc();
      return this;
    };
    Polygon2.prototype["setAngle"] = Polygon2.prototype.setAngle = function(angle2) {
      this["angle"] = angle2;
      this._recalc();
      return this;
    };
    Polygon2.prototype["setOffset"] = Polygon2.prototype.setOffset = function(offset) {
      this["offset"] = offset;
      this._recalc();
      return this;
    };
    Polygon2.prototype["rotate"] = Polygon2.prototype.rotate = function(angle2) {
      var points = this["points"];
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        points[i3].rotate(angle2);
      }
      this._recalc();
      return this;
    };
    Polygon2.prototype["translate"] = Polygon2.prototype.translate = function(x2, y2) {
      var points = this["points"];
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        points[i3]["x"] += x2;
        points[i3]["y"] += y2;
      }
      this._recalc();
      return this;
    };
    Polygon2.prototype._recalc = function() {
      var calcPoints = this["calcPoints"];
      var edges = this["edges"];
      var normals = this["normals"];
      var points = this["points"];
      var offset = this["offset"];
      var angle2 = this["angle"];
      var len = points.length;
      var i3;
      for (i3 = 0; i3 < len; i3++) {
        var calcPoint = calcPoints[i3].copy(points[i3]);
        calcPoint["x"] += offset["x"];
        calcPoint["y"] += offset["y"];
        if (angle2 !== 0) {
          calcPoint.rotate(angle2);
        }
      }
      for (i3 = 0; i3 < len; i3++) {
        var p1 = calcPoints[i3];
        var p2 = i3 < len - 1 ? calcPoints[i3 + 1] : calcPoints[0];
        var e3 = edges[i3].copy(p2).sub(p1);
        normals[i3].copy(e3).perp().normalize();
      }
      return this;
    };
    Polygon2.prototype["getAABBAsBox"] = Polygon2.prototype.getAABBAsBox = function() {
      var points = this["calcPoints"];
      var len = points.length;
      var xMin = points[0]["x"];
      var yMin = points[0]["y"];
      var xMax = points[0]["x"];
      var yMax = points[0]["y"];
      for (var i3 = 1; i3 < len; i3++) {
        var point = points[i3];
        if (point["x"] < xMin) {
          xMin = point["x"];
        } else if (point["x"] > xMax) {
          xMax = point["x"];
        }
        if (point["y"] < yMin) {
          yMin = point["y"];
        } else if (point["y"] > yMax) {
          yMax = point["y"];
        }
      }
      return new Box(this["pos"].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
    };
    Polygon2.prototype["getAABB"] = Polygon2.prototype.getAABB = function() {
      return this.getAABBAsBox().toPolygon();
    };
    Polygon2.prototype["getCentroid"] = Polygon2.prototype.getCentroid = function() {
      var points = this["calcPoints"];
      var len = points.length;
      var cx = 0;
      var cy = 0;
      var ar = 0;
      for (var i3 = 0; i3 < len; i3++) {
        var p1 = points[i3];
        var p2 = i3 === len - 1 ? points[0] : points[i3 + 1];
        var a8 = p1["x"] * p2["y"] - p2["x"] * p1["y"];
        cx += (p1["x"] + p2["x"]) * a8;
        cy += (p1["y"] + p2["y"]) * a8;
        ar += a8;
      }
      ar = ar * 3;
      cx = cx / ar;
      cy = cy / ar;
      return new Vector(cx, cy);
    };
    function Box(pos, w2, h2) {
      this["pos"] = pos || new Vector();
      this["w"] = w2 || 0;
      this["h"] = h2 || 0;
    }
    SAT2["Box"] = Box;
    Box.prototype["toPolygon"] = Box.prototype.toPolygon = function() {
      var pos = this["pos"];
      var w2 = this["w"];
      var h2 = this["h"];
      return new Polygon2(new Vector(pos["x"], pos["y"]), [
        new Vector(),
        new Vector(w2, 0),
        new Vector(w2, h2),
        new Vector(0, h2)
      ]);
    };
    function Response() {
      this["a"] = null;
      this["b"] = null;
      this["overlapN"] = new Vector();
      this["overlapV"] = new Vector();
      this.clear();
    }
    SAT2["Response"] = Response;
    Response.prototype["clear"] = Response.prototype.clear = function() {
      this["aInB"] = true;
      this["bInA"] = true;
      this["overlap"] = Number.MAX_VALUE;
      return this;
    };
    var T_VECTORS = [];
    for (var i2 = 0; i2 < 10; i2++) {
      T_VECTORS.push(new Vector());
    }
    var T_ARRAYS = [];
    for (var i2 = 0; i2 < 5; i2++) {
      T_ARRAYS.push([]);
    }
    var T_RESPONSE = new Response();
    var TEST_POINT = new Box(new Vector(), 1e-6, 1e-6).toPolygon();
    function flattenPointsOn(points, normal, result) {
      var min = Number.MAX_VALUE;
      var max = -Number.MAX_VALUE;
      var len = points.length;
      for (var i3 = 0; i3 < len; i3++) {
        var dot = points[i3].dot(normal);
        if (dot < min) {
          min = dot;
        }
        if (dot > max) {
          max = dot;
        }
      }
      result[0] = min;
      result[1] = max;
    }
    function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
      var rangeA = T_ARRAYS.pop();
      var rangeB = T_ARRAYS.pop();
      var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
      var projectedOffset = offsetV.dot(axis);
      flattenPointsOn(aPoints, axis, rangeA);
      flattenPointsOn(bPoints, axis, rangeB);
      rangeB[0] += projectedOffset;
      rangeB[1] += projectedOffset;
      if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return true;
      }
      if (response) {
        var overlap = 0;
        if (rangeA[0] < rangeB[0]) {
          response["aInB"] = false;
          if (rangeA[1] < rangeB[1]) {
            overlap = rangeA[1] - rangeB[0];
            response["bInA"] = false;
          } else {
            var option1 = rangeA[1] - rangeB[0];
            var option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
          }
        } else {
          response["bInA"] = false;
          if (rangeA[1] > rangeB[1]) {
            overlap = rangeA[0] - rangeB[1];
            response["aInB"] = false;
          } else {
            var option1 = rangeA[1] - rangeB[0];
            var option2 = rangeB[1] - rangeA[0];
            overlap = option1 < option2 ? option1 : -option2;
          }
        }
        var absOverlap = Math.abs(overlap);
        if (absOverlap < response["overlap"]) {
          response["overlap"] = absOverlap;
          response["overlapN"].copy(axis);
          if (overlap < 0) {
            response["overlapN"].reverse();
          }
        }
      }
      T_VECTORS.push(offsetV);
      T_ARRAYS.push(rangeA);
      T_ARRAYS.push(rangeB);
      return false;
    }
    SAT2["isSeparatingAxis"] = isSeparatingAxis;
    function voronoiRegion(line, point) {
      var len2 = line.len2();
      var dp = point.dot(line);
      if (dp < 0) {
        return LEFT_VORONOI_REGION;
      } else if (dp > len2) {
        return RIGHT_VORONOI_REGION;
      } else {
        return MIDDLE_VORONOI_REGION;
      }
    }
    var LEFT_VORONOI_REGION = -1;
    var MIDDLE_VORONOI_REGION = 0;
    var RIGHT_VORONOI_REGION = 1;
    function pointInCircle(p2, c3) {
      var differenceV = T_VECTORS.pop().copy(p2).sub(c3["pos"]).sub(c3["offset"]);
      var radiusSq = c3["r"] * c3["r"];
      var distanceSq = differenceV.len2();
      T_VECTORS.push(differenceV);
      return distanceSq <= radiusSq;
    }
    SAT2["pointInCircle"] = pointInCircle;
    function pointInPolygon(p2, poly) {
      TEST_POINT["pos"].copy(p2);
      T_RESPONSE.clear();
      var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
      if (result) {
        result = T_RESPONSE["aInB"];
      }
      return result;
    }
    SAT2["pointInPolygon"] = pointInPolygon;
    function testCircleCircle(a8, b3, response) {
      var differenceV = T_VECTORS.pop().copy(b3["pos"]).add(b3["offset"]).sub(a8["pos"]).sub(a8["offset"]);
      var totalRadius = a8["r"] + b3["r"];
      var totalRadiusSq = totalRadius * totalRadius;
      var distanceSq = differenceV.len2();
      if (distanceSq > totalRadiusSq) {
        T_VECTORS.push(differenceV);
        return false;
      }
      if (response) {
        var dist = Math.sqrt(distanceSq);
        response["a"] = a8;
        response["b"] = b3;
        response["overlap"] = totalRadius - dist;
        response["overlapN"].copy(differenceV.normalize());
        response["overlapV"].copy(differenceV).scale(response["overlap"]);
        response["aInB"] = a8["r"] <= b3["r"] && dist <= b3["r"] - a8["r"];
        response["bInA"] = b3["r"] <= a8["r"] && dist <= a8["r"] - b3["r"];
      }
      T_VECTORS.push(differenceV);
      return true;
    }
    SAT2["testCircleCircle"] = testCircleCircle;
    function testPolygonCircle(polygon, circle, response) {
      var circlePos = T_VECTORS.pop().copy(circle["pos"]).add(circle["offset"]).sub(polygon["pos"]);
      var radius = circle["r"];
      var radius2 = radius * radius;
      var points = polygon["calcPoints"];
      var len = points.length;
      var edge = T_VECTORS.pop();
      var point = T_VECTORS.pop();
      for (var i3 = 0; i3 < len; i3++) {
        var next = i3 === len - 1 ? 0 : i3 + 1;
        var prev = i3 === 0 ? len - 1 : i3 - 1;
        var overlap = 0;
        var overlapN = null;
        edge.copy(polygon["edges"][i3]);
        point.copy(circlePos).sub(points[i3]);
        if (response && point.len2() > radius2) {
          response["aInB"] = false;
        }
        var region = voronoiRegion(edge, point);
        if (region === LEFT_VORONOI_REGION) {
          edge.copy(polygon["edges"][prev]);
          var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
          region = voronoiRegion(edge, point2);
          if (region === RIGHT_VORONOI_REGION) {
            var dist = point.len();
            if (dist > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(edge);
              T_VECTORS.push(point);
              T_VECTORS.push(point2);
              return false;
            } else if (response) {
              response["bInA"] = false;
              overlapN = point.normalize();
              overlap = radius - dist;
            }
          }
          T_VECTORS.push(point2);
        } else if (region === RIGHT_VORONOI_REGION) {
          edge.copy(polygon["edges"][next]);
          point.copy(circlePos).sub(points[next]);
          region = voronoiRegion(edge, point);
          if (region === LEFT_VORONOI_REGION) {
            var dist = point.len();
            if (dist > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(edge);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              response["bInA"] = false;
              overlapN = point.normalize();
              overlap = radius - dist;
            }
          }
        } else {
          var normal = edge.perp().normalize();
          var dist = point.dot(normal);
          var distAbs = Math.abs(dist);
          if (dist > 0 && distAbs > radius) {
            T_VECTORS.push(circlePos);
            T_VECTORS.push(normal);
            T_VECTORS.push(point);
            return false;
          } else if (response) {
            overlapN = normal;
            overlap = radius - dist;
            if (dist >= 0 || overlap < 2 * radius) {
              response["bInA"] = false;
            }
          }
        }
        if (overlapN && response && Math.abs(overlap) < Math.abs(response["overlap"])) {
          response["overlap"] = overlap;
          response["overlapN"].copy(overlapN);
        }
      }
      if (response) {
        response["a"] = polygon;
        response["b"] = circle;
        response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
      }
      T_VECTORS.push(circlePos);
      T_VECTORS.push(edge);
      T_VECTORS.push(point);
      return true;
    }
    SAT2["testPolygonCircle"] = testPolygonCircle;
    function testCirclePolygon(circle, polygon, response) {
      var result = testPolygonCircle(polygon, circle, response);
      if (result && response) {
        var a8 = response["a"];
        var aInB = response["aInB"];
        response["overlapN"].reverse();
        response["overlapV"].reverse();
        response["a"] = response["b"];
        response["b"] = a8;
        response["aInB"] = response["bInA"];
        response["bInA"] = aInB;
      }
      return result;
    }
    SAT2["testCirclePolygon"] = testCirclePolygon;
    function testPolygonPolygon(a8, b3, response) {
      var aPoints = a8["calcPoints"];
      var aLen = aPoints.length;
      var bPoints = b3["calcPoints"];
      var bLen = bPoints.length;
      for (var i3 = 0; i3 < aLen; i3++) {
        if (isSeparatingAxis(a8["pos"], b3["pos"], aPoints, bPoints, a8["normals"][i3], response)) {
          return false;
        }
      }
      for (var i3 = 0; i3 < bLen; i3++) {
        if (isSeparatingAxis(a8["pos"], b3["pos"], aPoints, bPoints, b3["normals"][i3], response)) {
          return false;
        }
      }
      if (response) {
        response["a"] = a8;
        response["b"] = b3;
        response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
      }
      return true;
    }
    SAT2["testPolygonPolygon"] = testPolygonPolygon;
    return SAT2;
  });
})(SAT$1);
var SATExports = SAT$1.exports;
const SAT = /* @__PURE__ */ getDefaultExportFromCjs(SATExports);
class HitClass {
  createObjectHitbox(x2, y2, z2, w2, h2) {
    return new SAT.Box(new SAT.Vector(x2, y2 - z2), w2, h2);
  }
  getHitbox(obj, offset) {
    let hitbox, type;
    if (!offset)
      offset = {
        x: 0,
        y: 0
      };
    const x2 = obj.x + offset.x;
    const y2 = obj.y + offset.y;
    if ("ellipse" in obj || obj.type == HitType.Circle) {
      type = HitType.Circle;
      const radius = obj.width / 2;
      hitbox = new SAT.Circle(new SAT.Vector(x2 + radius, y2 + radius), radius);
    } else if ("polygon" in obj) {
      type = HitType.Polygon;
      hitbox = new SAT.Polygon(new SAT.Vector(x2, y2), obj.polygon.map((pos) => new SAT.Vector(+pos.x, +pos.y)));
    } else if (!("polygon" in obj) && "width" in obj && "height" in obj) {
      type = HitType.Box;
      hitbox = new SAT.Box(new SAT.Vector(x2, y2), obj.width, obj.height);
    } else {
      hitbox = new SAT.Vector(x2, y2);
      type = obj.type;
    }
    return {
      hitbox,
      type,
      name: obj.name
    };
  }
  testPolyCollision(type, hit1, hit2) {
    let collided = false;
    if (type == HitType.Box) {
      if (hit1.pos.x <= hit2.pos.x + hit2.w && hit1.pos.x + hit1.w >= hit2.pos.x && hit1.pos.y <= hit2.pos.y + hit2.h && hit1.h + hit1.pos.y >= hit2.pos.y) {
        return true;
      }
      return false;
    }
    if (isInstanceOf$3(hit1, SAT.Box))
      hit1 = hit1.toPolygon();
    if (isInstanceOf$3(hit2, SAT.Box))
      hit2 = hit2.toPolygon();
    switch (type) {
      case HitType.Circle:
        collided = SAT.testPolygonCircle(hit1, hit2);
        break;
      case HitType.Polygon:
        collided = SAT.testPolygonPolygon(hit1, hit2);
        break;
    }
    return collided;
  }
}
const Hit = new HitClass();
var TiledLayerType;
(function(TiledLayerType2) {
  TiledLayerType2["Tile"] = "tilelayer";
  TiledLayerType2["ObjectGroup"] = "objectgroup";
  TiledLayerType2["Image"] = "imagelayer";
  TiledLayerType2["Group"] = "group";
})(TiledLayerType || (TiledLayerType = {}));
function isTiledFormat(val) {
  return typeof val == "object" && val.version && val.orientation;
}
const global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init$1() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init$1();
  }
  var i2, j2, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init$1();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read$2(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
}
function write$2(buffer2, value, offset, isLE, mLen, nBytes) {
  var e3, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value += rt / c3;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m2 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m2 = (value * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
}
var toString$4 = {}.toString;
var isArray$c = Array.isArray || function(arr) {
  return toString$4.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
Buffer$2.from = function(value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
}
function assertSize(size2) {
  if (typeof size2 !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size2 < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size2, fill2, encoding) {
  assertSize(size2);
  if (size2 <= 0) {
    return createBuffer(that, size2);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size2).fill(fill2, encoding) : createBuffer(that, size2).fill(fill2);
  }
  return createBuffer(that, size2);
}
Buffer$2.alloc = function(size2, fill2, encoding) {
  return alloc(null, size2, fill2, encoding);
};
function allocUnsafe(that, size2) {
  assertSize(size2);
  that = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size2; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size2) {
  return allocUnsafe(null, size2);
};
Buffer$2.allocUnsafeSlow = function(size2) {
  return allocUnsafe(null, size2);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike$1(that, array2) {
  var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
  that = createBuffer(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    that[i2] = array2[i2] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array2, byteOffset, length) {
  array2.byteLength;
  if (byteOffset < 0 || array2.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array2.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array2 = new Uint8Array(array2);
  } else if (length === void 0) {
    array2 = new Uint8Array(array2, byteOffset);
  } else {
    array2 = new Uint8Array(array2, byteOffset, length);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array2;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike$1(that, array2);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike$1(that, obj);
    }
    if (obj.type === "Buffer" && isArray$c(obj.data)) {
      return fromArrayLike$1(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer$2.isBuffer = isBuffer$1;
function internalIsBuffer(b3) {
  return !!(b3 != null && b3._isBuffer);
}
Buffer$2.compare = function compare(a8, b3) {
  if (!internalIsBuffer(a8) || !internalIsBuffer(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a8 === b3)
    return 0;
  var x2 = a8.length;
  var y2 = b3.length;
  for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
    if (a8[i2] !== b3[i2]) {
      x2 = a8[i2];
      y2 = b3[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat(list, length) {
  if (!isArray$c(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i2;
  if (length === void 0) {
    length = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length += list[i2].length;
    }
  }
  var buffer2 = Buffer$2.allocUnsafe(length);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer2, pos);
    pos += buf.length;
  }
  return buffer2;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap$1(b3, n2, m2) {
  var i2 = b3[n2];
  b3[n2] = b3[m2];
  b3[m2] = i2;
}
Buffer$2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap$1(this, i2, i2 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap$1(this, i2, i2 + 3);
    swap$1(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap$1(this, i2, i2 + 7);
    swap$1(this, i2 + 1, i2 + 6);
    swap$1(this, i2 + 2, i2 + 5);
    swap$1(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals(b3) {
  if (!internalIsBuffer(b3))
    throw new TypeError("Argument must be a Buffer");
  if (this === b3)
    return true;
  return Buffer$2.compare(this, b3) === 0;
};
Buffer$2.prototype.inspect = function inspect() {
  var str2 = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str2 += " ... ";
  }
  return "<Buffer " + str2 + ">";
};
Buffer$2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x2 = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x2, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x2 = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer2.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer2.length + byteOffset;
  if (byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i2 + j2) !== read2(val, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i2 = 0; i2 < length; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer$2.prototype.write = function write(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext2, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext2 > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read$2(this, offset, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read$2(this, offset, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read$2(this, offset, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read$2(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext2, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext2 > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset] = value & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset + i2] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset + i2] = value & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset + i2] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 2); i2 < j2; ++i2) {
    buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset, 4); i2 < j2; ++i2) {
    buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i2] = value & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer$2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext2, max, min) {
  if (offset + ext2 > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write$2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write$2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer$2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str2) {
  str2 = stringtrim(str2).replace(INVALID_BASE64_RE, "");
  if (str2.length < 2)
    return "";
  while (str2.length % 4 !== 0) {
    str2 = str2 + "=";
  }
  return str2;
}
function stringtrim(str2) {
  if (str2.trim)
    return str2.trim();
  return str2.replace(/^\s+|\s+$/g, "");
}
function toHex(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str2) {
  var byteArray = [];
  for (var i2 = 0; i2 < str2.length; ++i2) {
    byteArray.push(str2.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str2, units) {
  var c3, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str2.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c3 = str2.charCodeAt(i2);
    hi = c3 >> 8;
    lo = c3 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str2) {
  return toByteArray(base64clean(str2));
}
function blitBuffer(src, dst, offset, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var sax$1 = {};
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter$2() {
  EventEmitter$2.init.call(this);
}
EventEmitter$2.EventEmitter = EventEmitter$2;
EventEmitter$2.usingDomains = false;
EventEmitter$2.prototype.domain = void 0;
EventEmitter$2.prototype._events = void 0;
EventEmitter$2.prototype._maxListeners = void 0;
EventEmitter$2.defaultMaxListeners = 10;
EventEmitter$2.init = function() {
  this.domain = null;
  if (EventEmitter$2.usingDomains) {
    if (domain.active)
      ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$2.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n2;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$2.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners2[i2].apply(self2, args);
  }
}
EventEmitter$2.prototype.emit = function emit(type) {
  var er, handler, len, args, i2, events2, domain2;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain2 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain2) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain2;
      er.domainThrown = false;
      domain2.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err.context = er;
      throw err;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type;
        w2.count = existing.length;
        emitWarning(w2);
      }
    }
  }
  return target;
}
function emitWarning(e3) {
  typeof console.warn === "function" ? console.warn(e3) : console.log(e3);
}
EventEmitter$2.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$2.prototype.on = EventEmitter$2.prototype.addListener;
EventEmitter$2.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g2() {
    target.removeListener(type, g2);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g2.listener = listener;
  return g2;
}
EventEmitter$2.prototype.once = function once(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$2.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$2.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2) {
    do {
      this.removeListener(type, listeners2[listeners2.length - 1]);
    } while (listeners2[0]);
  }
  return this;
};
EventEmitter$2.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter$2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter$2.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$2.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index2) {
  for (var i2 = index2, k4 = i2 + 1, n2 = list.length; k4 < n2; i2 += 1, k4 += 1)
    list[i2] = list[k4];
  list.pop();
}
function arrayClone(arr, i2) {
  var copy3 = new Array(i2);
  while (i2--)
    copy3[i2] = arr[i2];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue$1 = currentQueue.concat(queue$1);
  } else {
    queueIndex = -1;
  }
  if (queue$1.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue$1.length;
  while (len) {
    currentQueue = queue$1;
    queue$1 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue$1.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick$1(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue$1.push(new Item$1(fun, args));
  if (queue$1.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item$1(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform$1 = "browser";
var browser$1 = true;
var env = {};
var argv = [];
var version$1 = "";
var versions = {};
var release = {};
var config$2 = {};
function noop$3() {
}
var on = noop$3;
var addListener2 = noop$3;
var once2 = noop$3;
var off = noop$3;
var removeListener2 = noop$3;
var removeAllListeners2 = noop$3;
var emit$1 = noop$3;
function binding(name2) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick$1,
  title,
  browser: browser$1,
  env,
  argv,
  version: version$1,
  versions,
  on,
  addListener: addListener2,
  once: once2,
  off,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit$1,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform: platform$1,
  release,
  config: config$2,
  uptime
};
var inherits$1;
if (typeof Object.create === "function") {
  inherits$1 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$1 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
const inherits$2 = inherits$1;
var formatRegExp = /%[sdj%]/g;
function format$1(f3) {
  if (!isString$a(f3)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect2(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str2 = String(f3).replace(formatRegExp, function(x3) {
    if (x3 === "%%")
      return "%";
    if (i2 >= len)
      return x3;
    switch (x3) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_2) {
          return "[Circular]";
        }
      default:
        return x3;
    }
  });
  for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
    if (isNull(x2) || !isObject$3(x2)) {
      str2 += " " + x2;
    } else {
      str2 += " " + inspect2(x2);
    }
  }
  return str2;
}
function deprecate(fn, msg) {
  if (isUndefined$1(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set2) {
  if (isUndefined$1(debugEnviron))
    debugEnviron = {}.NODE_DEBUG || "";
  set2 = set2.toUpperCase();
  if (!debugs[set2]) {
    if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set2] = function() {
        var msg = format$1.apply(null, arguments);
        console.error("%s %d: %s", set2, pid, msg);
      };
    } else {
      debugs[set2] = function() {
      };
    }
  }
  return debugs[set2];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean$1(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined$1(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined$1(ctx.depth))
    ctx.depth = 2;
  if (isUndefined$1(ctx.colors))
    ctx.colors = false;
  if (isUndefined$1(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect2.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect2.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str2, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str2 + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str2;
  }
}
function stylizeNoColor(str2, styleType) {
  return str2;
}
function arrayToHash(array2) {
  var hash = {};
  array2.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction$7(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString$a(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction$7(value)) {
      var name2 = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name2 + "]", "special");
    }
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate$1(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base2 = "", array2 = false, braces = ["{", "}"];
  if (isArray$b(value)) {
    array2 = true;
    braces = ["[", "]"];
  }
  if (isFunction$7(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base2 = " [Function" + n2 + "]";
  }
  if (isRegExp$1(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate$1(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array2 || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array2) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined$1(value))
    return ctx.stylize("undefined", "undefined");
  if (isString$a(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$1(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean$1(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
    if (hasOwnProperty$5(value, String(i2))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
  var name2, str2, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str2 = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str2 = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str2 = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty$5(visibleKeys, key)) {
    name2 = "[" + key + "]";
  }
  if (!str2) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str2 = formatValue(ctx, desc.value, null);
      } else {
        str2 = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str2.indexOf("\n") > -1) {
        if (array2) {
          str2 = str2.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str2 = "\n" + str2.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str2 = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined$1(name2)) {
    if (array2 && key.match(/^\d+$/)) {
      return str2;
    }
    name2 = JSON.stringify("" + key);
    if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name2 = name2.substr(1, name2.length - 2);
      name2 = ctx.stylize(name2, "name");
    } else {
      name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name2 = ctx.stylize(name2, "string");
    }
  }
  return name2 + ": " + str2;
}
function reduceToSingleString(output, base2, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0)
      ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray$b(ar) {
  return Array.isArray(ar);
}
function isBoolean$1(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber$1(arg) {
  return typeof arg === "number";
}
function isString$a(arg) {
  return typeof arg === "string";
}
function isUndefined$1(arg) {
  return arg === void 0;
}
function isRegExp$1(re) {
  return isObject$3(re) && objectToString$2(re) === "[object RegExp]";
}
function isObject$3(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate$1(d2) {
  return isObject$3(d2) && objectToString$2(d2) === "[object Date]";
}
function isError(e3) {
  return isObject$3(e3) && (objectToString$2(e3) === "[object Error]" || e3 instanceof Error);
}
function isFunction$7(arg) {
  return typeof arg === "function";
}
function objectToString$2(o2) {
  return Object.prototype.toString.call(o2);
}
function _extend(origin, add2) {
  if (!add2 || !isObject$3(add2))
    return origin;
  var keys2 = Object.keys(add2);
  var i2 = keys2.length;
  while (i2--) {
    origin[keys2[i2]] = add2[keys2[i2]];
  }
  return origin;
}
function hasOwnProperty$5(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0)
    this.tail.next = entry;
  else
    this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0)
    this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0)
    return;
  var ret = this.head.data;
  if (this.length === 1)
    this.head = this.tail = null;
  else
    this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0)
    return "";
  var p2 = this.head;
  var ret = "" + p2.data;
  while (p2 = p2.next) {
    ret += s2 + p2.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n2) {
  if (this.length === 0)
    return Buffer$2.alloc(0);
  if (this.length === 1)
    return this.head.data;
  var ret = Buffer$2.allocUnsafe(n2 >>> 0);
  var p2 = this.head;
  var i2 = 0;
  while (p2) {
    p2.data.copy(ret, i2);
    i2 += p2.data.length;
    p2 = p2.next;
  }
  return ret;
};
var isBufferEncoding = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer2) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
    buffer2.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer2 = buffer2.slice(available, buffer2.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer2.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer2);
  var end = buffer2.length;
  if (this.charLength) {
    buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
    end -= this.charReceived;
  }
  charStr += buffer2.toString(this.encoding, 0, end);
  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  if (charCode >= 55296 && charCode <= 56319) {
    var size2 = this.surrogateSize;
    this.charLength += size2;
    this.charReceived += size2;
    this.charBuffer.copy(this.charBuffer, size2, 0, size2);
    buffer2.copy(this.charBuffer, 0, 0, size2);
    return charStr.substring(0, end);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
  var i2 = buffer2.length >= 3 ? 3 : buffer2.length;
  for (; i2 > 0; i2--) {
    var c3 = buffer2[buffer2.length - i2];
    if (i2 == 1 && c3 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c3 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c3 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder.prototype.end = function(buffer2) {
  var res = "";
  if (buffer2 && buffer2.length)
    res = this.write(buffer2);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer2) {
  return buffer2.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
const stringDecoder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StringDecoder
}, Symbol.toStringTag, { value: "Module" }));
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$2(Readable, EventEmitter$2);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream2) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function")
    this._read = options2.read;
  EventEmitter$2.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;
  if (!state.objectMode && typeof chunk === "string") {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = Buffer$2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream2, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e3 = new Error("stream.push() after EOF");
      stream2.emit("error", e3);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n2) {
  if (n2 >= MAX_HWM) {
    n2 = MAX_HWM;
  } else {
    n2--;
    n2 |= n2 >>> 1;
    n2 |= n2 >>> 2;
    n2 |= n2 >>> 4;
    n2 |= n2 >>> 8;
    n2 |= n2 >>> 16;
    n2++;
  }
  return n2;
}
function howMuchToRead(n2, state) {
  if (n2 <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n2 !== n2) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n2 > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n2);
  if (n2 <= state.length)
    return n2;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
Readable.prototype.read = function(n2) {
  debug("read", n2);
  n2 = parseInt(n2, 10);
  var state = this._readableState;
  var nOrig = n2;
  if (n2 !== 0)
    state.emittedReadable = false;
  if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }
  n2 = howMuchToRead(n2, state);
  if (n2 === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }
  var doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n2 < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0)
      state.needReadable = true;
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading)
      n2 = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n2 > 0)
    ret = fromList(n2, state);
  else
    ret = null;
  if (ret === null) {
    state.needReadable = true;
    n2 = 0;
  } else {
    state.length -= n2;
  }
  if (state.length === 0) {
    if (!state.ended)
      state.needReadable = true;
    if (nOrig !== n2 && state.ended)
      endReadable(this);
  }
  if (ret !== null)
    this.emit("data", ret);
  return ret;
};
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer$2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state = stream2._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick$1(emitReadable_, stream2);
    else
      emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick$1(maybeReadMore_, stream2, state);
  }
}
function maybeReadMore_(stream2, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n2) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend2 : cleanup;
  if (state.endEmitted)
    nextTick$1(endFn);
  else
    src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  function onend2() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend2);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0)
      dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;
  if (state.pipesCount === 0)
    return this;
  if (state.pipesCount === 1) {
    if (dest && dest !== state.pipes)
      return this;
    if (!dest)
      dest = state.pipes;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i2 = indexOf2(state.pipes, dest);
  if (i2 === -1)
    return this;
  state.pipes.splice(i2, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter$2.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false)
      this.resume();
  } else if (ev === "readable") {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick$1(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = true;
    resume(this, state);
  }
  return this;
};
function resume(stream2, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick$1(resume_, stream2, state);
  }
}
function resume_(stream2, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state.flowing && !state.reading)
    stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state = stream2._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (state.objectMode && (chunk === null || chunk === void 0))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach$1(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n2) {
    debug("wrapped _read", n2);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n2, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n2 || n2 >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n2, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n2, list, hasStrings) {
  var ret;
  if (n2 < list.head.data.length) {
    ret = list.head.data.slice(0, n2);
    list.head.data = list.head.data.slice(n2);
  } else if (n2 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
  }
  return ret;
}
function copyFromBufferString(n2, list) {
  var p2 = list.head;
  var c3 = 1;
  var ret = p2.data;
  n2 -= ret.length;
  while (p2 = p2.next) {
    var str2 = p2.data;
    var nb = n2 > str2.length ? str2.length : n2;
    if (nb === str2.length)
      ret += str2;
    else
      ret += str2.slice(0, n2);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === str2.length) {
        ++c3;
        if (p2.next)
          list.head = p2.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = str2.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function copyFromBuffer(n2, list) {
  var ret = Buffer$2.allocUnsafe(n2);
  var p2 = list.head;
  var c3 = 1;
  p2.data.copy(ret);
  n2 -= p2.data.length;
  while (p2 = p2.next) {
    var buf = p2.data;
    var nb = n2 > buf.length ? buf.length : n2;
    buf.copy(ret, ret.length - n2, 0, nb);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === buf.length) {
        ++c3;
        if (p2.next)
          list.head = p2.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = buf.slice(nb);
      }
      break;
    }
    ++c3;
  }
  list.length -= c3;
  return ret;
}
function endReadable(stream2) {
  var state = stream2._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick$1(endReadableNT, state, stream2);
  }
}
function endReadableNT(state, stream2) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach$1(xs, f3) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    f3(xs[i2], i2);
  }
}
function indexOf2(xs, x2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2)
      return i2;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$2(Writable, EventEmitter$2);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options2, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write;
    if (typeof options2.writev === "function")
      this._writev = options2.writev;
  }
  EventEmitter$2.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick$1(cb, er);
}
function validChunk(stream2, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer$2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick$1(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer$2.isBuffer(chunk))
    encoding = "buffer";
  else if (!encoding)
    encoding = state.defaultEncoding;
  if (typeof cb !== "function")
    cb = nop;
  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function() {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
      clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string")
    encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
    throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer$2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer$2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last2 = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream2._writev(chunk, state.onwrite);
  else
    stream2._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream2, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick$1(cb, er);
  else
    cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream2, er) {
  var state = stream2._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream2, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream2, state);
    }
    if (sync) {
      nextTick$1(afterWrite, stream2, state, finished, cb);
    } else {
      afterWrite(stream2, state, finished, cb);
    }
  }
}
function afterWrite(stream2, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream2, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream2, state);
}
function onwriteDrain(stream2, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state.bufferedRequestCount;
    var buffer2 = new Array(l2);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer2[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream2, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0)
    this.write(chunk, encoding);
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream2, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream2, state);
      state.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state);
    }
  }
  return need;
}
function endWritable(stream2, state, cb) {
  state.ending = true;
  finishMaybe(stream2, state);
  if (cb) {
    if (state.finished)
      nextTick$1(cb);
    else
      stream2.once("finish", cb);
  }
  state.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
inherits$2(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (var v$1 = 0; v$1 < keys.length; v$1++) {
  var method = keys[v$1];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false)
    this.readable = false;
  if (options2 && options2.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick$1(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$2(Transform$1, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream2, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream2.push(data);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform$1(options2) {
  if (!(this instanceof Transform$1))
    return new Transform$1(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream2, er);
      });
    else
      done(stream2);
  });
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n2) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er)
    return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$2(PassThrough, Transform$1);
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform$1.call(this, options2);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$2(Stream, EventEmitter$2);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform$1;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter$2.call(this);
}
Stream.prototype.pipe = function(dest, options2) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options2 || options2.end !== false)) {
    source.on("end", onend2);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend2() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter$2.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend2);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
const stream = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform$1,
  Writable,
  default: Stream
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(stream);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(stringDecoder);
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S2.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit3(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o2) {
        function F2() {
        }
        F2.prototype = o2;
        var newf = new F2();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o2) {
        var a8 = [];
        for (var i2 in o2)
          if (o2.hasOwnProperty(i2))
            a8.push(i2);
        return a8;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
        var len = parser[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m2 + parser.position;
    }
    function clearBuffers(parser) {
      for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
        parser[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write: write5,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require$$0.Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h2) {
            if (!h2) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h2;
              return h2;
            }
            me.on(ev, h2);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer$2 === "function" && typeof Buffer$2.isBuffer === "function" && Buffer$2.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1.StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c3) {
      return c3 === " " || c3 === "\n" || c3 === "\r" || c3 === "	";
    }
    function isQuote(c3) {
      return c3 === '"' || c3 === "'";
    }
    function isAttribEnd(c3) {
      return c3 === ">" || isWhitespace(c3);
    }
    function isMatch(regex, c3) {
      return regex.test(c3);
    }
    function notMatch(regex, c3) {
      return !isMatch(regex, c3);
    }
    var S2 = 0;
    sax2.STATE = {
      BEGIN: S2++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S2++,
      // leading whitespace
      TEXT: S2++,
      // general stuff
      TEXT_ENTITY: S2++,
      // &amp and such.
      OPEN_WAKA: S2++,
      // <
      SGML_DECL: S2++,
      // <!BLARG
      SGML_DECL_QUOTED: S2++,
      // <!BLARG foo "bar
      DOCTYPE: S2++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S2++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S2++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S2++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S2++,
      // <!-
      COMMENT: S2++,
      // <!--
      COMMENT_ENDING: S2++,
      // <!-- blah -
      COMMENT_ENDED: S2++,
      // <!-- blah --
      CDATA: S2++,
      // <![CDATA[ something
      CDATA_ENDING: S2++,
      // ]
      CDATA_ENDING_2: S2++,
      // ]]
      PROC_INST: S2++,
      // <?hi
      PROC_INST_BODY: S2++,
      // <?hi there
      PROC_INST_ENDING: S2++,
      // <?hi "there" ?
      OPEN_TAG: S2++,
      // <strong
      OPEN_TAG_SLASH: S2++,
      // <strong /
      ATTRIB: S2++,
      // <a
      ATTRIB_NAME: S2++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S2++,
      // <a foo _
      ATTRIB_VALUE: S2++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S2++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S2++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S2++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S2++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S2++,
      // <foo bar=&quot
      CLOSE_TAG: S2++,
      // </a
      CLOSE_TAG_SAW_WHITE: S2++,
      // </a   >
      SCRIPT: S2++,
      // <script> ...
      SCRIPT_ENDING: S2++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e3 = sax2.ENTITIES[key];
      var s3 = typeof e3 === "number" ? String.fromCharCode(e3) : e3;
      sax2.ENTITIES[key] = s3;
    });
    for (var s2 in sax2.STATE) {
      sax2.STATE[sax2.STATE[s2]] = s2;
    }
    S2 = sax2.STATE;
    function emit3(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit3(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit3(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit3(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit3(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name2, attribute) {
      var i2 = name2.indexOf(":");
      var qualName = i2 < 0 ? ["", name2] : name2.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name2 === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(
              parser,
              "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p2) {
            emitNode(parser, "onopennamespace", {
              prefix: p2,
              uri: tag.ns[p2]
            });
          });
        }
        for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
          var nv = parser.attribList[i2];
          var name2 = nv[0];
          var value = nv[1];
          var qualName = qname(name2, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a8 = {
            name: name2,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a8.uri = prefix;
          }
          parser.tag.attributes[name2] = a8;
          emitNode(parser, "onattribute", a8);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S2.SCRIPT;
        } else {
          parser.state = S2.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S2.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S2.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S2.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s3 = parser.tags.length;
      while (s3-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x2 = {};
        for (var i2 in tag.ns) {
          x2[i2] = tag.ns[i2];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p2) {
            var n2 = tag.ns[p2];
            emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
          });
        }
      }
      if (t2 === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S2.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c3) {
      if (c3 === "<") {
        parser.state = S2.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c3)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c3;
        parser.state = S2.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write5(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(
          parser,
          "Cannot write after close. Assign an onready handler."
        );
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c3 = "";
      while (true) {
        c3 = charAt(chunk, i2++);
        parser.c = c3;
        if (!c3) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c3 === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S2.BEGIN:
            parser.state = S2.BEGIN_WHITESPACE;
            if (c3 === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c3);
            continue;
          case S2.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c3);
            continue;
          case S2.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i2 - 1;
              while (c3 && c3 !== "<" && c3 !== "&") {
                c3 = charAt(chunk, i2++);
                if (c3 && parser.trackPosition) {
                  parser.position++;
                  if (c3 === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c3 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S2.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c3) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c3 === "&") {
                parser.state = S2.TEXT_ENTITY;
              } else {
                parser.textNode += c3;
              }
            }
            continue;
          case S2.SCRIPT:
            if (c3 === "<") {
              parser.state = S2.SCRIPT_ENDING;
            } else {
              parser.script += c3;
            }
            continue;
          case S2.SCRIPT_ENDING:
            if (c3 === "/") {
              parser.state = S2.CLOSE_TAG;
            } else {
              parser.script += "<" + c3;
              parser.state = S2.SCRIPT;
            }
            continue;
          case S2.OPEN_WAKA:
            if (c3 === "!") {
              parser.state = S2.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c3))
              ;
            else if (isMatch(nameStart, c3)) {
              parser.state = S2.OPEN_TAG;
              parser.tagName = c3;
            } else if (c3 === "/") {
              parser.state = S2.CLOSE_TAG;
              parser.tagName = "";
            } else if (c3 === "?") {
              parser.state = S2.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c3 = new Array(pad).join(" ") + c3;
              }
              parser.textNode += "<" + c3;
              parser.state = S2.TEXT;
            }
            continue;
          case S2.SGML_DECL:
            if ((parser.sgmlDecl + c3).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S2.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c3 === "--") {
              parser.state = S2.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c3).toUpperCase() === DOCTYPE) {
              parser.state = S2.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  "Inappropriately located doctype declaration"
                );
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c3 === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S2.TEXT;
            } else if (isQuote(c3)) {
              parser.state = S2.SGML_DECL_QUOTED;
              parser.sgmlDecl += c3;
            } else {
              parser.sgmlDecl += c3;
            }
            continue;
          case S2.SGML_DECL_QUOTED:
            if (c3 === parser.q) {
              parser.state = S2.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c3;
            continue;
          case S2.DOCTYPE:
            if (c3 === ">") {
              parser.state = S2.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c3;
              if (c3 === "[") {
                parser.state = S2.DOCTYPE_DTD;
              } else if (isQuote(c3)) {
                parser.state = S2.DOCTYPE_QUOTED;
                parser.q = c3;
              }
            }
            continue;
          case S2.DOCTYPE_QUOTED:
            parser.doctype += c3;
            if (c3 === parser.q) {
              parser.q = "";
              parser.state = S2.DOCTYPE;
            }
            continue;
          case S2.DOCTYPE_DTD:
            parser.doctype += c3;
            if (c3 === "]") {
              parser.state = S2.DOCTYPE;
            } else if (isQuote(c3)) {
              parser.state = S2.DOCTYPE_DTD_QUOTED;
              parser.q = c3;
            }
            continue;
          case S2.DOCTYPE_DTD_QUOTED:
            parser.doctype += c3;
            if (c3 === parser.q) {
              parser.state = S2.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S2.COMMENT:
            if (c3 === "-") {
              parser.state = S2.COMMENT_ENDING;
            } else {
              parser.comment += c3;
            }
            continue;
          case S2.COMMENT_ENDING:
            if (c3 === "-") {
              parser.state = S2.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c3;
              parser.state = S2.COMMENT;
            }
            continue;
          case S2.COMMENT_ENDED:
            if (c3 !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c3;
              parser.state = S2.COMMENT;
            } else {
              parser.state = S2.TEXT;
            }
            continue;
          case S2.CDATA:
            if (c3 === "]") {
              parser.state = S2.CDATA_ENDING;
            } else {
              parser.cdata += c3;
            }
            continue;
          case S2.CDATA_ENDING:
            if (c3 === "]") {
              parser.state = S2.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c3;
              parser.state = S2.CDATA;
            }
            continue;
          case S2.CDATA_ENDING_2:
            if (c3 === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S2.TEXT;
            } else if (c3 === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c3;
              parser.state = S2.CDATA;
            }
            continue;
          case S2.PROC_INST:
            if (c3 === "?") {
              parser.state = S2.PROC_INST_ENDING;
            } else if (isWhitespace(c3)) {
              parser.state = S2.PROC_INST_BODY;
            } else {
              parser.procInstName += c3;
            }
            continue;
          case S2.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c3)) {
              continue;
            } else if (c3 === "?") {
              parser.state = S2.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c3;
            }
            continue;
          case S2.PROC_INST_ENDING:
            if (c3 === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S2.TEXT;
            } else {
              parser.procInstBody += "?" + c3;
              parser.state = S2.PROC_INST_BODY;
            }
            continue;
          case S2.OPEN_TAG:
            if (isMatch(nameBody, c3)) {
              parser.tagName += c3;
            } else {
              newTag(parser);
              if (c3 === ">") {
                openTag(parser);
              } else if (c3 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c3)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S2.ATTRIB;
              }
            }
            continue;
          case S2.OPEN_TAG_SLASH:
            if (c3 === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S2.ATTRIB;
            }
            continue;
          case S2.ATTRIB:
            if (isWhitespace(c3)) {
              continue;
            } else if (c3 === ">") {
              openTag(parser);
            } else if (c3 === "/") {
              parser.state = S2.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              parser.attribName = c3;
              parser.attribValue = "";
              parser.state = S2.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_NAME:
            if (c3 === "=") {
              parser.state = S2.ATTRIB_VALUE;
            } else if (c3 === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c3)) {
              parser.state = S2.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c3)) {
              parser.attribName += c3;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_NAME_SAW_WHITE:
            if (c3 === "=") {
              parser.state = S2.ATTRIB_VALUE;
            } else if (isWhitespace(c3)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c3 === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c3)) {
                parser.attribName = c3;
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S2.ATTRIB;
              }
            }
            continue;
          case S2.ATTRIB_VALUE:
            if (isWhitespace(c3)) {
              continue;
            } else if (isQuote(c3)) {
              parser.q = c3;
              parser.state = S2.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S2.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c3;
            }
            continue;
          case S2.ATTRIB_VALUE_QUOTED:
            if (c3 !== parser.q) {
              if (c3 === "&") {
                parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c3;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S2.ATTRIB_VALUE_CLOSED;
            continue;
          case S2.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c3)) {
              parser.state = S2.ATTRIB;
            } else if (c3 === ">") {
              openTag(parser);
            } else if (c3 === "/") {
              parser.state = S2.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c3;
              parser.attribValue = "";
              parser.state = S2.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S2.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c3)) {
              if (c3 === "&") {
                parser.state = S2.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c3;
              }
              continue;
            }
            attrib(parser);
            if (c3 === ">") {
              openTag(parser);
            } else {
              parser.state = S2.ATTRIB;
            }
            continue;
          case S2.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c3)) {
                continue;
              } else if (notMatch(nameStart, c3)) {
                if (parser.script) {
                  parser.script += "</" + c3;
                  parser.state = S2.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c3;
              }
            } else if (c3 === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c3)) {
              parser.tagName += c3;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S2.SCRIPT;
            } else {
              if (!isWhitespace(c3)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S2.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S2.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c3)) {
              continue;
            }
            if (c3 === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S2.TEXT_ENTITY:
          case S2.ATTRIB_VALUE_ENTITY_Q:
          case S2.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer2;
            switch (parser.state) {
              case S2.TEXT_ENTITY:
                returnState = S2.TEXT;
                buffer2 = "textNode";
                break;
              case S2.ATTRIB_VALUE_ENTITY_Q:
                returnState = S2.ATTRIB_VALUE_QUOTED;
                buffer2 = "attribValue";
                break;
              case S2.ATTRIB_VALUE_ENTITY_U:
                returnState = S2.ATTRIB_VALUE_UNQUOTED;
                buffer2 = "attribValue";
                break;
            }
            if (c3 === ";") {
              parser[buffer2] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c3)) {
              parser.entity += c3;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer2] += "&" + parser.entity + c3;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode2 = String.fromCharCode;
        var floor2 = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index2 = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index2 < length) {
            var codePoint = Number(arguments[index2]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor2(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode2.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
var arrayHelper = {
  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    return Object.prototype.toString.call(value) === "[object Array]";
  }
};
var isArray$a = arrayHelper.isArray;
var optionsHelper = {
  copyOptions: function(options2) {
    var key, copy3 = {};
    for (key in options2) {
      if (options2.hasOwnProperty(key)) {
        copy3[key] = options2[key];
      }
    }
    return copy3;
  },
  ensureFlagExists: function(item, options2) {
    if (!(item in options2) || typeof options2[item] !== "boolean") {
      options2[item] = false;
    }
  },
  ensureSpacesExists: function(options2) {
    if (!("spaces" in options2) || typeof options2.spaces !== "number" && typeof options2.spaces !== "string") {
      options2.spaces = 0;
    }
  },
  ensureAlwaysArrayExists: function(options2) {
    if (!("alwaysArray" in options2) || typeof options2.alwaysArray !== "boolean" && !isArray$a(options2.alwaysArray)) {
      options2.alwaysArray = false;
    }
  },
  ensureKeyExists: function(key, options2) {
    if (!(key + "Key" in options2) || typeof options2[key + "Key"] !== "string") {
      options2[key + "Key"] = options2.compact ? "_" + key : key;
    }
  },
  checkFnExists: function(key, options2) {
    return key + "Fn" in options2;
  }
};
var sax = sax$1;
var helper$2 = optionsHelper;
var isArray$9 = arrayHelper.isArray;
var options;
var currentElement$1;
function validateOptions$2(userOptions) {
  options = helper$2.copyOptions(userOptions);
  helper$2.ensureFlagExists("ignoreDeclaration", options);
  helper$2.ensureFlagExists("ignoreInstruction", options);
  helper$2.ensureFlagExists("ignoreAttributes", options);
  helper$2.ensureFlagExists("ignoreText", options);
  helper$2.ensureFlagExists("ignoreComment", options);
  helper$2.ensureFlagExists("ignoreCdata", options);
  helper$2.ensureFlagExists("ignoreDoctype", options);
  helper$2.ensureFlagExists("compact", options);
  helper$2.ensureFlagExists("alwaysChildren", options);
  helper$2.ensureFlagExists("addParent", options);
  helper$2.ensureFlagExists("trim", options);
  helper$2.ensureFlagExists("nativeType", options);
  helper$2.ensureFlagExists("nativeTypeAttributes", options);
  helper$2.ensureFlagExists("sanitize", options);
  helper$2.ensureFlagExists("instructionHasAttributes", options);
  helper$2.ensureFlagExists("captureSpacesBetweenElements", options);
  helper$2.ensureAlwaysArrayExists(options);
  helper$2.ensureKeyExists("declaration", options);
  helper$2.ensureKeyExists("instruction", options);
  helper$2.ensureKeyExists("attributes", options);
  helper$2.ensureKeyExists("text", options);
  helper$2.ensureKeyExists("comment", options);
  helper$2.ensureKeyExists("cdata", options);
  helper$2.ensureKeyExists("doctype", options);
  helper$2.ensureKeyExists("type", options);
  helper$2.ensureKeyExists("name", options);
  helper$2.ensureKeyExists("elements", options);
  helper$2.ensureKeyExists("parent", options);
  return options;
}
function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === "true") {
    return true;
  } else if (bValue === "false") {
    return false;
  }
  return value;
}
function addField(type, value) {
  var key;
  if (options.compact) {
    if (!currentElement$1[options[type + "Key"]] && (isArray$9(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
      currentElement$1[options[type + "Key"]] = [];
    }
    if (currentElement$1[options[type + "Key"]] && !isArray$9(currentElement$1[options[type + "Key"]])) {
      currentElement$1[options[type + "Key"]] = [currentElement$1[options[type + "Key"]]];
    }
    if (type + "Fn" in options && typeof value === "string") {
      value = options[type + "Fn"](value, currentElement$1);
    }
    if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement$1);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement$1)] = temp;
          }
        }
      }
    }
    if (isArray$9(currentElement$1[options[type + "Key"]])) {
      currentElement$1[options[type + "Key"]].push(value);
    } else {
      currentElement$1[options[type + "Key"]] = value;
    }
  } else {
    if (!currentElement$1[options.elementsKey]) {
      currentElement$1[options.elementsKey] = [];
    }
    var element = {};
    element[options.typeKey] = type;
    if (type === "instruction") {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement$1) : key;
      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];
        if ("instructionFn" in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement$1);
        }
      } else {
        if ("instructionFn" in options) {
          value[key] = options.instructionFn(value[key], key, currentElement$1);
        }
        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + "Fn" in options) {
        value = options[type + "Fn"](value, currentElement$1);
      }
      element[options[type + "Key"]] = value;
    }
    if (options.addParent) {
      element[options.parentKey] = currentElement$1;
    }
    currentElement$1[options.elementsKey].push(element);
  }
}
function manipulateAttributes(attributes) {
  if ("attributesFn" in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement$1);
  }
  if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim)
          attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ("attributeValueFn" in options)
          attributes[key] = options.attributeValueFn(attributes[key], key, currentElement$1);
        if ("attributeNameFn" in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement$1)] = temp;
        }
      }
    }
  }
  return attributes;
}
function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === "xml") {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement$1[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement$1[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement$1[options.declarationKey][options.parentKey] = currentElement$1;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField("instruction", value);
  }
}
function onStartElement(name2, attributes) {
  var element;
  if (typeof name2 === "object") {
    attributes = name2.attributes;
    name2 = name2.name;
  }
  attributes = manipulateAttributes(attributes);
  if ("elementNameFn" in options) {
    name2 = options.elementNameFn(name2, currentElement$1);
  }
  if (options.compact) {
    element = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (!(name2 in currentElement$1) && (isArray$9(options.alwaysArray) ? options.alwaysArray.indexOf(name2) !== -1 : options.alwaysArray)) {
      currentElement$1[name2] = [];
    }
    if (currentElement$1[name2] && !isArray$9(currentElement$1[name2])) {
      currentElement$1[name2] = [currentElement$1[name2]];
    }
    if (isArray$9(currentElement$1[name2])) {
      currentElement$1[name2].push(element);
    } else {
      currentElement$1[name2] = element;
    }
  } else {
    if (!currentElement$1[options.elementsKey]) {
      currentElement$1[options.elementsKey] = [];
    }
    element = {};
    element[options.typeKey] = "element";
    element[options.nameKey] = name2;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }
    currentElement$1[options.elementsKey].push(element);
  }
  element[options.parentKey] = currentElement$1;
  currentElement$1 = element;
}
function onText(text) {
  if (options.ignoreText) {
    return;
  }
  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text = text.trim();
  }
  if (options.nativeType) {
    text = nativeType(text);
  }
  if (options.sanitize) {
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  addField("text", text);
}
function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField("comment", comment);
}
function onEndElement(name2) {
  var parentElement = currentElement$1[options.parentKey];
  if (!options.addParent) {
    delete currentElement$1[options.parentKey];
  }
  currentElement$1 = parentElement;
}
function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField("cdata", cdata);
}
function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, "");
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField("doctype", doctype);
}
function onError(error2) {
  error2.note = error2;
}
var xml2js$2 = function(xml, userOptions) {
  var parser = sax.parser(true, {});
  var result = {};
  currentElement$1 = result;
  options = validateOptions$2(userOptions);
  {
    parser.opt = { strictEntities: true };
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  }
  {
    parser.write(xml).close();
  }
  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }
  return result;
};
var helper$1 = optionsHelper;
var xml2js$1 = xml2js$2;
function validateOptions$1(userOptions) {
  var options2 = helper$1.copyOptions(userOptions);
  helper$1.ensureSpacesExists(options2);
  return options2;
}
var xml2json$1 = function(xml, userOptions) {
  var options2, js, json, parentKey;
  options2 = validateOptions$1(userOptions);
  js = xml2js$1(xml, options2);
  parentKey = "compact" in options2 && options2.compact ? "_parent" : "parent";
  if ("addParent" in options2 && options2.addParent) {
    json = JSON.stringify(js, function(k4, v2) {
      return k4 === parentKey ? "_" : v2;
    }, options2.spaces);
  } else {
    json = JSON.stringify(js, null, options2.spaces);
  }
  return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
};
var helper = optionsHelper;
var isArray$8 = arrayHelper.isArray;
var currentElement, currentElementName;
function validateOptions(userOptions) {
  var options2 = helper.copyOptions(userOptions);
  helper.ensureFlagExists("ignoreDeclaration", options2);
  helper.ensureFlagExists("ignoreInstruction", options2);
  helper.ensureFlagExists("ignoreAttributes", options2);
  helper.ensureFlagExists("ignoreText", options2);
  helper.ensureFlagExists("ignoreComment", options2);
  helper.ensureFlagExists("ignoreCdata", options2);
  helper.ensureFlagExists("ignoreDoctype", options2);
  helper.ensureFlagExists("compact", options2);
  helper.ensureFlagExists("indentText", options2);
  helper.ensureFlagExists("indentCdata", options2);
  helper.ensureFlagExists("indentAttributes", options2);
  helper.ensureFlagExists("indentInstruction", options2);
  helper.ensureFlagExists("fullTagEmptyElement", options2);
  helper.ensureFlagExists("noQuotesForNativeAttributes", options2);
  helper.ensureSpacesExists(options2);
  if (typeof options2.spaces === "number") {
    options2.spaces = Array(options2.spaces + 1).join(" ");
  }
  helper.ensureKeyExists("declaration", options2);
  helper.ensureKeyExists("instruction", options2);
  helper.ensureKeyExists("attributes", options2);
  helper.ensureKeyExists("text", options2);
  helper.ensureKeyExists("comment", options2);
  helper.ensureKeyExists("cdata", options2);
  helper.ensureKeyExists("doctype", options2);
  helper.ensureKeyExists("type", options2);
  helper.ensureKeyExists("name", options2);
  helper.ensureKeyExists("elements", options2);
  return options2;
}
function writeIndentation(options2, depth, firstLine) {
  return (!firstLine && options2.spaces ? "\n" : "") + Array(depth + 1).join(options2.spaces);
}
function writeAttributes(attributes, options2, depth) {
  if (options2.ignoreAttributes) {
    return "";
  }
  if ("attributesFn" in options2) {
    attributes = options2.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
      quote = options2.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
      attr = "" + attributes[key];
      attr = attr.replace(/"/g, "&quot;");
      attrName = "attributeNameFn" in options2 ? options2.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push(options2.spaces && options2.indentAttributes ? writeIndentation(options2, depth + 1, false) : " ");
      result.push(attrName + "=" + quote + ("attributeValueFn" in options2 ? options2.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options2.spaces && options2.indentAttributes) {
    result.push(writeIndentation(options2, depth, false));
  }
  return result.join("");
}
function writeDeclaration(declaration, options2, depth) {
  currentElement = declaration;
  currentElementName = "xml";
  return options2.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options2.attributesKey], options2, depth) + "?>";
}
function writeInstruction(instruction, options2, depth) {
  if (options2.ignoreInstruction) {
    return "";
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = "instructionNameFn" in options2 ? options2.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === "object") {
    currentElement = instruction;
    currentElementName = instructionName;
    return "<?" + instructionName + writeAttributes(instruction[key][options2.attributesKey], options2, depth) + "?>";
  } else {
    var instructionValue = instruction[key] ? instruction[key] : "";
    if ("instructionFn" in options2)
      instructionValue = options2.instructionFn(instructionValue, key, currentElementName, currentElement);
    return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
  }
}
function writeComment(comment, options2) {
  return options2.ignoreComment ? "" : "<!--" + ("commentFn" in options2 ? options2.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
}
function writeCdata(cdata, options2) {
  return options2.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options2 ? options2.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
}
function writeDoctype(doctype, options2) {
  return options2.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options2 ? options2.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
}
function writeText(text, options2) {
  if (options2.ignoreText)
    return "";
  text = "" + text;
  text = text.replace(/&amp;/g, "&");
  text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return "textFn" in options2 ? options2.textFn(text, currentElementName, currentElement) : text;
}
function hasContent(element, options2) {
  var i2;
  if (element.elements && element.elements.length) {
    for (i2 = 0; i2 < element.elements.length; ++i2) {
      switch (element.elements[i2][options2.typeKey]) {
        case "text":
          if (options2.indentText) {
            return true;
          }
          break;
        case "cdata":
          if (options2.indentCdata) {
            return true;
          }
          break;
        case "instruction":
          if (options2.indentInstruction) {
            return true;
          }
          break;
        case "doctype":
        case "comment":
        case "element":
          return true;
        default:
          return true;
      }
    }
  }
  return false;
}
function writeElement(element, options2, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [], elementName = "elementNameFn" in options2 ? options2.elementNameFn(element.name, element) : element.name;
  xml.push("<" + elementName);
  if (element[options2.attributesKey]) {
    xml.push(writeAttributes(element[options2.attributesKey], options2, depth));
  }
  var withClosingTag = element[options2.elementsKey] && element[options2.elementsKey].length || element[options2.attributesKey] && element[options2.attributesKey]["xml:space"] === "preserve";
  if (!withClosingTag) {
    if ("fullTagEmptyElementFn" in options2) {
      withClosingTag = options2.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options2.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml.push(">");
    if (element[options2.elementsKey] && element[options2.elementsKey].length) {
      xml.push(writeElements(element[options2.elementsKey], options2, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }
    xml.push(options2.spaces && hasContent(element, options2) ? "\n" + Array(depth + 1).join(options2.spaces) : "");
    xml.push("</" + elementName + ">");
  } else {
    xml.push("/>");
  }
  return xml.join("");
}
function writeElements(elements, options2, depth, firstLine) {
  return elements.reduce(function(xml, element) {
    var indent = writeIndentation(options2, depth, firstLine && !xml);
    switch (element.type) {
      case "element":
        return xml + indent + writeElement(element, options2, depth);
      case "comment":
        return xml + indent + writeComment(element[options2.commentKey], options2);
      case "doctype":
        return xml + indent + writeDoctype(element[options2.doctypeKey], options2);
      case "cdata":
        return xml + (options2.indentCdata ? indent : "") + writeCdata(element[options2.cdataKey], options2);
      case "text":
        return xml + (options2.indentText ? indent : "") + writeText(element[options2.textKey], options2);
      case "instruction":
        var instruction = {};
        instruction[element[options2.nameKey]] = element[options2.attributesKey] ? element : element[options2.instructionKey];
        return xml + (options2.indentInstruction ? indent : "") + writeInstruction(instruction, options2, depth);
    }
  }, "");
}
function hasContentCompact(element, options2, anyContent) {
  var key;
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
        case options2.parentKey:
        case options2.attributesKey:
          break;
        case options2.textKey:
          if (options2.indentText || anyContent) {
            return true;
          }
          break;
        case options2.cdataKey:
          if (options2.indentCdata || anyContent) {
            return true;
          }
          break;
        case options2.instructionKey:
          if (options2.indentInstruction || anyContent) {
            return true;
          }
          break;
        case options2.doctypeKey:
        case options2.commentKey:
          return true;
        default:
          return true;
      }
    }
  }
  return false;
}
function writeElementCompact(element, name2, options2, depth, indent) {
  currentElement = element;
  currentElementName = name2;
  var elementName = "elementNameFn" in options2 ? options2.elementNameFn(name2, element) : name2;
  if (typeof element === "undefined" || element === null || element === "") {
    return "fullTagEmptyElementFn" in options2 && options2.fullTagEmptyElementFn(name2, element) || options2.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
  }
  var xml = [];
  if (name2) {
    xml.push("<" + elementName);
    if (typeof element !== "object") {
      xml.push(">" + writeText(element, options2) + "</" + elementName + ">");
      return xml.join("");
    }
    if (element[options2.attributesKey]) {
      xml.push(writeAttributes(element[options2.attributesKey], options2, depth));
    }
    var withClosingTag = hasContentCompact(element, options2, true) || element[options2.attributesKey] && element[options2.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options2) {
        withClosingTag = options2.fullTagEmptyElementFn(name2, element);
      } else {
        withClosingTag = options2.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push(">");
    } else {
      xml.push("/>");
      return xml.join("");
    }
  }
  xml.push(writeElementsCompact(element, options2, depth + 1, false));
  currentElement = element;
  currentElementName = name2;
  if (name2) {
    xml.push((indent ? writeIndentation(options2, depth, false) : "") + "</" + elementName + ">");
  }
  return xml.join("");
}
function writeElementsCompact(element, options2, depth, firstLine) {
  var i2, key, nodes, xml = [];
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray$8(element[key]) ? element[key] : [element[key]];
      for (i2 = 0; i2 < nodes.length; ++i2) {
        switch (key) {
          case options2.declarationKey:
            xml.push(writeDeclaration(nodes[i2], options2, depth));
            break;
          case options2.instructionKey:
            xml.push((options2.indentInstruction ? writeIndentation(options2, depth, firstLine) : "") + writeInstruction(nodes[i2], options2, depth));
            break;
          case options2.attributesKey:
          case options2.parentKey:
            break;
          case options2.textKey:
            xml.push((options2.indentText ? writeIndentation(options2, depth, firstLine) : "") + writeText(nodes[i2], options2));
            break;
          case options2.cdataKey:
            xml.push((options2.indentCdata ? writeIndentation(options2, depth, firstLine) : "") + writeCdata(nodes[i2], options2));
            break;
          case options2.doctypeKey:
            xml.push(writeIndentation(options2, depth, firstLine) + writeDoctype(nodes[i2], options2));
            break;
          case options2.commentKey:
            xml.push(writeIndentation(options2, depth, firstLine) + writeComment(nodes[i2], options2));
            break;
          default:
            xml.push(writeIndentation(options2, depth, firstLine) + writeElementCompact(nodes[i2], key, options2, depth, hasContentCompact(nodes[i2], options2)));
        }
        firstLine = firstLine && !xml.length;
      }
    }
  }
  return xml.join("");
}
var js2xml$2 = function(js, options2) {
  options2 = validateOptions(options2);
  var xml = [];
  currentElement = js;
  currentElementName = "_root_";
  if (options2.compact) {
    xml.push(writeElementsCompact(js, options2, 0, true));
  } else {
    if (js[options2.declarationKey]) {
      xml.push(writeDeclaration(js[options2.declarationKey], options2, 0));
    }
    if (js[options2.elementsKey] && js[options2.elementsKey].length) {
      xml.push(writeElements(js[options2.elementsKey], options2, 0, !xml.length));
    }
  }
  return xml.join("");
};
var js2xml$1 = js2xml$2;
var json2xml$1 = function(json, options2) {
  if (json instanceof Buffer$2) {
    json = json.toString();
  }
  var js = null;
  if (typeof json === "string") {
    try {
      js = JSON.parse(json);
    } catch (e3) {
      throw new Error("The JSON structure is invalid");
    }
  } else {
    js = json;
  }
  return js2xml$1(js, options2);
};
var xml2js = xml2js$2;
var xml2json = xml2json$1;
var js2xml = js2xml$2;
var json2xml = json2xml$1;
var lib = {
  xml2js,
  xml2json,
  js2xml,
  json2xml
};
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i2 = parts.length - 1; i2 >= 0; i2--) {
    var last2 = parts[i2];
    if (last2 === ".") {
      parts.splice(i2, 1);
    } else if (last2 === "..") {
      parts.splice(i2, 1);
      up++;
    } else if (up) {
      parts.splice(i2, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve$1() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    var path2 = i2 >= 0 ? arguments[i2] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter$2(resolvedPath.split("/"), function(p2) {
    return !!p2;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path2) {
  var isPathAbsolute = isAbsolute(path2), trailingSlash = substr(path2, -1) === "/";
  path2 = normalizeArray(filter$2(path2.split("/"), function(p2) {
    return !!p2;
  }), !isPathAbsolute).join("/");
  if (!path2 && !isPathAbsolute) {
    path2 = ".";
  }
  if (path2 && trailingSlash) {
    path2 += "/";
  }
  return (isPathAbsolute ? "/" : "") + path2;
}
function isAbsolute(path2) {
  return path2.charAt(0) === "/";
}
function join$1() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter$2(paths, function(p2, index2) {
    if (typeof p2 !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p2;
  }).join("/"));
}
function relative(from2, to) {
  from2 = resolve$1(from2).substr(1);
  to = resolve$1(to).substr(1);
  function trim2(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim2(from2.split("/"));
  var toParts = trim2(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i2 = 0; i2 < length; i2++) {
    if (fromParts[i2] !== toParts[i2]) {
      samePartsLength = i2;
      break;
    }
  }
  var outputParts = [];
  for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep = "/";
var delimiter$1 = ":";
function dirname(path2) {
  var result = splitPath(path2), root2 = result[0], dir = result[1];
  if (!root2 && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root2 + dir;
}
function basename(path2, ext2) {
  var f3 = splitPath(path2)[2];
  if (ext2 && f3.substr(-1 * ext2.length) === ext2) {
    f3 = f3.substr(0, f3.length - ext2.length);
  }
  return f3;
}
function extname(path2) {
  return splitPath(path2)[3];
}
const path$1 = {
  extname,
  basename,
  dirname,
  sep,
  delimiter: delimiter$1,
  relative,
  join: join$1,
  isAbsolute,
  normalize,
  resolve: resolve$1
};
function filter$2(xs, f3) {
  if (xs.filter)
    return xs.filter(f3);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (f3(xs[i2], i2, xs))
      res.push(xs[i2]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str2, start, len) {
  return str2.substr(start, len);
} : function(str2, start, len) {
  if (start < 0)
    start = str2.length + start;
  return str2.substr(start, len);
};
class TiledParser {
  constructor(xml, filePath = "") {
    this.xml = xml;
    this.filePath = filePath;
    this.layers = /* @__PURE__ */ new Map();
    this.transform = (obj) => {
      var _a, _b;
      if (!obj)
        return;
      const attr = obj.attributes || obj._attributes;
      if (!attr)
        return obj;
      let newObj = {
        ...obj,
        ...attr,
        ...TiledParser.propToNumber(attr, ["version", "width", "height", "tilewidth", "tileheight", "nextlayerid", "nextobjectid", "hexsidelength", "opacity", "x", "y", "offsetx", "offsety", "startx", "starty", "id", "firstgid", "imageheight", "imagewidth", "margin", "columns", "rows", "tilecount", "rotation", "gid", "tileid", "duration", "parallaxx", "parallaxy", "repeatx", "repeaty", "pixelsize"]),
        ...TiledParser.propToBool(attr, ["visible", "infinite", "locked", "bold", "italic", "kerning", "strikeout", "underline", "wrap"])
      };
      if (newObj.properties) {
        const properties = TiledParser.toArray(newObj.properties.property);
        const propObj = {};
        for (let prop of properties) {
          const attr2 = prop._attributes;
          if (!attr2)
            continue;
          let val;
          switch (attr2.type) {
            case "file":
              val = this.getImagePath(attr2.value);
              break;
            case "object":
            case "float":
            case "int":
              val = +attr2.value;
              break;
            case "bool":
              val = attr2.value == "true" ? true : false;
              break;
            case "class":
              val = {
                ...((_a = this.transform(prop)) == null ? void 0 : _a.properties) ?? {},
                _classname: attr2.propertytype
              };
              break;
            default:
              val = attr2.value;
          }
          propObj[attr2.name] = val;
        }
        newObj.properties = propObj;
      }
      if (newObj.polygon) {
        newObj.polygon = this.transform(newObj.polygon);
      }
      if (newObj.polyline) {
        newObj.polyline = this.transform(newObj.polyline);
      }
      if (newObj.points) {
        newObj = newObj.points.split(" ").map((point) => {
          const pos = point.split(",");
          return {
            x: +pos[0],
            y: +pos[1]
          };
        });
      }
      if (newObj.point) {
        newObj.point = true;
      }
      if (newObj.ellipse) {
        newObj.ellipse = true;
      }
      if (newObj.text) {
        newObj.text = {
          text: newObj.text._text,
          ...this.transform(newObj.text)
        };
        delete newObj.text._text;
      }
      if (newObj.image) {
        newObj.image = this.transform(newObj.image);
      }
      if (newObj.source) {
        newObj.source = this.getImagePath(newObj.source);
      }
      const objectgroup = newObj.object || ((_b = newObj.objectgroup) == null ? void 0 : _b.object);
      if (objectgroup) {
        newObj.objects = TiledParser.toArray(objectgroup).map((object) => {
          return this.transform(object);
        });
      }
      delete newObj._attributes;
      delete newObj.attributes;
      delete newObj.object;
      delete newObj.objectgroup;
      return newObj;
    };
  }
  static toArray(prop) {
    if (!prop)
      return [];
    if (!Array.isArray(prop))
      return [prop];
    return prop;
  }
  getImagePath(image) {
    const baseName = path$1.dirname(this.filePath);
    if (this.filePath.startsWith("http"))
      return new URL(image, this.filePath).href;
    return path$1.join(baseName, image);
  }
  static unpackTileBytes(buffer2, size2) {
    const expectedCount = size2 * 4;
    if (buffer2.length !== expectedCount) {
      throw new Error("Expected " + expectedCount + " bytes of tile data; received " + buffer2.length);
    }
    let tileIndex = 0;
    const array2 = [];
    for (let i2 = 0; i2 < expectedCount; i2 += 4) {
      array2[tileIndex] = buffer2.readUInt32LE(i2);
      tileIndex++;
    }
    return array2;
  }
  static decode(obj, size2) {
    const {
      encoding,
      data
    } = obj;
    if (encoding == "base64") {
      return TiledParser.unpackTileBytes(Buffer$2.from(data.trim(), "base64"), size2);
    } else if (encoding == "csv") {
      return data.trim().split(",").map((x2) => +x2);
    }
    return data;
  }
  parseMap() {
    const json = lib.xml2js(this.xml, {
      compact: true
    });
    const jsonNoCompact = lib.xml2js(this.xml);
    const tileset = json.map.tileset;
    json.map.group;
    const recursiveObjectGroup = (obj) => {
      const {
        objectgroup,
        group,
        layer,
        imagelayer
      } = obj;
      const setLayer = (type) => {
        if (!type)
          return;
        TiledParser.toArray(type).forEach((val) => {
          if (this.layers.has(+val._attributes.id)) {
            throw new Error(`Tiled Parser Error: Layer with id ${val._attributes.id} already exists`);
          }
          this.layers.set(+val._attributes.id, val);
        });
      };
      setLayer(objectgroup);
      setLayer(layer);
      setLayer(group);
      setLayer(imagelayer);
      if (group) {
        recursiveObjectGroup(group);
      }
    };
    recursiveObjectGroup(json.map);
    const recursiveLayer = (elements, array2 = []) => {
      var _a;
      if (!elements)
        return array2;
      for (let element of elements) {
        const {
          name: name2
        } = element;
        if (!["layer", "group", "imagelayer", "objectgroup"].includes(name2))
          continue;
        const data = (_a = element.elements) == null ? void 0 : _a.find((el) => el.name == "data");
        element.layer = this.layers.get(+element.attributes.id);
        const obj = {
          ...this.transform(data) ?? {},
          ...this.transform(element),
          ...this.transform(element.layer),
          layers: recursiveLayer(element.elements),
          data: data ? data.elements[0].text : void 0,
          type: name2 == "layer" ? "tilelayer" : name2
        };
        delete obj.elements;
        delete obj.layer;
        if (obj.data)
          obj.data = TiledParser.decode(obj, obj.width * obj.height);
        array2.push(obj);
      }
      return array2;
    };
    const layers = recursiveLayer(jsonNoCompact.elements[0].elements);
    const tilesets = TiledParser.toArray(tileset).map((tileset2) => {
      const obj = this.transform(tileset2);
      return obj;
    });
    const ret = {
      ...this.transform(json.map),
      layers,
      tilesets
    };
    delete ret.layer;
    delete ret.tileset;
    delete ret.group;
    delete ret.imagelayer;
    return ret;
  }
  parseTileset() {
    const json = lib.xml2js(this.xml, {
      compact: true
    });
    const {
      tileset
    } = json;
    const ret = {
      ...this.transform(tileset),
      image: this.transform(tileset.image),
      tiles: TiledParser.toArray(tileset.tile).map((tile) => {
        const ret2 = this.transform(tile);
        if (tile.animation) {
          ret2.animations = TiledParser.toArray(tile.animation.frame).map(this.transform);
        }
        delete ret2.animation;
        return ret2;
      })
    };
    delete ret.tile;
    return ret;
  }
}
TiledParser.propToNumber = (obj, props) => {
  for (let key of props) {
    if (obj[key] !== void 0) {
      obj[key] = +obj[key];
    }
  }
  return obj;
};
TiledParser.propToBool = (obj, props) => {
  for (let key of props) {
    if (obj[key] !== void 0) {
      obj[key] = obj[key] == "true" || obj[key] == "1";
    }
  }
  return obj;
};
class TiledProperties {
  constructor(data) {
    this.properties = {};
    this.properties = (data == null ? void 0 : data.properties) ?? {};
  }
  getProperty(name2, defaultValue2) {
    const val = this.properties[name2];
    if (val === void 0) {
      return defaultValue2;
    }
    return val;
  }
  hasProperty(name2) {
    return !!this.properties[name2];
  }
  setProperty(name2, value) {
    this.properties[name2] = value;
  }
  getType() {
    return this.class || this["type"];
  }
}
const FLIPPED_HORIZONTALLY_FLAG = 2147483648;
const FLIPPED_VERTICALLY_FLAG = 1073741824;
const FLIPPED_DIAGONALLY_FLAG = 536870912;
const ROTATED_HEXAGONAL_120_FLAG = 268435456;
class TileGid extends TiledProperties {
  constructor(obj) {
    super(obj);
    this.obj = obj;
    this._gid = obj == null ? void 0 : obj.gid;
  }
  static getRealGid(gid) {
    return gid & ~(FLIPPED_HORIZONTALLY_FLAG | FLIPPED_VERTICALLY_FLAG | FLIPPED_DIAGONALLY_FLAG | ROTATED_HEXAGONAL_120_FLAG);
  }
  get horizontalFlip() {
    return !!(this._gid & FLIPPED_HORIZONTALLY_FLAG);
  }
  get verticalFlip() {
    return !!(this._gid & FLIPPED_VERTICALLY_FLAG);
  }
  get diagonalFlip() {
    return !!(this._gid & FLIPPED_DIAGONALLY_FLAG);
  }
  get rotatedHex120() {
    return !!(this._gid & ROTATED_HEXAGONAL_120_FLAG);
  }
  get gid() {
    return TileGid.getRealGid(this._gid);
  }
  set gid(val) {
    this._gid = val;
  }
}
let Tile$1 = class Tile extends TileGid {
  constructor(tile) {
    super(tile);
    this.tile = tile;
    Reflect.deleteProperty(tile, "gid");
    Object.assign(this, tile);
  }
};
class TiledObjectClass extends TileGid {
  constructor(object) {
    super(object);
    this.layerName = "";
    Object.assign(this, object);
    if (object == null ? void 0 : object.gid) {
      this.y -= this.height;
    }
  }
}
class Layer extends TiledProperties {
  get size() {
    return this.data.length;
  }
  constructor(layer, tilesets, parent) {
    super(layer);
    this.tilesets = tilesets;
    this.parent = parent;
    this.cacheTiles = false;
    this.tiles = [];
    Object.assign(this, layer);
    this.mapObjects();
    this.mergePropertiesWithParent();
    this.cacheTiles = this.getProperty("cache-tiles", false);
    if (this.cacheTiles)
      this.propertiesTiles();
  }
  createTile(gid, tileIndex, layerIndex) {
    if (gid == 0) {
      return;
    }
    const realGid = TileGid.getRealGid(gid);
    const tileset = Layer.findTileSet(realGid, this.tilesets);
    if (!tileset) {
      return void 0;
    }
    const tile = tileset.getTile(realGid - tileset.firstgid);
    if (tile) {
      return new Tile$1({
        ...tile.tile,
        gid,
        index: tileIndex,
        layerIndex
      });
    }
    return new Tile$1({
      gid,
      index: tileIndex,
      layerIndex
    });
  }
  mergePropertiesWithParent() {
    const parent = this.getLayerParent();
    if (!this.properties)
      this.properties = {};
    if (!parent)
      return;
    for (let key in parent.properties) {
      const val = parent.properties[key];
      const valChild = this.properties[key];
      if (valChild === void 0) {
        this.properties[key] = val;
      } else {
        if (key == "z") {
          this.properties[key] += val;
        } else {
          continue;
        }
      }
    }
    this.opacity = Math.round((parent.opacity ?? 1) * (this.opacity ?? 1) * 100) / 100;
    this.offsetx = (parent.offsetx ?? 0) + (this.offsetx ?? 0);
    this.offsety = (parent.offsety ?? 0) + (this.offsety ?? 0);
    this.locked = parent.locked ?? false;
  }
  propertiesTiles() {
    if (!this.data)
      return;
    const data = this.data;
    for (let i2 = 0; i2 < data.length; i2++) {
      const id = data[i2];
      this.tiles.push(this.createTile(id, i2));
    }
  }
  mapObjects() {
    if (this.objects) {
      this.objects = this.objects.map((object) => {
        const obj = new TiledObjectClass(object);
        obj.layerName = this.name;
        return obj;
      });
    }
  }
  getTileByIndex(tileIndex) {
    if (this.cacheTiles) {
      return this.tiles[tileIndex];
    }
    return this.createTile(this.data[tileIndex], tileIndex);
  }
  static findTileSet(gid, tileSets) {
    let tileset;
    for (let i2 = tileSets.length - 1; i2 >= 0; i2--) {
      tileset = tileSets[i2];
      if (tileset.firstgid && tileset.firstgid <= gid) {
        break;
      }
    }
    return tileset;
  }
  getLayerParent() {
    return this.parent;
  }
  tilesForEach(cb) {
    for (let i2 = 0; i2 < this.data.length; i2++) {
      if (this.cacheTiles) {
        cb(this.tiles[i2], i2);
        continue;
      }
      cb(this.createTile(this.data[i2], i2), i2);
    }
  }
  setData(tileIndex, gid) {
    this.data[tileIndex] = gid;
  }
}
class Tileset extends TiledProperties {
  constructor(tileset) {
    super(tileset);
    this.tileset = tileset;
    this.cacheTileId = /* @__PURE__ */ new Map();
    Object.assign(this, tileset);
    this.margin = this.margin ?? 0;
    this.spacing = this.spacing ?? 0;
    for (let tile of tileset.tiles) {
      this.addTile(tile);
    }
    Reflect.deleteProperty(this, "tiles");
  }
  addTile(tileObj) {
    const tile = new Tile$1(tileObj);
    this.cacheTileId.set(tile.id, tile);
    return tile;
  }
  getTile(id) {
    return this.cacheTileId.get(+id);
  }
}
function bind$2(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$3 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const kindOf = ((cache) => (thing) => {
  const str2 = toString$3.call(thing);
  return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$7 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$6(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer$1 = kindOfTest("ArrayBuffer");
function isArrayBufferView$1(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer$1(val.buffer);
  }
  return result;
}
const isString$9 = typeOfTest("string");
const isFunction$6 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$2 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$1 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile$1 = kindOfTest("File");
const isBlob$1 = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$2(val) && isFunction$6(val.pipe);
const isFormData$1 = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$6(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$6(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams$1 = kindOfTest("URLSearchParams");
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$7(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global$1;
})();
const isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge$3() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge$3(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge$3({}, val);
    } else if (isArray$7(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend$3 = (a8, b3, thisArg, { allOwnKeys } = {}) => {
  forEach(b3, (val, key) => {
    if (thisArg && isFunction$6(val)) {
      a8[key] = bind$2(val, thisArg);
    } else {
      a8[key] = val;
    }
  }, { allOwnKeys });
  return a8;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$7(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator2 = generator.call(obj);
  let result;
  while ((result = iterator2.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str2) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str2)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str2) => {
  return str2.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$4 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction$6(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction$6(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$7(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value, defaultValue2) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue2;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  while (size2--) {
    str2 += alphabet[Math.random() * length | 0];
  }
  return str2;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$6(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray$7(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$2(thing) || isFunction$6(thing)) && isFunction$6(thing.then) && isFunction$6(thing.catch);
const utils = {
  isArray: isArray$7,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer,
  isFormData: isFormData$1,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$9,
  isNumber,
  isBoolean,
  isObject: isObject$2,
  isPlainObject: isPlainObject$1,
  isUndefined,
  isDate,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isRegExp,
  isFunction: isFunction$6,
  isStream,
  isURLSearchParams: isURLSearchParams$1,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$3,
  extend: extend$3,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$4,
  hasOwnProp: hasOwnProperty$4,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config2, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options2) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options2 = utils.toFlatObject(options2, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options2.metaTokens;
  const visitor = options2.visitor || defaultVisitor;
  const dots = options2.dots;
  const indexes = options2.indexes;
  const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer$2.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$3(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options2) {
  this._pairs = [];
  params && toFormData(params, this, options2);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$3);
  } : encode$3;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options2) {
  if (!params) {
    return url2;
  }
  const _encode = options2 && options2.encode || encode$2;
  const serializeFn = options2 && options2.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options2);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options2) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options2 ? options2.synchronous : false,
      runWhen: options2 ? options2.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options2) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options2));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name2 = path2[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path2.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path2, value, target[name2], index2);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder2) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context2, value, header, filter3, isHeaderNameFilter) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context2 = response || config2;
  const headers = AxiosHeaders$1.from(context2.headers);
  let data = context2.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write5(name2, value, expires, path2, domain2, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils.isString(domain2)) {
          cookie.push("domain=" + domain2);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write5() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }()
);
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e3
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done2() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request.timeout = config2.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done2();
      }, function _reject(err) {
        reject(err);
        done2();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config2.withCredentials)) {
      request.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e3) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a8, b3, caseless) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(a8, b3, caseless);
    } else if (!utils.isUndefined(a8)) {
      return getMergedValue(void 0, a8, caseless);
    }
  }
  function valueFromConfig2(a8, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a8, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils.isUndefined(a8)) {
      return getMergedValue(void 0, a8);
    }
  }
  function mergeDirectKeys(a8, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a8, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a8);
    }
  }
  const mergeMap2 = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a8, b3) => mergeDeepProperties(headersToObject(a8), headersToObject(b3), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap2[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const VERSION$1 = "1.4.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options2, schema, allowUnknown) {
  if (typeof options2 !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options2);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options2[opt];
      const result = value === void 0 || validator2(value, opt, options2);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context2 = new Axios$1(defaultConfig);
  const instance = bind$2(Axios$1.prototype.request, context2);
  utils.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
  utils.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
const fs = {};
class TiledParserFile {
  constructor(file, {
    basePath = "",
    staticDir = "",
    relativePath = ""
  } = {}) {
    this.file = file;
    this.basePath = basePath;
    this.staticDir = staticDir;
    this.relativePath = relativePath;
  }
  static isBrowser() {
    return typeof window !== "undefined" && !window.useFileSystem;
  }
  static typeOfFile(file) {
    file = file.trim();
    const isString2 = typeof file == "string";
    const info = {
      isXml: isString2 && file.startsWith("<?xml"),
      isObject: !!file["version"],
      isHttp: isString2 && file.startsWith("http")
    };
    return {
      ...info,
      isPath: !info.isXml && !info.isObject && !info.isHttp
    };
  }
  _parseFile(file, type, cb) {
    const isXml = (content) => TiledParserFile.typeOfFile(content).isXml;
    const loadContent = (content) => {
      if (!content) {
        return cb(null);
      }
      if (isXml(content)) {
        const parser = new TiledParser(content, this.staticDir ? "" : isXml(file) ? this.relativePath : file);
        if (type == "map") {
          const json = parser.parseMap();
          return cb(json);
        } else if (type == "tileset") {
          const json = parser.parseTileset();
          return cb(json);
        }
      }
      return cb(JSON.parse(content));
    };
    if (TiledParserFile.typeOfFile(file).isObject) {
      return cb(file);
    }
    const {
      isHttp
    } = TiledParserFile.typeOfFile(file);
    if (isXml(file)) {
      loadContent(file);
    } else if (isHttp || TiledParserFile.isBrowser() && true) {
      let url2 = isHttp ? file : path$1.join(this.basePath, this.staticDir, file);
      if (TiledParserFile.isBrowser() && window.urlCache) {
        url2 = window.urlCache[file];
      }
      axios$1.get(url2).then((res) => res.data).then(loadContent);
    } else {
      let filepath = file;
      if (file.startsWith("/")) {
        filepath = path$1.join(this.basePath ? this.basePath : "", file);
      }
      if (this.staticDir) {
        filepath = path$1.join(this.staticDir, file);
      }
      fs.readFile(path$1.normalize(filepath), "utf-8", (err, data) => {
        if (err)
          return cb(null, err);
        loadContent(data);
      });
      return;
    }
  }
  parseFile(cb, options2 = {}) {
    const {
      getOnlyBasename
    } = options2;
    const basename2 = (path2) => path2.substring(path2.lastIndexOf("/") + 1);
    if (getOnlyBasename) {
      if (TiledParserFile.typeOfFile(this.file).isPath) {
        this.file = basename2(this.file);
      }
    }
    this._parseFile(this.file, "map", (map2, err) => {
      let hasError = false;
      if (err)
        return cb(null, err);
      if (map2.tilesets) {
        const parseTileset = [];
        const finish = () => {
          loadAll++;
          if (loadAll == map2.tilesets.length && !hasError) {
            map2.tilesets = parseTileset;
            cb(map2);
          }
        };
        let loadAll = 0;
        for (let i2 = 0; i2 < map2.tilesets.length; i2++) {
          const tileset = map2.tilesets[i2];
          if (!tileset.source) {
            parseTileset[i2] = tileset;
            finish();
            continue;
          }
          if (getOnlyBasename) {
            if (TiledParserFile.typeOfFile(tileset.source).isPath) {
              tileset.source = basename2(tileset.source);
            }
          }
          this._parseFile(tileset.source, "tileset", (result, err2) => {
            if (err2) {
              hasError = true;
              return cb(null, err2);
            }
            parseTileset[i2] = {
              ...result,
              firstgid: tileset.firstgid
            };
            finish();
          });
        }
      }
    });
  }
  parseFilePromise(options2 = {}) {
    return new Promise((resolve2, reject) => {
      this.parseFile((ret, err) => {
        if (ret)
          resolve2(ret);
        else
          reject(err);
      }, options2);
    });
  }
}
let bufferTilesets = {};
class MapClass extends TiledProperties {
  constructor(map2) {
    super(map2 ?? {});
    this.tilesets = [];
    this.layers = [];
    this.tmpLayers = [];
    this.tilesIndex = {};
    this.allocateMemory = 0;
    this.lowMemory = false;
    if (map2)
      this.load(map2);
  }
  load(map2) {
    Object.assign(this, map2);
    if (this.hasProperty("low-memory")) {
      this.lowMemory = this.getProperty("low-memory", false);
    }
    this.tmpLayers = [];
    this.mapTilesets();
    this.mapLayers(this.layers);
    this.layers = [...this.tmpLayers];
    Reflect.deleteProperty(this, "tmpLayers");
    this.setTilesIndex();
    this.data = map2;
  }
  /**
   * @title Width of the map in pixels
   * @prop {number} [widthPx]
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get widthPx() {
    return this.width * this.tilewidth;
  }
  /**
  * @title Height of the map in pixels
  * @prop {number} [heightPx]
  * @readonly
  * @memberof Map
  * @memberof RpgSceneMap
  * */
  get heightPx() {
    return this.height * this.tileheight;
  }
  /**
   * @title The depth of the map in pixels (this is the height of a tile ;))
   * @prop {number} map.zTileHeight
   * @readonly
   * @memberof Map
   * @memberof RpgSceneMap
   * */
  get zTileHeight() {
    return this.tileheight;
  }
  /**
   * Find a layer by name. Returns `undefined` is the layer is not found
    * @title Get Layer by name
   * @method map.getLayerByName(name)
   * @param {string} name layer name
   * @returns {LayerInfo | undefined}
   * @example
   *  ```ts
   *  const tiles = map.getLayerByName(0, 0)
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getLayerByName(name2) {
    return this.layers.find((layer) => layer.name == name2);
  }
  /**
  * Get the tile index on the tileset
  *
  * @title Get index of tile
  * @method map.getTileIndex(x,y)
  * @param {number} x Position X
  * @param {number} x Position Y
  * @returns {number}
  * @memberof Map
  * @memberof RpgSceneMap
  */
  getTileIndex(x2, y2, [z2] = [0]) {
    return this.width * Math.floor((y2 - z2) / this.tileheight) + Math.floor(x2 / this.tilewidth);
  }
  getTilePosition(index2) {
    return {
      y: Math.floor(index2 / this.width) * this.tileheight,
      x: index2 % this.width * this.tilewidth
    };
  }
  /**
   * Find the point of origin (top left) of a tile. Of course, its position depends on the size of the tile
    * @title Get origin position of tile
   * @method map.getTileOriginPosition(x,y)
   * @param {number} x Position X
   * @param {number} x Position Y
   * @returns { {x: number, y: number }}
   * @example
   *  ```ts
   *  // If the size of a tile is 32x32px
   *  const position = map.getTileOriginPosition(35, 12)
   *  console.log(position) // { x: 32, y: 0 }
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getTileOriginPosition(x2, y2) {
    return {
      x: Math.floor(x2 / this.tilewidth) * this.tilewidth,
      y: Math.floor(y2 / this.tileheight) * this.tileheight
    };
  }
  /**
  * Recover tiles according to a position
   * @title Get tile by position
  * @method map.getTileByPosition(x,y)
  * @param {number} x Position X
  * @param {number} x Position Y
  * @returns {TileInfo}
  * @example
  *  ```ts
  *  const tiles = map.getTileByPosition(0, 0)
  *  ```
  * @memberof Map
  * @memberof RpgSceneMap
  */
  getTileByPosition(x2, y2, z2 = [0, 0], options2 = {}) {
    const tileIndex = this.getTileIndex(x2, y2, [z2[0]]);
    return this.getTileByIndex(tileIndex, z2, options2);
  }
  /**
   * Retrieves tiles according to its index
    * @title Get tile by index
   * @method map.getTileByIndex(tileIndex)
   * @param {number} tileIndex tile index
   * @returns {TileInfo}
   * @example
   *  ```ts
   *  const index = map.getTileIndex(0, 0)
   *  const tiles = map.getTileByIndex(index)
   *  ```
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getTileByIndex(tileIndex, zPlayer = [0, 0], options2 = {
    populateTiles: true
  }) {
    const zA = Math.floor(zPlayer[0] / this.zTileHeight);
    Math.floor(zPlayer[1] / this.zTileHeight);
    const level = this.tilesIndex[zA];
    const obj = {
      tiles: [],
      hasCollision: true,
      isOverlay: false,
      objectGroups: [],
      tileIndex
    };
    if (!level) {
      return obj;
    }
    const [layer] = this.layers;
    const getTileByPointer = (pointer = 0) => {
      const pos = tileIndex * this.realAllocateMemory + pointer;
      const gid = level[pos];
      if (gid === 0) {
        return obj;
      }
      const tile2 = layer.createTile(gid, tileIndex, level[pos + 1]);
      if (tile2)
        obj.tiles.push(tile2);
    };
    if (options2.populateTiles) {
      for (let i2 = 0; i2 < this.realAllocateMemory; i2 += 2) {
        getTileByPointer(i2);
      }
    } else {
      getTileByPointer();
    }
    const [tile] = obj.tiles;
    if (tile) {
      obj.hasCollision = tile.getProperty("collision", false);
      obj.objectGroups = tile.objects ?? [];
    }
    return obj;
  }
  getAllObjects() {
    return this.layers.reduce((prev, current) => {
      if (!current.objects)
        return prev;
      return prev.concat(...current.objects);
    }, []);
  }
  getData() {
    return {
      ...this.data,
      layers: this.layers
    };
  }
  setTile(x2, y2, layerFilter, tileInfo) {
    if (this.lowMemory) {
      throw "Impossible to change a tile with the lowMemory option";
    }
    const tileIndex = this.getTileIndex(x2, y2);
    let fnFilter;
    let tilesEdited = {};
    if (typeof layerFilter == "string") {
      fnFilter = (layer) => layer.name == layerFilter;
    } else {
      fnFilter = layerFilter;
    }
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      const layer = this.layers[i2];
      if (!fnFilter(layer))
        continue;
      let tile;
      const oldTile = this.getTileByIndex(tileIndex);
      if (tileInfo.gid) {
        tile = layer.createTile(tileInfo.gid, tileIndex);
      }
      if (!tile)
        continue;
      for (let key in tileInfo) {
        if (key == "gid")
          continue;
        tile[key] = tileInfo[key];
      }
      tilesEdited[layer.name] = {
        gid: tile.gid,
        properties: tile.properties
      };
      this.setTileIndex(layer, oldTile.tiles[0], tile, tileIndex, i2);
      layer.setData(tileIndex, tile.gid);
    }
    return {
      x: x2,
      y: y2,
      tiles: tilesEdited
    };
  }
  removeCacheTileset(name2) {
    delete bufferTilesets[name2];
  }
  clearCacheTilesets() {
    bufferTilesets = {};
  }
  mapTilesets() {
    this.tilesets = this.tilesets.map((tileset) => {
      if (bufferTilesets[tileset.name]) {
        const instance = bufferTilesets[tileset.name];
        instance.firstgid = tileset.firstgid;
        return instance;
      }
      const _tileset = new Tileset(tileset);
      bufferTilesets[_tileset.name] = _tileset;
      return _tileset;
    });
  }
  mapLayers(layers = [], parent) {
    for (let layer of layers) {
      const layerInstance = new Layer(layer, this.tilesets, parent);
      this.tmpLayers.push(layerInstance);
      if (layer.layers) {
        this.mapLayers(layer.layers, layerInstance);
      }
    }
    if (this.lowMemory)
      this.allocateMemory = 1;
    if (!this.allocateMemory)
      this.allocateMemory = this.layers.length;
  }
  setTileIndex(layer, oldTile, newTile, tileIndex, layerIndex) {
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    const zLayer = layer.getProperty("z", 0);
    const zTile = oldTile.getProperty("z", 0);
    let z2 = zLayer + zTile;
    while (pointer >= startPos) {
      const zlayer = this.tilesIndex[z2];
      if (zlayer[pointer] === oldTile.gid && zlayer[pointer + 1] === layerIndex) {
        this.tilesIndex[z2][pointer] = newTile.gid;
      }
      pointer -= 2;
    }
  }
  /**
   * We multiply by 2 because 2 entries are stored for a tile: its GID and the Layer Index
   *
   * Example If I have 3 layers, The array will have the following form
   *
   * [
   *  GID of Layer 3,
   *  Layer Index of Layer 3,
   *  GID of Layer 2,
   *  Layer Index of Layer 2,
   *  GID of Layer 1,
   *  Layer Index of Layer 1,
   * ... others tiles
   * ]
   *
   * The size in memory of the map is therefore:
   *
   * `(map width * map height * number of layers * 4) bytes`
   *
   * > We multiply by 4, because an element takes 2 bytes and has 2 elements for a tile is 4 bytes in all
   *
   * Example (a 100x100 map with 5 layers)
   *
   * `100 * 100 * 5 * 4 = 200000 bytes = ~195 Kb`
   *
   * If we define on lowMemory then the calculation is the following
   *
   * `(map width * map height * 4) bytes`
   *
   * Example
   *
   * `100 * 100 * 4 = 40000 bytes = ~39 Kb`
   */
  get realAllocateMemory() {
    return this.allocateMemory * 2;
  }
  /**
   * We keep each tile in memory classified by z value. The values are ordered from the end to the beginning so that the first element of the array (when retrieved with getTileByIndex() is the tile on the highest layer. This way, the tile search is very fast for collisions
   *
   */
  addTileIndex(layer, tile, tileIndex, layerIndex) {
    if (!tile || tile && tile.gid == 0) {
      return;
    }
    const zLayer = layer.getProperty("z", 0);
    const zTile = tile.getProperty("z", 0);
    let z2 = zLayer + zTile;
    if (!this.tilesIndex[z2]) {
      const buffer2 = new ArrayBuffer(layer.size * this.realAllocateMemory * 2);
      this.tilesIndex[z2] = new Uint16Array(buffer2);
    }
    const startPos = tileIndex * this.realAllocateMemory;
    let pointer = startPos + this.realAllocateMemory - 2;
    while (this.tilesIndex[z2][pointer] !== 0 && pointer > startPos) {
      pointer -= 2;
    }
    this.tilesIndex[z2][pointer] = tile.gid;
    this.tilesIndex[z2][pointer + 1] = layerIndex;
    this.tilesIndex[z2][startPos] = tile.gid;
    this.tilesIndex[z2][startPos + 1] = layerIndex;
  }
  setTilesIndex() {
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      const layer = this.layers[i2];
      if (layer.type != TiledLayerType.Tile) {
        continue;
      }
      layer.tilesForEach((tile, index2) => {
        this.addTileIndex(layer, tile, index2, i2);
      });
    }
  }
}
class Vector2d {
  constructor(x2, y2, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  add(vector) {
    this.x += vector.x;
    this.y += vector.y;
    return this;
  }
  subtract(vector) {
    this.x -= vector.x;
    this.y -= vector.y;
    return this;
  }
  multiply(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    return this;
  }
  distanceWith(vector) {
    const dx = this.x - vector.x;
    const dy = this.y - vector.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  copy() {
    return new Vector2d(this.x, this.y, this.z);
  }
  normalize() {
    return this.divide(this.magnitude());
  }
  isEqual(vector) {
    return this.x === vector.x && this.y === vector.y && this.z === vector.z;
  }
  hasDifferentValues(vector) {
    return this.x !== vector.x || this.y !== vector.y || this.z !== vector.z;
  }
}
class Vector2dZero extends Vector2d {
  constructor() {
    super(0, 0);
  }
}
var ShapePositioning;
(function(ShapePositioning2) {
  ShapePositioning2["Default"] = "default";
  ShapePositioning2["Center"] = "center";
})(ShapePositioning || (ShapePositioning = {}));
class RpgShape extends TiledObjectClass {
  constructor(obj) {
    super();
    this.type = HitType.Box;
    this.class = "";
    this.name = "";
    this.playersIn = {};
    this.clientContainer = null;
    this.positioning = ShapePositioning.Default;
    this.components = [];
    Reflect.deleteProperty(obj, "id");
    this.set(obj);
  }
  setPos(type, val) {
    if (!this.hitbox.pos)
      return;
    if (this.isShapePosition()) {
      this.hitbox[type] = val;
    } else {
      this.hitbox.pos[type] = val;
    }
  }
  get hasCollision() {
    return this.getProperty("collision", false);
  }
  // alias
  get id() {
    return this.name;
  }
  get hitbox() {
    if (this.fixEvent) {
      this._hitbox.pos.x = this.fixEvent.position.x;
      this._hitbox.pos.y = this.fixEvent.position.y;
      switch (this.positioning) {
        case ShapePositioning.Center:
          this._hitbox.pos.x -= this._hitbox.w / 2 - this.fixEvent.hitbox.w / 2;
          this._hitbox.pos.y -= this._hitbox.h / 2 - this.fixEvent.hitbox.h / 2;
          break;
      }
    }
    return this._hitbox;
  }
  set hitbox(val) {
    this._hitbox = val;
  }
  /**
  * Get/Set width
  * @title width
  * @prop { number } width
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get width() {
    return this.hitbox.w || 0;
  }
  set width(val) {
    this.setPos("w", val);
  }
  /**
  * Get/Set height
  * @title height
  * @prop { number } height
  * @since 3.0.0-beta.5
  * @memberof Shape
  */
  get height() {
    return this.hitbox.h || 0;
  }
  set height(val) {
    this.setPos("h", val);
  }
  /**
  * Get/Set x
  * @title x
  * @prop { number } x
  * @memberof Shape
  */
  get x() {
    return this.hitbox.x || this.hitbox.pos.x;
  }
  set x(val) {
    this.setPos("x", val);
  }
  get z() {
    return this.getProperty("z");
  }
  /**
  * Get/Set y
  * @title y
  * @prop { number } y
  * @memberof Shape
  */
  get y() {
    return this.hitbox.y || this.hitbox.pos.y;
  }
  set y(val) {
    this.setPos("y", val);
  }
  get position() {
    return new Vector2d(this.x, this.y, this.z);
  }
  /**
  * Get/Set properties
   * @title Properties
  * @prop { object } Properties
  * @memberof Shape
  */
  isEvent() {
    return this.type == PlayerType.Event;
  }
  set(obj) {
    const hit = Hit.getHitbox(obj);
    Object.assign(this, hit);
    const objClone = {
      ...obj
    };
    ["width", "height", "x", "y"].forEach((prop) => Reflect.deleteProperty(objClone, prop));
    Object.assign(this, objClone);
    const findPoint = (prop, isMin) => {
      return this.hitbox.points.sort((a8, b3) => isMin ? a8[prop] - b3[prop] : b3[prop] - a8[prop])[0][prop];
    };
    if (this.type == HitType.Polygon) {
      this.hitbox.minX = findPoint("x", true);
      this.hitbox.maxX = findPoint("x", false);
      this.hitbox.minY = findPoint("y", true);
      this.hitbox.maxY = findPoint("y", false);
    }
    this.positioning = obj.positioning;
    this.fixEvent = obj.fixEvent;
    this.setComponent();
  }
  setComponent() {
    const color = this.getProperty("color");
    const image = this.getProperty("image");
    if (color) {
      this.components = [{
        id: "shape",
        value: {
          fill: color
        }
      }];
      return;
    }
    if (image) {
      this.components = [{
        id: "image",
        value: image
      }];
      return;
    }
    if (this.text) {
      this.components = [{
        id: "text",
        value: this.text.text
      }];
      return;
    }
    if (this.gid) {
      this.components = [{
        id: "tile",
        value: this.gid
      }];
      return;
    }
  }
  getType() {
    return this.class || this.type;
  }
  async in(player2) {
    var _a;
    if (!this.playerIsIn(player2)) {
      this.playersIn[player2.id] = true;
      player2.inShapes[this.name] = this;
      await player2.execMethod("onInShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectInShape", [player2, this], this.fixEvent));
      await player2.execMethod("onIn", [player2], this);
      return true;
    }
    return false;
  }
  async out(player2) {
    var _a;
    if (this.playerIsIn(player2)) {
      delete this.playersIn[player2.id];
      delete player2.inShapes[this.name];
      await player2.execMethod("onOutShape", [this]);
      await ((_a = this.fixEvent) == null ? void 0 : _a.execMethod("onDetectOutShape", [player2, this], this.fixEvent));
      await player2.execMethod("onOut", [player2], this);
      return true;
    }
    return false;
  }
  /**
   * Whether the player is in this shape
   *
   * @title Player is in this shape ?
   * @method shape.playerIsIn(player)
   * @returns {boolean}
   * @memberof Shape
   */
  playerIsIn(player2) {
    return !!this.playersIn[player2.id];
  }
  isShapePosition() {
    return this.type !== HitType.Box && this.type !== HitType.Circle && this.type !== HitType.Polygon;
  }
  /**
    * Recover the player with the shape. You must have used the `attachShape()` method on the player
    *
    * @title Get Player Owner
    * @method shape.getPlayerOwner()
    * @returns {RpgPlayer | undefined}
    * @memberof Shape
    */
  getPlayerOwner() {
    return this.fixEvent;
  }
  /**
   * We get the rectangle of a shape (box, circle and polygon). We use in the grid system to recover a shape.
   * Generally we add a margin (size of a tile) to detect if the player enters or leaves a shape
   * @param margin
   * @returns { minX: number, minY: number, maxX: number, maxY: number }
   */
  getSizeBox(margin = 0) {
    if (this.type == HitType.Circle) {
      const radius = this.hitbox.r;
      return {
        minX: this.x - radius - margin,
        maxX: this.x + radius + margin,
        minY: this.y - radius - margin,
        maxY: this.y + radius + margin
      };
    }
    if (this.type == HitType.Polygon) {
      return {
        minX: this.x + this.hitbox.minX - margin,
        maxX: this.x + this.hitbox.maxX + margin,
        minY: this.y + this.hitbox.minY - margin,
        maxY: this.y + this.hitbox.maxY + margin
      };
    }
    return {
      minX: this.x - margin,
      maxX: this.x + this.width + margin,
      minY: this.y - margin,
      maxY: this.y + this.height + margin
    };
  }
}
class VirtualGrid {
  constructor(nbCellWidth, cellWidth, cellHeight) {
    this.nbCellWidth = nbCellWidth;
    this.cellWidth = cellWidth;
    this.cellHeight = cellHeight;
    this.cells = /* @__PURE__ */ new Map();
    this.inverseCells = /* @__PURE__ */ new Map();
  }
  zoom(nbCell) {
    this.nbCellWidth = Math.ceil(this.nbCellWidth / nbCell);
    this.cellWidth *= nbCell;
    this.cellHeight *= nbCell;
    return this;
  }
  getCellIndex(x2, y2) {
    return this.nbCellWidth * Math.floor(y2 / this.cellHeight) + Math.floor(x2 / this.cellWidth);
  }
  getCells(box, cb) {
    const {
      minX,
      minY,
      maxX,
      maxY
    } = box;
    const topLeft = this.getCellIndex(minX, minY);
    const topRight = this.getCellIndex(maxX, minY);
    const bottomLeft = this.getCellIndex(minX, maxY);
    const nbLines = (bottomLeft - topLeft) / this.nbCellWidth + 1;
    for (let j2 = 0; j2 < nbLines; j2++) {
      for (let i2 = topLeft; i2 <= topRight; i2++) {
        const index2 = i2 + j2 * this.nbCellWidth;
        cb(index2);
      }
    }
  }
  getObjectsByBox(box) {
    let objects = [];
    this.getCells(box, (index2) => {
      objects = [...objects, ...this.cells.get(index2) || []];
    });
    return new Set(objects);
  }
  getObjectsById(id) {
    let objects = [];
    const cells = this.inverseCells.get(id);
    cells == null ? void 0 : cells.forEach((index2) => {
      objects = [...objects, ...this.cells.get(index2) || []];
    });
    return new Set(objects);
  }
  clearObjectInCells(id) {
    var _a;
    if (this.inverseCells.has(id)) {
      (_a = this.inverseCells.get(id)) == null ? void 0 : _a.forEach((cellIndex) => {
        var _a2;
        (_a2 = this.cells.get(cellIndex)) == null ? void 0 : _a2.delete(id);
      });
      this.inverseCells.delete(id);
    }
  }
  insertInCells(id, box) {
    this.clearObjectInCells(id);
    const cells = /* @__PURE__ */ new Set();
    this.getCells(box, (index2) => {
      var _a;
      cells.add(index2);
      const memoryCells = this.cells.get(index2);
      if (!memoryCells) {
        this.cells.set(index2, /* @__PURE__ */ new Set());
      }
      (_a = this.cells.get(index2)) == null ? void 0 : _a.add(id);
    });
    this.inverseCells.set(id, cells);
  }
}
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p2 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p2))
        d3[p2] = b4[p2];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f3) {
    return function(v2) {
      return Promise.resolve(v2).then(f3, reject);
    };
  }
  function verb(n2, f3) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a8, b3) {
          q2.push([n2, v2, a8, b3]) > 1 || resume2(n2, v2);
        });
      };
      if (f3)
        i2[n2] = f3(i2[n2]);
    }
  }
  function resume2(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e3) {
      settle2(q2[0][3], e3);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle2(f3, v2) {
    if (f3(v2), q2.shift(), q2.length)
      resume2(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle2(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle2(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error2, e3.suppressed = suppressed, e3;
};
function isFunction$5(value) {
  return typeof value === "function";
}
function createErrorClass$1(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError$1 = createErrorClass$1(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});
function arrRemove$1(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription$1 = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction$5(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e3) {
          errors2 = e3 instanceof UnsubscriptionError$1 ? e3.errors : [e3];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer$1(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError$1) {
                errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError$1(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer$1(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove$1(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove$1(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION$1 = Subscription$1.EMPTY;
function isSubscription$1(value) {
  return value instanceof Subscription$1 || value && "closed" in value && isFunction$5(value.remove) && isFunction$5(value.add) && isFunction$5(value.unsubscribe);
}
function execFinalizer$1(finalizer) {
  if (isFunction$5(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$1 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider$1 = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider$1.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider$1.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError$1(err) {
  timeoutProvider$1.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$1() {
}
function errorContext$1(cb) {
  {
    cb();
  }
}
var Subscriber$1 = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription$1(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER$1;
    }
    return _this;
  }
  Subscriber2.create = function(next, error2, complete) {
    return new SafeSubscriber$1(next, error2, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription$1);
var _bind$1 = Function.prototype.bind;
function bind$1(fn, thisArg) {
  return _bind$1.call(fn, thisArg);
}
var ConsumerObserver$1 = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error2) {
        handleUnhandledError$1(error2);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error2) {
        handleUnhandledError$1(error2);
      }
    } else {
      handleUnhandledError$1(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error2) {
        handleUnhandledError$1(error2);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber$1 = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction$5(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error2 !== null && error2 !== void 0 ? error2 : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config$1.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind$1(observerOrNext.next, context_1),
          error: observerOrNext.error && bind$1(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind$1(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver$1(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber$1);
function handleUnhandledError$1(error2) {
  {
    reportUnhandledError$1(error2);
  }
}
function defaultErrorHandler$1(err) {
  throw err;
}
var EMPTY_OBSERVER$1 = {
  closed: true,
  next: noop$1,
  error: defaultErrorHandler$1,
  complete: noop$1
};
var observable$1 = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity$1(x2) {
  return x2;
}
function pipeFromArray$1(fns) {
  if (fns.length === 0) {
    return identity$1;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable$1 = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var _this = this;
    var subscriber = isSubscriber$1(observerOrNext) ? observerOrNext : new SafeSubscriber$1(observerOrNext, error2, complete);
    errorContext$1(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor$1(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber$1({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable$1] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray$1(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor$1(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor$1(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver$1(value) {
  return value && isFunction$5(value.next) && isFunction$5(value.error) && isFunction$5(value.complete);
}
function isSubscriber$1(value) {
  return value && value instanceof Subscriber$1 || isObserver$1(value) && isSubscription$1(value);
}
function hasLift(source) {
  return isFunction$5(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError2, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError2, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError2, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError2 ? function(err) {
      try {
        onError2(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber$1);
var ObjectUnsubscribedError$1 = createErrorClass$1(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject$1 = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject$1(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError$1();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext$1(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext$1(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext$1(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION$1;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription$1(function() {
      _this.currentObservers = null;
      arrRemove$1(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable$1();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject$1(destination, source);
  };
  return Subject2;
}(Observable$1);
var AnonymousSubject$1 = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION$1;
  };
  return AnonymousSubject2;
}(Subject$1);
var BehaviorSubject$1 = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject$1);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription$1);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error2 = this._execute(state, delay);
    if (error2) {
      return error2;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e3) {
      errored = true;
      errorValue = e3 ? e3 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove$1(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler$1 = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler$1.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error2;
    this._active = true;
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsyncScheduler2;
}(Scheduler$1);
var asyncScheduler = new AsyncScheduler(AsyncAction);
function isScheduler(value) {
  return value && isFunction$5(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction$5(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise$2(value) {
  return isFunction$5(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction$5(input[observable$1]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction$5(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction$5(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done2;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done2 = _a.done;
          if (!done2)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction$5(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable$1) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise$2(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable$1(function(subscriber) {
    var obs = obj[observable$1]();
    if (isFunction$5(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array2) {
  return new Observable$1(function(subscriber) {
    for (var i2 = 0; i2 < array2.length && !subscriber.closed; i2++) {
      subscriber.next(array2[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable$1(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError$1);
  });
}
function fromIterable(iterable) {
  return new Observable$1(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable$1(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable$1(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable$1(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done2;
        try {
          _a = iterator$1.next(), value = _a.value, done2 = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction$5(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable$1(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise$2(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
var EmptyError = createErrorClass$1(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve2(_value);
        } else if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}
function map$6(project, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index2++));
    }));
  });
}
var isArray$6 = Array.isArray;
function callOrApply(fn, args) {
  return isArray$6(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map$6(function(args) {
    return callOrApply(fn, args);
  });
}
var isArray$5 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto$1 = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray$5(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto$1;
}
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable$1(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity$1));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity$1;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction$5(resultSelector)) {
    return mergeMap(function(a8, i2) {
      return map$6(function(b3, ii) {
        return resultSelector(a8, b3, i2, ii);
      })(innerFrom(project(a8, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
  var result = new Observable$1(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject(keys2, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function filter$1(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit3 = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit3();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit3();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
function distinctUntilChanged(comparator2, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity$1;
  }
  comparator2 = comparator2 !== null && comparator2 !== void 0 ? comparator2 : defaultCompare$1;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator2(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare$1(a8, b3) {
  return a8 === b3;
}
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index2 = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index2++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop$1));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
function tap(observerOrNext, error2, complete) {
  var tapObserver = isFunction$5(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity$1;
}
const buffer = /* @__PURE__ */ new Map();
const bufferClient = /* @__PURE__ */ new Map();
class RpgCommonMap extends MapClass {
  constructor() {
    super(...arguments);
    this.shapes = {};
  }
  get tileWidth() {
    return this.tilewidth;
  }
  get tileHeight() {
    return this.tileheight;
  }
  /**
   * Retrieves the X position of the map in the world (0 if no world assigned)
   *
   * @title World X Position
   * @prop {number} [worldX]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldX() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.x) || 0;
  }
  /**
   * Retrieves the Y position of the map in the world (0 if no world assigned)
   *
   * @title World Y Position
   * @prop {number} [worldY]
   * @readonly
   * @since 3.0.0-beta.8
   * @memberof Map
   * */
  get worldY() {
    var _a, _b;
    return ((_b = (_a = this.getInWorldMaps()) == null ? void 0 : _a.getMapInfo(this.id)) == null ? void 0 : _b.y) || 0;
  }
  /**
   * Memorize the maps so you don't have to make a new request or open a file each time you load a map
   */
  static get buffer() {
    return buffer;
  }
  /**
   * In RPG mode, to avoid confusion with buffer, we have a new variable to memorize the maps
   */
  static get bufferClient() {
    return bufferClient;
  }
  load(data) {
    super.load(data);
    this.gridTiles = new VirtualGrid(this.width, this.tileWidth, this.tileHeight);
    this.grid = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(10);
    this.gridShapes = new VirtualGrid(this.width, this.tileWidth, this.tileHeight).zoom(20);
  }
  /**
   * Create a shape dynamically on the map
   *
   * Object:
   *  - (number) x: Position X
   *  - (number) y: Position Y
   *  - (number) width: Width
   *  - (number) height: Height
   *  - (object) properties (optionnal):
   *      - (number) z: Position Z
   *      - (hexadecimal) color: Color (shared with client)
   *      - (boolean) collision
   *      - You can your own properties
   *
   * @title Create Shape
   * @since 3.0.0-beta.3
   * @method map.createShape(obj)
   * @param {object} obj
   * @returns {RpgShape}
   * @memberof Map
   */
  createShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    this.shapes[id] = shape;
    if (!shape.isShapePosition()) {
      this.gridShapes.insertInCells(id, shape.getSizeBox(this.tileWidth));
    }
    return this.shapes[id];
  }
  /**
   * Delete a shape
   *
   * @title Delete Shape
   * @method map.removeShape(name)
   * @param {string} name Name of shape
   * @returns {void}
   * @memberof Map
   */
  removeShape(name2) {
    delete this.shapes[name2];
  }
  clearShapes() {
    this.shapes = {};
  }
  /**
   * Return all shapes on the map
   *
   * @title Get Shapes
   * @method map.getShapes()
   * @returns {RpgShape[]}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShapes() {
    return Object.values(this.shapes);
  }
  /**
   * Returns a shape by its name. Returns undefined is nothing is found
   *
   * @title Get Shape by name
   * @method map.getShape(name)
   * @param {string} name Name of shape
   * @returns {RpgShape[] | undefined}
   * @memberof Map
   * @memberof RpgSceneMap
   */
  getShape(name2) {
    return this.getShapes().find((shape) => shape.name == name2);
  }
  getPositionByShape(filter3) {
    const startsFind = this.getShapes().filter(filter3);
    if (startsFind.length) {
      const start = startsFind[random$2(0, startsFind.length - 1)];
      return {
        x: start.hitbox.x,
        y: start.hitbox.y,
        z: start.properties.z * this.zTileHeight || 0
      };
    }
    return null;
  }
  /**
   * Get tile and verify collision with hitbox
   * @param hitbox
   * @param x
   * @param y
   * @param z
   * @returns TileInfo
   */
  getTile(hitbox, x2, y2, z2 = [0, 0]) {
    const tile = {
      ...this.getTileByPosition(x2, y2, z2)
    };
    const tilePos = this.getTileOriginPosition(x2, y2);
    if (tile.objectGroups) {
      for (let object of tile.objectGroups) {
        const hit = Hit.getHitbox(object, {
          x: tilePos.x,
          y: tilePos.y
        });
        if (hit.type) {
          const collided = Hit.testPolyCollision(hit.type, hit.hitbox, hitbox);
          if (collided) {
            tile.hasCollision = true;
          }
        }
      }
    }
    return tile;
  }
  /**
   * Assign the map to a world
    * @title Assign the map to a world
   * @method map.setInWorldMaps(name)
   * @param {RpgWorldMaps} worldMap world maps
   * @since 3.0.0-beta.8
   * @memberof Map
   */
  setInWorldMaps(worldMap) {
    this.worldMapParent = worldMap;
  }
  /**
   * Remove this map from the world
   * @title Remove this map from the world
   * @method map.removeFromWorldMaps()
   * @returns {boolean | undefined}
   * @since 3.0.0-beta.8
   * @memberof Map
   */
  removeFromWorldMaps() {
    var _a;
    return (_a = this.worldMapParent) == null ? void 0 : _a.removeMap(this.id);
  }
  /**
  * Recover the world attached to this map (`undefined` if no world attached)
   * @title Get attached World
  * @method map.getInWorldMaps()
  * @return {RpgCommonWorldMaps | undefined}
  * @since 3.0.0-beta.8
  * @memberof Map
  */
  getInWorldMaps() {
    return this.worldMapParent;
  }
  boundingMap(nextPosition, hitbox) {
    let bounding = false;
    if (nextPosition.x < 0) {
      nextPosition.x = 0;
      bounding = true;
    } else if (nextPosition.y < 0) {
      nextPosition.y = 0;
      bounding = true;
    } else if (nextPosition.x > this.widthPx - hitbox.w) {
      nextPosition.x = this.widthPx - hitbox.w;
      bounding = true;
    } else if (nextPosition.y > this.heightPx - hitbox.h) {
      nextPosition.y = this.heightPx - hitbox.h;
      bounding = true;
    }
    return {
      bounding,
      nextPosition
    };
  }
  _createMovingHitbox(gameEngine, tick$, mapId, hitboxes, options2 = {}) {
    const object = new AbstractObject(gameEngine, Utils$1.generateUID());
    object.disableVirtualGrid = true;
    object.map = mapId;
    object.speed = options2.speed ?? 1;
    let i2 = 0;
    let frame = 0;
    const destroyHitbox$ = new Subject$1();
    return tick$.pipe(takeUntil(destroyHitbox$), filter$1(() => {
      frame++;
      return frame % object.speed == 0;
    }), map$6(() => {
      const hitbox = hitboxes[i2];
      if (!hitbox) {
        destroyHitbox$.next(object);
        destroyHitbox$.complete();
        return object;
      }
      object.position.x = hitbox.x;
      object.position.y = hitbox.y;
      object.setHitbox(hitbox.width, hitbox.height);
      i2++;
      return object;
    }), mergeMap((object2) => from(object2.isCollided(object2.position, {
      allSearch: true
    }))), map$6(() => object));
  }
}
let EventEmitter$1 = class EventEmitter {
  constructor() {
    this.listeners = {};
    this.listenersOnce = {};
  }
  has(name2) {
    return !!this.listeners[name2] || !!this.listenersOnce[name2];
  }
  once(name2, cb) {
    this.listenersOnce[name2] = cb;
    return this;
  }
  on(name2, cb) {
    if (!this.listeners[name2])
      this.listeners[name2] = [];
    this.listeners[name2].push(cb);
    return this;
  }
  emit(name2, data, rest = false) {
    const ret = [];
    if (this.listeners[name2]) {
      for (let listener of this.listeners[name2]) {
        if (rest)
          ret.push(listener(...data));
        else
          ret.push(listener(data));
      }
    }
    if (this.listenersOnce[name2]) {
      if (rest)
        ret.push(this.listenersOnce[name2](...data));
      else
        ret.push(this.listenersOnce[name2](data));
    }
    return Promise.all(ret.map((val) => {
      if (!isPromise$3(val)) {
        return Promise.resolve(val);
      }
      return val;
    }));
  }
  off(name2, listener) {
    if (!listener) {
      delete this.listeners[name2];
      delete this.listenersOnce[name2];
      return;
    }
    if (this.listeners[name2]) {
      const index2 = this.listeners[name2].indexOf(listener);
      if (index2 !== -1) {
        this.listeners[name2].splice(index2, 1);
      }
    }
  }
  clear() {
    this.listeners = {};
    this.listenersOnce = {};
  }
};
var HookServer;
(function(HookServer2) {
  HookServer2["Start"] = "Server.Start";
  HookServer2["Step"] = "Server.Step";
  HookServer2["Auth"] = "Server.Auth";
  HookServer2["PlayerConnected"] = "Server.onConnected";
  HookServer2["PlayerDisconnected"] = "Server.onDisconnected";
  HookServer2["AddMap"] = "Server.AddMap";
  HookServer2["AddEvent"] = "Server.AddEvent";
  HookServer2["AddWorldMaps"] = "Server.AddWorldMaps";
  HookServer2["AddDatabase"] = "Server.AddDatabase";
  HookServer2["PlayerInput"] = "Server.onInput";
  HookServer2["PlayerJoinMap"] = "Server.onJoinMap";
  HookServer2["PlayerLeaveMap"] = "Server.onLeaveMap";
  HookServer2["PlayerLevelUp"] = "Server.onLevelUp";
  HookServer2["PlayerDead"] = "Server.onDead";
  HookServer2["PlayerInShape"] = "Server.onInShape";
  HookServer2["PlayerOutShape"] = "Server.onOutShape";
  HookServer2["PlayerMove"] = "Server.PlayerMove";
  HookServer2["PlayerCanChangeMap"] = "Server.PlayerCanChangeMap";
  HookServer2["ScalabilityPlayerConnected"] = "Server.ScalabilityPlayerConnected";
  HookServer2["ScalabilityChangeServer"] = "Server.ScalabilityChangeServer";
})(HookServer || (HookServer = {}));
var HookClient;
(function(HookClient2) {
  HookClient2["Start"] = "Client.Start";
  HookClient2["Step"] = "Client.Step";
  HookClient2["Connected"] = "Client.Connected";
  HookClient2["Disconnect"] = "Client.Disconnect";
  HookClient2["ConnectedError"] = "Client.ConnectedError";
  HookClient2["AddSpriteSheet"] = "Client.AddSpriteSheet";
  HookClient2["AddGui"] = "Client.AddGui";
  HookClient2["AddSound"] = "Client.AddSound";
  HookClient2["SendInput"] = "Client.SendInput";
  HookClient2["BeforeSceneLoading"] = "Client.BeforeSceneLoading";
  HookClient2["AfterSceneLoading"] = "Client.AfterSceneLoading";
  HookClient2["SceneMapLoading"] = "Client.SceneMapLoading";
  HookClient2["SceneAddSprite"] = "Client.SceneAddSprite";
  HookClient2["SceneOnChanges"] = "Client.SceneOnChanges";
  HookClient2["SceneDraw"] = "Client.SceneDraw";
  HookClient2["SceneRemoveSprite"] = "Client.SceneRemoveSprite";
  HookClient2["AddSprite"] = "Client.AddSprite";
  HookClient2["RemoveSprite"] = "Client.RemoveSprite";
  HookClient2["UpdateSprite"] = "Client.UpdateSprite";
  HookClient2["ChangesSprite"] = "Client.ChangesSprite";
  HookClient2["WindowResize"] = "Client.WindowResize";
  HookClient2["SpriteMove"] = "Client.SpriteMove";
})(HookClient || (HookClient = {}));
let PluginSystem$1 = class PluginSystem extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.customHooks = {};
  }
  customHookExists(name2) {
    return this.customHooks[name2];
  }
  loadPlugins(plugins, shared, type) {
    if (!plugins)
      return;
    for (let plugin of plugins) {
      if (!plugin)
        continue;
      let plug = [];
      if (!isArray$d(plugin)) {
        plug = [plugin];
      } else {
        plug = plugin;
      }
      const [side, options2] = plug;
      if (!side[type])
        continue;
      side[type]({
        RpgPlugin,
        ...shared
      }, options2);
    }
  }
  loadServerPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "server");
  }
  loadClientPlugins(plugins, shared) {
    this.loadPlugins(plugins, shared, "client");
  }
};
const RpgPlugin = new PluginSystem$1();
class GameWorker {
  constructor(options2 = {}) {
    this.options = options2;
  }
  load() {
    return this;
  }
  call(methodName, data) {
    return this.pool.exec(methodName, [data]);
  }
}
var GameSide;
(function(GameSide2) {
  GameSide2["Server"] = "server";
  GameSide2["Client"] = "client";
  GameSide2["Worker"] = "worker";
})(GameSide || (GameSide = {}));
class RpgCommonGame extends EventEmitter$1 {
  initialize(side) {
    this.side = side;
    this.events = {};
  }
  get isWorker() {
    return this.side == "worker";
  }
  start(world) {
    this.world = world;
  }
  createWorkers(options2) {
    return new GameWorker(options2);
  }
  addObject(_class, playerId) {
    let event;
    if (!playerId)
      playerId = generateUID();
    if (isClass(_class)) {
      if (this.side == GameSide.Client) {
        event = new _class(this, playerId);
      } else {
        event = new _class(playerId);
      }
    } else {
      event = _class;
    }
    return event;
  }
  addPlayer(playerClass, playerId) {
    const player2 = this.addObject(playerClass, playerId);
    return player2;
  }
  addEvent(eventClass, eventId) {
    const event = this.addObject(eventClass, eventId);
    return event;
  }
  addShape(obj) {
    const id = obj.name = obj.name || generateUID();
    const shape = new RpgShape(obj);
    shape.name = id;
    return shape;
  }
  async processInput(playerId, controls) {
    const player2 = this.world.getObject(playerId);
    const inputs = [];
    if (!player2)
      return {
        player: player2,
        inputs
      };
    while (player2.pendingMove.length > 0) {
      const inputData = player2.pendingMove.shift();
      let {
        input,
        deltaTimeInt
      } = inputData;
      let moving2 = false;
      if (controls && controls[input]) {
        const control = controls[input];
        const now = Date.now();
        const inputTime = player2.inputsTimestamp[input] || 0;
        if (inputTime >= now) {
          continue;
        }
        if (control.delay) {
          let duration;
          let otherControls = [];
          if (typeof control.delay == "number") {
            duration = control.delay;
          } else {
            duration = control.delay.duration;
            if (control.delay.otherControls) {
              otherControls = control.delay.otherControls;
            }
          }
          player2.inputsTimestamp[input] = now + duration;
          for (let control2 of otherControls) {
            player2.inputsTimestamp[control2] = now + duration;
          }
        }
      }
      if (input == Control.Action) {
        await player2.triggerCollisionWith(RpgCommonPlayer.ACTIONS.ACTION);
      } else if (input == Direction.Left || input == Direction.Right || input == Direction.Up || input == Direction.Down) {
        player2.moving = true;
        moving2 = true;
        await player2.moveByDirection(+input, deltaTimeInt || 1);
      }
      if (this.side == GameSide.Server) {
        await RpgPlugin.emit("Server.onInput", [player2, {
          ...inputData,
          moving: moving2
        }], true);
      }
      inputs.push(input);
    }
    return {
      player: player2,
      inputs
    };
  }
}
const ACTIONS = {
  IDLE: 0,
  RUN: 1,
  ACTION: 2
};
class AbstractObject {
  static get ACTIONS() {
    return ACTIONS;
  }
  constructor(gameEngine, playerId) {
    this.gameEngine = gameEngine;
    this.playerId = playerId;
    this.map = "";
    this.height = 0;
    this.width = 0;
    this.direction = 3;
    this.moving = false;
    this.checkCollision = true;
    this.clientModeMove = MoveClientMode.ByDirection;
    this.behavior = Behavior.Direction;
    this.inShapes = {};
    this.disableVirtualGrid = false;
    this.shapes = [];
    this.collisionWith = [];
    this._collisionWithTiles = [];
    this._collisionWithShapes = [];
    this.destroyMove$ = new Subject$1();
    this._destroy$ = new Subject$1();
    this._hitboxPos = new SAT.Vector(0, 0);
    this.setHitbox(this.width, this.height);
    this.position = {
      x: 0,
      y: 0,
      z: 0
    };
  }
  get id() {
    return this.playerId;
  }
  set id(str2) {
    this.playerId = str2;
  }
  updateInVirtualGrid() {
    const map2 = this.mapInstance;
    if (map2 && !this.disableVirtualGrid) {
      map2.grid.insertInCells(this.id, this.getSizeMaxShape());
    }
  }
  get canMove() {
    return this.clientModeMove == MoveClientMode.ByDirection;
  }
  set canMove(val) {
    this.clientModeMove = val ? MoveClientMode.ByDirection : MoveClientMode.Disabled;
  }
  /**
   * Get/Set position x, y and z of player
   *
   * z is the depth layer. By default, its value is 0. Collisions and overlays will be performed with other objects on the same z-position.
   *
   * @title Get/Set position
   * @prop { { x: number, y: number, z: number } } position
   * @memberof Player
   */
  set position(val) {
    if (this.isDestroyed)
      return;
    const {
      x: x2,
      y: y2,
      z: z2
    } = val;
    if (!isInstanceOf$3(val, Vector2d)) {
      val = new Vector2d(x2, y2, z2);
    }
    this._hitboxPos.x = x2;
    this._hitboxPos.y = y2;
    this._hitboxPos.z = z2;
    this.updateInVirtualGrid();
    this._position = new Proxy(val, {
      get: (target, prop) => target[prop],
      set: (target, prop, value) => {
        this._hitboxPos[prop] = value;
        target[prop] = value;
        this.updateInVirtualGrid();
        return true;
      }
    });
  }
  get position() {
    return this._position;
  }
  get worldPositionX() {
    let x2 = this.position.x;
    if (this.mapInstance) {
      x2 += this.mapInstance.worldX;
    }
    return x2;
  }
  get worldPositionY() {
    let y2 = this.position.y;
    if (this.mapInstance) {
      y2 += this.mapInstance.worldY;
    }
    return y2;
  }
  set posX(val) {
    this.position.x = val;
  }
  set posY(val) {
    this.position.y = val;
  }
  set posZ(val) {
    this.position.z = val;
  }
  /** @internal */
  get mapInstance() {
    if (this.gameEngine.side == GameSide.Client) {
      return RpgCommonMap.bufferClient.get(this.map);
    }
    return RpgCommonMap.buffer.get(this.map);
  }
  /**
  *
  * Recovers all the colliding shapes of the current player
  *
  * @title Get Collision of shapes
  * @since 3.2.0
  * @readonly
  * @prop { RpgShape[] } shapes
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get shapesCollision() {
    return this._collisionWithShapes;
  }
  /**
  *
  * Recovers all the colliding tiles of the current player
  *
  * @title Get Collision of tiles
  * @since 3.0.0-beta.4
  * @readonly
  * @prop { TileInfo[] } tiles
  * @memberof Player
  * @memberof RpgSpriteLogic
  */
  get tilesCollision() {
    return this._collisionWithTiles;
  }
  /**
   *
   * Recovers all other players and events colliding with the current player's hitbox
   *
   * @title Get Collision of other players/events
   * @since 3.0.0-beta.4
   * @readonly
   * @prop { (RpgPlayer | RpgEvent)[] } otherPlayersCollision
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  get otherPlayersCollision() {
    return this.collisionWith;
  }
  /**
   * Define the size of the player. You can set the hitbox for collisions
   *
   * ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32
   * })
   * ```
   *
   * and with hitbox:
   *
   *  ```ts
   * player.setSizes({
   *      width: 32,
   *      height: 32,
   *      hitbox: {
   *          width: 20,
   *          height: 20
   *      }
   * })
   * ```
   *
   * @title Set Sizes
   * @method player.setSizes(key,value)
   * @param { { width: number, height: number, hitbox?: { width: number, height: number } } } obj
   * @deprecated
   * @returns {void}
   * @memberof Player
   */
  setSizes(obj) {
    this.width = obj.width;
    this.height = obj.height;
    if (obj.hitbox) {
      this.hitbox = new SAT.Box(this._hitboxPos, obj.hitbox.width, obj.hitbox.height);
    }
  }
  /**
   * Define the hitbox of the player.
   *
   * ```ts
   * player.setHitbox(20, 20)
   * ```
   *
   * @title Set Hitbox
   * @method player.setHitbox(width,height)
   * @param {number} width
   * @param {number} height
   * @returns {void}
   * @memberof Player
   */
  setHitbox(width, height) {
    const map2 = this.mapInstance;
    if (map2) {
      this.width = map2.tileWidth;
      this.height = map2.tileHeight;
    }
    this.hitbox = new SAT.Box(this._hitboxPos, width, height);
    this.wHitbox = width;
    this.hHitbox = height;
    this.updateInVirtualGrid();
  }
  set wHitbox(val) {
    this.hitbox.w = val;
  }
  set hHitbox(val) {
    this.hitbox.h = val;
  }
  get wHitbox() {
    return this.hitbox.w;
  }
  get hHitbox() {
    return this.hitbox.h;
  }
  directionToAngle(direction) {
    const angle2 = (direction < 2 ? +direction + 2 : direction - 2) * 90;
    return toRadians(angle2);
  }
  /** @internal */
  defineNextPosition(direction, deltaTimeInt) {
    const angle2 = this.directionToAngle(direction);
    const computePosition = (prop) => {
      return this.position[prop] + this.speed * deltaTimeInt * (Math.round(Math[prop == "x" ? "cos" : "sin"](angle2) * 100) / 100);
    };
    const x2 = this.speed < 1 ? computePosition("x") : round$1(computePosition("x"));
    const y2 = this.speed < 1 ? computePosition("y") : round$1(computePosition("y"));
    return new Vector2d(x2, y2, ~~this.position.z);
  }
  /** @internal */
  setPosition({
    x: x2,
    y: y2,
    tileX,
    tileY
  }, move = true) {
    const {
      tileWidth,
      tileHeight
    } = this.mapInstance;
    if (x2 !== void 0)
      this.posX = x2;
    if (y2 !== void 0)
      this.posY = y2;
    if (tileX !== void 0)
      this.posX = tileX * tileWidth;
    if (tileY !== void 0)
      this.posY = tileY * tileHeight;
  }
  /** @internal */
  async triggerCollisionWith(type) {
    let doChanges = false;
    for (let collisionWith of this.collisionWith) {
      if (collisionWith.isDestroyed)
        continue;
      if (collisionWith instanceof RpgShape) {
        const goMap = collisionWith.getProperty("go-map");
        if (goMap && "changeMap" in this)
          await this.changeMap(goMap);
      } else {
        if (type == AbstractObject.ACTIONS.ACTION) {
          if ("onAction" in collisionWith) {
            await collisionWith.execMethod("onAction", [this]);
            doChanges = true;
          }
        } else if ("onPlayerTouch" in collisionWith) {
          await collisionWith.execMethod("onPlayerTouch", [this]);
          doChanges = true;
        }
      }
    }
    if (this.syncChanges && doChanges)
      this.syncChanges();
  }
  /** @internal */
  zCollision(other) {
    const z2 = this.position.z;
    const otherZ = other.position.z;
    return intersection$1([z2, z2 + this.height], [otherZ, otherZ + other.height]);
  }
  /** @internal */
  moveByDirection(direction, deltaTimeInt) {
    const nextPosition = this.defineNextPosition(direction, deltaTimeInt);
    return this.move(nextPosition);
  }
  /**
   * Retrieves a tile and checks if the player has a collision
   *
   * ```ts
   * const tileInfo = player.getTile(20, 30)
   * console.log(tileInfo)
   * ```
   *
   * Example of returns:
   *
   * ```ts
   *   {
   *       tiles: [
   *           {
   *               id: 0,
   *               terrain: [],
   *               probability: null,
   *               properties: [Object],
   *               animations: [],
   *               objectGroups: [],
   *               image: null,
   *               gid: 1
   *           }
   *       ],
   *       hasCollision: false,
   *       isOverlay: undefined,
   *       objectGroups: [],
   *       isClimbable: undefined,
   *       tileIndex: 93
   *   }
   * ```
   *
   * @title Get Tile
   * @since 3.0.0-beta.4
   * @method player.getTile(x,y,z?)
   * @param {number} x
   * @param {number} y
   * @param {number} [z]
   * @returns {object}
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getTile(x2, y2, z2 = 0, hitbox) {
    const map2 = this.mapInstance;
    return map2.getTile(hitbox || this.hitbox, x2, y2, [z2, this.height]);
  }
  async collisionObjects(playerSizeBox, hitbox, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return true;
    const events2 = this.gameEngine.world.getObjectsOfGroup(this.map, this);
    const objects = map2.grid.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let objectId of objects) {
      if (!events2[objectId])
        continue;
      const event = events2[objectId]["object"] || events2[objectId];
      if (event.id == this.id)
        continue;
      if (!this.zCollision(event))
        continue;
      const collided = Hit.testPolyCollision(HitType.Box, hitbox, event.hitbox);
      for (let shape of this.shapes) {
        await this.collisionWithShape(shape, event);
      }
      for (let shape of event.shapes) {
        await event.collisionWithShape(shape, this);
      }
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(event);
      if (collided) {
        this.collisionWith.push(event);
        this.triggerCollisionWith();
        let throughOtherPlayer = false;
        if (event.type == PlayerType.Player && this.type == PlayerType.Player) {
          if (!(event.throughOtherPlayer || this.throughOtherPlayer)) {
            boolFound = true;
            if (!(triggers == null ? void 0 : triggers.allSearch))
              return true;
          } else {
            throughOtherPlayer = true;
          }
        }
        if (!throughOtherPlayer && !(event.through || this.through)) {
          boolFound = true;
          if (!(triggers == null ? void 0 : triggers.allSearch))
            return true;
        }
      }
      if (boolFound) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(event);
      }
    }
    return boolFound;
  }
  /** @internal */
  async collisionWithShape(shape, player2, nextPosition) {
    const collision = shape.hasCollision;
    const z2 = shape.z;
    if (shape.isShapePosition())
      return false;
    if (z2 !== void 0 && !this.zCollision({
      position: {
        z: z2
      },
      height: this.mapInstance.zTileHeight
    })) {
      return false;
    }
    let position;
    let {
      hitbox
    } = player2;
    if (nextPosition) {
      position = nextPosition.copy();
    } else {
      position = player2.position.copy();
    }
    const hitboxObj = Hit.createObjectHitbox(position.x, position.y, position.z, hitbox.w, hitbox.h);
    let collided = Hit.testPolyCollision(shape.type, hitboxObj, shape.hitbox);
    const playerPositionSaved = player2.position.copy();
    const verifyIfPositionChanged = () => {
      if (this.position.z != playerPositionSaved.z && nextPosition) {
        nextPosition.z = this.position.z;
      }
      if (this.position.x != playerPositionSaved.x || this.position.y != playerPositionSaved.y) {
        return true;
      }
    };
    if (collided) {
      this._collisionWithShapes.push(shape);
      if (!collision)
        await shape.in(player2);
      if (verifyIfPositionChanged() === true)
        return true;
      this.triggerCollisionWith();
      if (collision)
        return true;
    } else {
      await shape.out(player2);
      if (verifyIfPositionChanged() === true)
        return true;
    }
    return false;
  }
  async collisionShapes(playerSizeBox, nextPosition, triggers) {
    const map2 = this.mapInstance;
    if (!map2)
      return false;
    const shapes = this.gameEngine.world.getShapesOfGroup(this.map);
    const shapesInGrid = this.gameEngine.side == GameSide.Client ? new Set(Object.keys(shapes)) : map2.gridShapes.getObjectsByBox(playerSizeBox);
    let boolFound = false;
    for (let shapeId of shapesInGrid) {
      const shape = shapes[shapeId]["object"] || shapes[shapeId];
      if (triggers == null ? void 0 : triggers.near)
        triggers.near(shape);
      const bool = await this.collisionWithShape(shape, this, nextPosition);
      if (bool) {
        if (triggers == null ? void 0 : triggers.collision)
          triggers.collision(shape);
        boolFound = true;
        if (!(triggers == null ? void 0 : triggers.allSearch))
          return true;
      }
    }
    return boolFound;
  }
  async computeNextPositionByTarget(nextPosition, target) {
    const pullDistance = target.distanceWith(nextPosition);
    if (pullDistance <= this.speed) {
      return nextPosition.set(target);
    }
    const pull2 = target.copy().subtract(nextPosition).multiply(1 / pullDistance);
    const totalPush = new Vector2dZero();
    let contenders = 0;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
    const createObstacle = function(x2, y2, radius) {
      const obstacle = new Vector2d(x2, y2);
      let push2 = nextPosition.copy().subtract(obstacle);
      let distance2 = nextPosition.distanceWith(obstacle) - radius - radius;
      if (distance2 < radius * 2 * 10) {
        ++contenders;
        if (distance2 < 1e-4)
          distance2 = 1e-4;
        let weight = 1 / distance2;
        totalPush.add(push2.multiply(weight));
      }
      return obstacle;
    };
    const area2 = this.mapInstance.tileheight * 2;
    this.mapInstance.gridTiles.getCells({
      minX: nextPosition.x - area2,
      maxX: nextPosition.x + area2,
      minY: nextPosition.y - area2,
      maxY: nextPosition.y + area2
    }, (index2) => {
      if (index2 < 0)
        return;
      const pos = this.mapInstance.getTilePosition(index2);
      const hitbox2 = Hit.createObjectHitbox(pos.x, pos.y, nextPosition.z, this.hitbox.w, this.hitbox.h);
      const radius = this.mapInstance.tilewidth / 2;
      const tile = this.getTile(pos.x, pos.y, nextPosition.z, hitbox2);
      if (tile.hasCollision) {
        createObstacle(pos.x, pos.y, radius);
      }
    });
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    await this.collisionObjects(playerSizeBox, hitbox, {
      collision: (event) => {
        const {
          x: x2,
          y: y2
        } = event.position;
        createObstacle(x2, y2, event.hitbox.w);
      },
      allSearch: true
    });
    await this.collisionShapes(playerSizeBox, nextPosition, {
      collision: (shape) => {
        const {
          x: x2,
          y: y2
        } = shape.position;
        createObstacle(x2, y2, shape.hitbox.w);
      },
      allSearch: true
    });
    pull2.multiply(Math.max(1, 4 * contenders)).add(totalPush).normalize();
    return nextPosition.add(pull2.multiply(this.speed));
  }
  async isCollided(nextPosition, options2 = {}) {
    var _a;
    this.collisionWith = [];
    this._collisionWithTiles = [];
    const prevMapId = this.map;
    const hitbox = Hit.createObjectHitbox(nextPosition.x, nextPosition.y, 0, this.hitbox.w, this.hitbox.h);
    const boundingMap = (_a = this.mapInstance) == null ? void 0 : _a.boundingMap(nextPosition, this.hitbox);
    let collided = false;
    if (boundingMap == null ? void 0 : boundingMap.bounding) {
      this.position.set(nextPosition);
      if (!options2.allSearch)
        return true;
      else
        collided = true;
    }
    const tileCollision = (x2, y2) => {
      const tile = this.getTile(x2, y2, nextPosition.z, hitbox);
      if (tile.hasCollision) {
        this._collisionWithTiles.push(tile);
        return true;
      }
      return false;
    };
    if (tileCollision(nextPosition.x, nextPosition.y) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y) || tileCollision(nextPosition.x, nextPosition.y + this.hitbox.h) || tileCollision(nextPosition.x + this.hitbox.w, nextPosition.y + this.hitbox.h)) {
      if (!options2.allSearch)
        return true;
      else
        collided = true;
    }
    if (this.autoChangeMap && this.type == PlayerType.Player) {
      const changeMap = await this.autoChangeMap(nextPosition);
      if (changeMap) {
        return true;
      }
    }
    const playerSizeBox = this.getSizeMaxShape(nextPosition.x, nextPosition.y);
    if (await this.collisionObjects(playerSizeBox, hitbox, options2)) {
      if (!options2.allSearch)
        return true;
      else
        collided = true;
    }
    if (await this.collisionShapes(playerSizeBox, nextPosition, options2)) {
      if (!options2.allSearch)
        return true;
      else
        collided = true;
    }
    if (prevMapId != this.map) {
      return true;
    }
    return collided;
  }
  /**
   * Attach a shape to the player (and allow interaction with it)
   *
   * ```ts
   * import { ShapePositioning } from '@rpgjs/server'
   *
   * player.attachShape({
   *      width: 100,
   *      height: 100,
   *      positioning: ShapePositioning.Center
   * })
   * ```
   *
   * @title Attach Shape
   * @method player.attachShape(parameters)
   * @param { { width: number, height: number, positioning?, name?, properties?: object } } obj
   * - positioning: Indicate where the shape is placed.
   * - properties: An object in order to retrieve information when interacting with the shape
   * - name: The name of the shape
   * @since 3.0.0-beta.3
   * @returns {RpgShape}
   * @memberof Player
   */
  attachShape(obj) {
    obj.name = obj.name || generateUID();
    const shape = new RpgShape({
      ...obj,
      fixEvent: this
    });
    this.shapes.push(shape);
    return shape;
  }
  /**
   * Returns all shapes assigned to this player
   *
   * @title Get Shapes
   * @method player.getShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   * @memberof RpgSpriteLogic
   */
  getShapes() {
    return this.shapes;
  }
  autoChangeDirection(nextPosition) {
    const {
      x: x2,
      y: y2
    } = this.position;
    const {
      x: nx,
      y: ny
    } = nextPosition;
    const diff = Math.abs(x2 - nx) > Math.abs(y2 - ny);
    if (diff) {
      if (nx > x2) {
        this.changeDirection(Direction.Right);
      } else {
        this.changeDirection(Direction.Left);
      }
    } else {
      if (ny > y2) {
        this.changeDirection(Direction.Down);
      } else {
        this.changeDirection(Direction.Up);
      }
    }
  }
  // @internal
  /**
   * We need to know if the event is deleted. Because when the event is deleted, you don't update the positions and you don't send the positions back to the client.
   */
  get isDestroyed() {
    return !!this._destroy$["_closed"];
  }
  /**
  * Stops the movement of the player who moves towards his target
  *
  * @title Stop Move To
  * @method player.stopMoveTo()
  * @returns {void}
  * @since 3.2.0
  * @memberof MoveManager
  */
  stopMoveTo() {
    if (this.destroyMove$.closed)
      return;
    this.moving = false;
    this.destroyMove$.next(true);
    this.destroyMove$.unsubscribe();
  }
  _lookToward(player2, otherPlayer) {
    const {
      x: x2,
      y: y2
    } = player2;
    const {
      x: ox,
      y: oy
    } = otherPlayer;
    const dx = ox - x2;
    const dy = oy - y2;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) {
        return Direction.Right;
      } else {
        return Direction.Left;
      }
    } else {
      if (dy > 0) {
        return Direction.Down;
      } else {
        return Direction.Up;
      }
    }
  }
  _moveTo(tick$, positionTarget, options2 = {}) {
    let i2 = 0;
    let count = 0;
    const lastPositions = [];
    this.stopMoveTo();
    this.moving = true;
    this.destroyMove$ = new Subject$1();
    const {
      infinite,
      onStuck,
      onComplete
    } = options2;
    const getPosition = () => {
      let pos;
      if ("x" in positionTarget) {
        pos = new Vector2d(positionTarget.x, positionTarget.y);
      } else {
        pos = positionTarget.position;
      }
      return pos;
    };
    return tick$.pipe(takeUntil(this.destroyMove$), takeUntil(this._destroy$), mergeMap(() => from(this.computeNextPositionByTarget(this.position.copy(), getPosition()))), filter$1(() => {
      return this.isDestroyed === false;
    }), map$6((position) => {
      this.autoChangeDirection(position);
      return this.position.set(position);
    }), tap((position) => {
      lastPositions[i2] = position.copy();
      i2++;
      count++;
      if (i2 >= 3) {
        i2 = 0;
      }
      if (lastPositions[2] && (lastPositions[0].isEqual(lastPositions[2]) || lastPositions[1].isEqual(lastPositions[2]) || lastPositions[0].isEqual(lastPositions[1]))) {
        this.direction = this._lookToward(this.position, getPosition());
        onStuck == null ? void 0 : onStuck(count);
        this.moving = false;
      } else if (this.position.isEqual(getPosition())) {
        onComplete == null ? void 0 : onComplete();
        if (!infinite) {
          this.stopMoveTo();
        }
      } else {
        count = 0;
        this.moving = true;
      }
    }));
  }
  /** @internal */
  async move(nextPosition) {
    this.autoChangeDirection(nextPosition);
    const notCollided = !await this.isCollided(nextPosition);
    if ((notCollided || !this.checkCollision) && !this.isDestroyed) {
      this.position = nextPosition.copy();
      await RpgPlugin.emit(HookServer.PlayerMove, this);
    }
    return true;
  }
  /**
   * Retrieves all shapes where the player is located
   *
   * @title Get In-Shapes
   * @method player.getInShapes()
   * @returns {RpgShape[]}
   * @since 3.0.0-beta.3
   * @memberof Player
   */
  getInShapes() {
    return Object.values(this.inShapes);
  }
  /**
  * Get the current direction.
  *
  * ```ts
  * player.getDirection()
  * ```
  *
  * @title Get Direction
  * @method player.getDirection()
  * @returns {Direction | number} direction
  * @memberof Player
  */
  getDirection(direction) {
    return direction || this.direction;
  }
  /**
  * Changes the player's direction
  *
  * ```ts
  * import { Direction } from '@rpgjs/server'
  *
  * player.changeDirection(Direction.Left)
  * ```
  *
  * @title Change direction
  * @method player.changeDirection(direction)
  * @param {Direction} direction
  * @enum {string}
  *
  * Direction.Left | left
  * Direction.Right | right
  * Direction.Up | up
  * Direction.Down | down
  * @returns {boolean} the direction has changed
  * @memberof Player
  */
  changeDirection(direction) {
    const dir = +this.getDirection(direction);
    if (dir === void 0)
      return false;
    this.direction = dir;
    return true;
  }
  /**
   * Gets the necessary number of pixels to allow the player to cross a tile.
   * This is the ratio between the height or width of the tile and the speed of the player.
   */
  get nbPixelInTile() {
    const direction = this.getDirection();
    switch (direction) {
      case Direction.Down:
      case Direction.Up:
        return Math.floor(this.mapInstance.tileHeight / this.speed);
      case Direction.Left:
      case Direction.Right:
        return Math.floor(this.mapInstance.tileWidth / this.speed);
      default:
        return NaN;
    }
  }
  getSizeMaxShape(x2, y2) {
    const _x = x2 || this.position.x;
    const _y = y2 || this.position.y;
    let minX = _x;
    let minY = _y;
    let maxX = _x + this.wHitbox;
    let maxY = _y + this.hHitbox;
    const shapes = this.getShapes();
    for (let shape of shapes) {
      if (shape.x < minX)
        minX = shape.x;
      if (shape.y < minY)
        minY = shape.y;
      const shapeMaxX = shape.x + shape.width;
      const shapeMaxY = shape.y + shape.height;
      if (shapeMaxX > maxX)
        maxX = shapeMaxX;
      if (shapeMaxY > maxY)
        maxY = shapeMaxY;
    }
    return {
      minX,
      minY,
      maxX,
      maxY
    };
  }
  /** @internal */
  async execMethod(methodName, methodData, instance) {
  }
}
const LiteralDirection = {
  1: "up",
  2: "right",
  3: "down",
  4: "left"
};
class RpgCommonPlayer extends AbstractObject {
  constructor() {
    super(...arguments);
    this.events = [];
    this.layerName = "";
    this.data = {};
    this.pendingMove = [];
    this.inputsTimestamp = {};
  }
}
var PrebuiltGui;
(function(PrebuiltGui2) {
  PrebuiltGui2["Dialog"] = "rpg-dialog";
  PrebuiltGui2["MainMenu"] = "rpg-main-menu";
  PrebuiltGui2["Shop"] = "rpg-shop";
  PrebuiltGui2["Disconnect"] = "rpg-disconnect";
  PrebuiltGui2["Gameover"] = "rpg-gameover";
  PrebuiltGui2["Save"] = "rpg-save";
  PrebuiltGui2["Controls"] = "rpg-controls";
  PrebuiltGui2["Notification"] = "rpg-notification";
})(PrebuiltGui || (PrebuiltGui = {}));
let MockIo$1 = class MockIo {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  on(name2, value) {
    this.events.set(name2, value);
  }
  off(name2) {
    this.events.delete(name2);
  }
  once(name2, value) {
    this.on(name2, value);
  }
  _trigger(name2, data, client) {
    const fn = this.events.get(name2);
    if (fn)
      fn(data, client);
  }
};
let MockSocket$1 = class MockSocket {
  constructor(io, handshake) {
    this.io = io;
    this.handshake = handshake;
    this.id = "" + Math.random();
  }
  on(name2, value) {
    this.io.on(name2, value, this.id);
    return this;
  }
  once(name2, value) {
    this.io.once(name2, value, this.id);
    return this;
  }
  emit(name2, data) {
    this.io.emit(name2, data, this.id);
  }
  removeAllListeners(name2) {
    return this.off(name2);
  }
  off(name2) {
    this.io.off(name2, this.id);
  }
};
let MockServerIo$1 = class MockServerIo extends MockIo$1 {
  constructor() {
    super(...arguments);
    this.clients = /* @__PURE__ */ new Map();
  }
  connection(client, handshake) {
    const socket = new MockSocket$1(this, handshake);
    this.clients.set(socket.id, client);
    client.id = socket.id;
    this._trigger("connection", socket);
  }
  emit(name2, data, id) {
    var _a;
    (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name2, data);
  }
  clear() {
    this.clients.clear();
  }
};
new MockServerIo$1();
class Scheduler extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.fps = 60;
    this.deltaTime = 0;
    this.frame = 0;
    this.timestamp = 0;
    this.requestedDelay = 0;
    this.lastTimestamp = 0;
    this._tick = new BehaviorSubject$1({
      timestamp: 0,
      deltaTime: 0,
      frame: 0,
      deltaRatio: 0
    });
    this._stop = false;
  }
  get tick() {
    return this._tick.asObservable();
  }
  nextTick(timestamp) {
    this.lastTimestamp = this.lastTimestamp || this.timestamp;
    this.deltaTime = Utils$1.preciseNow() - this.timestamp;
    this.timestamp = timestamp;
    this._tick.next({
      timestamp: this.timestamp,
      deltaTime: this.deltaTime,
      frame: this.frame,
      deltaRatio: ~~this.deltaTime / ~~Utils$1.fps2ms(this.fps)
    });
    this.lastTimestamp = this.timestamp;
    this.frame++;
  }
  /**
   * start the schedule
   * @return {Scheduler} returns this scheduler instance
   */
  start(options2) {
    if (options2.maxFps)
      this.maxFps = options2.maxFps;
    if (options2.fps)
      this.fps = options2.fps;
    if (options2.delay)
      this.requestedDelay = options2.delay;
    const requestAnimationFrame2 = (fn) => {
      if (Utils$1.isBrowser()) {
        window.requestAnimationFrame(fn.bind(this));
      } else {
        setTimeout(() => {
          this.requestedDelay = 0;
          fn(Utils$1.preciseNow());
        }, Utils$1.fps2ms(this.fps) + this.requestedDelay);
      }
    };
    if (!this.maxFps) {
      const loop = (timestamp) => {
        requestAnimationFrame2(loop);
        this.nextTick(timestamp);
      };
      requestAnimationFrame2(loop);
    } else {
      const msInterval = Utils$1.fps2ms(this.maxFps);
      let now = Utils$1.preciseNow();
      let then = Utils$1.preciseNow();
      const loop = (timestamp) => {
        if (this._stop)
          return;
        requestAnimationFrame2(loop);
        now = Utils$1.preciseNow();
        const elapsed = now - then;
        if (elapsed > msInterval) {
          then = now - elapsed % msInterval;
          this.nextTick(timestamp);
        }
      };
      requestAnimationFrame2(loop);
    }
    return this;
  }
  stop() {
    this._stop = true;
    this._tick.complete();
  }
}
function warning(...message) {
  console.warn("[RPGJS Warning]", ...message);
}
var Side;
(function(Side2) {
  Side2["Server"] = "server";
  Side2["Client"] = "client";
})(Side || (Side = {}));
function RpgModule(options2) {
  return (target) => {
    if (options2.hooks) {
      target.hooks = options2.hooks;
    }
    for (let key in options2) {
      target.prototype[key] = options2[key];
    }
  };
}
async function loadModules(modules, obj, middleware) {
  const {
    side,
    relations
  } = obj;
  let playerProps = {};
  let hooks = {};
  const getModuleClass = (module) => {
    if (!module)
      return null;
    let plug = [];
    if (!isArray$d(module)) {
      plug = [module];
    } else {
      plug = module;
    }
    const [moduleClassSides, options2] = plug;
    const moduleClass = moduleClassSides[side];
    if (!moduleClass)
      return null;
    return {
      moduleClass,
      options: options2
    };
  };
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const {
      moduleClass
    } = moduleObject;
    if (moduleClass.hooks) {
      for (let key in moduleClass.hooks) {
        if (!hooks[key])
          hooks[key] = [];
        hooks[key] = [...hooks[key], ...moduleClass.hooks[key]];
      }
    }
  }
  for (let module of modules) {
    const moduleObject = getModuleClass(module);
    if (!moduleObject)
      continue;
    const {
      moduleClass,
      options: options2
    } = moduleObject;
    let mod;
    if (options2 && side == Side.Client && options2[Side.Server]) {
      warning(`Data that may be sensitive (normally visible only on the server side) are made optional and visible on the client side.
Instead, import the configuration with the server! flag into an import. Example: 

import config from 'server!./config

'`, options2[Side.Server]);
    }
    if (options2 && !isClass(moduleClass) && isFunction$8(moduleClass)) {
      mod = new (moduleClass(options2[side]))();
    } else if (isClass(moduleClass)) {
      mod = new moduleClass();
    } else {
      mod = moduleClass;
    }
    if (middleware) {
      mod = middleware(mod);
      if (isPromise$3(mod)) {
        mod = await mod;
      }
    }
    const {
      imports,
      maps,
      spritesheets: spritesheets2,
      sounds: sounds2,
      gui,
      scenes,
      engine,
      database,
      worldMaps,
      scalability,
      events: events2
    } = mod;
    if (imports) {
      await loadModules(imports, obj);
    }
    if (maps) {
      RpgPlugin.on(HookServer.AddMap, () => maps);
    }
    if (events2) {
      RpgPlugin.on(HookServer.AddEvent, () => events2);
    }
    if (worldMaps) {
      RpgPlugin.on(HookServer.AddWorldMaps, () => worldMaps);
    }
    if (database) {
      RpgPlugin.on(HookServer.AddDatabase, () => database);
    }
    if (spritesheets2) {
      RpgPlugin.on(HookClient.AddSpriteSheet, () => spritesheets2);
    }
    if (sounds2) {
      RpgPlugin.on(HookClient.AddSound, () => sounds2);
    }
    if (gui) {
      RpgPlugin.on(HookClient.AddGui, () => gui);
    }
    const player2 = side == Side.Server ? mod.player : mod.sprite;
    const loadRelations = (hook, relationName) => {
      if (!hook)
        return;
      for (let method in relations[relationName]) {
        const hookName = relations[relationName][method];
        if (hook[method])
          RpgPlugin.on(hookName, hook[method]);
      }
      if (hooks[relationName]) {
        for (let methodName of hooks[relationName]) {
          const hookName = side + "." + relationName + "." + methodName;
          RpgPlugin.customHooks[hookName] = true;
          if (hook[methodName])
            RpgPlugin.on(hookName, hook[methodName]);
        }
      }
    };
    loadRelations(player2, "player");
    if (player2 && player2.props) {
      playerProps = Object.assign(playerProps, player2.props);
    }
    loadRelations(engine, "engine");
    if (scalability)
      loadRelations(scalability._hooks, "scalability");
    if (scenes)
      loadRelations(scenes.map, "sceneMap");
  }
  return {
    playerProps
  };
}
function quickselect(arr, k4, left, right, compare3) {
  quickselectStep(arr, k4, left || 0, right || arr.length - 1, compare3 || defaultCompare);
}
function quickselectStep(arr, k4, left, right, compare3) {
  while (right > left) {
    if (right - left > 600) {
      var n2 = right - left + 1;
      var m2 = k4 - left + 1;
      var z2 = Math.log(n2);
      var s2 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k4 - m2 * s2 / n2 + sd));
      var newRight = Math.min(right, Math.floor(k4 + (n2 - m2) * s2 / n2 + sd));
      quickselectStep(arr, k4, newLeft, newRight, compare3);
    }
    var t2 = arr[k4];
    var i2 = left;
    var j2 = right;
    swap(arr, left, k4);
    if (compare3(arr[right], t2) > 0)
      swap(arr, left, right);
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (compare3(arr[i2], t2) < 0)
        i2++;
      while (compare3(arr[j2], t2) > 0)
        j2--;
    }
    if (compare3(arr[left], t2) === 0)
      swap(arr, left, j2);
    else {
      j2++;
      swap(arr, j2, right);
    }
    if (j2 <= k4)
      left = j2 + 1;
    if (k4 <= j2)
      right = j2 - 1;
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultCompare(a8, b3) {
  return a8 < b3 ? -1 : a8 > b3 ? 1 : 0;
}
class RBush {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects$1(bbox, node))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects$1(bbox, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects$1(bbox, node))
      return false;
    const nodesToSearch = [];
    while (node) {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects$1(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this.insert(data[i2]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path2 = [];
    const indexes = [];
    let i2, parent, goingUp;
    while (node || path2.length) {
      if (!node) {
        node = path2.pop();
        parent = path2[path2.length - 1];
        i2 = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index2 = findItem(item, node.children, equalsFn);
        if (index2 !== -1) {
          node.children.splice(index2, 1);
          path2.push(node);
          this._condense(path2);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path2.push(node);
        indexes.push(i2);
        i2 = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i2++;
        node = parent.children[i2];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a8, b3) {
    return a8.minX - b3.minX;
  }
  compareMinY(a8, b3) {
    return a8.minY - b3.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push(...node.children);
      else
        nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N2 = right - left + 1;
    let M2 = this._maxEntries;
    let node;
    if (N2 <= M2) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N2) / Math.log(M2));
      M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N22 = Math.ceil(N2 / M2);
    const N1 = N22 * Math.ceil(Math.sqrt(M2));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i2 = left; i2 <= right; i2 += N1) {
      const right2 = Math.min(i2 + N1 - 1, right);
      multiSelect(items, i2, right2, N22, this.compareMinY);
      for (let j2 = i2; j2 <= right2; j2 += N22) {
        const right3 = Math.min(j2 + N22 - 1, right2);
        node.children.push(this._build(items, j2, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path2) {
    while (true) {
      path2.push(node);
      if (node.leaf || path2.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const area2 = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area2;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area2 < minArea ? area2 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area2 < minArea) {
            minArea = area2;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend$2(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M2 = node.children.length;
    const m2 = this._minEntries;
    this._chooseSplitAxis(node, m2, M2);
    const splitIndex = this._chooseSplitIndex(node, m2, M2);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m2, M2) {
    let index2;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i2 = m2; i2 <= M2 - m2; i2++) {
      const bbox1 = distBBox(node, 0, i2, this.toBBox);
      const bbox2 = distBBox(node, i2, M2, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area2 = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index2 = i2;
        minArea = area2 < minArea ? area2 : minArea;
      } else if (overlap === minOverlap) {
        if (area2 < minArea) {
          minArea = area2;
          index2 = i2;
        }
      }
    }
    return index2 || M2 - m2;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m2, M2) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m2, M2, compareMinX);
    const yMargin = this._allDistMargin(node, m2, M2, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m2, M2, compare3) {
    node.children.sort(compare3);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m2, toBBox);
    const rightBBox = distBBox(node, M2 - m2, M2, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i2 = m2; i2 < M2 - m2; i2++) {
      const child = node.children[i2];
      extend$2(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i2 = M2 - m2 - 1; i2 >= m2; i2--) {
      const child = node.children[i2];
      extend$2(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path2, level) {
    for (let i2 = level; i2 >= 0; i2--) {
      extend$2(path2[i2], bbox);
    }
  }
  _condense(path2) {
    for (let i2 = path2.length - 1, siblings; i2 >= 0; i2--) {
      if (path2[i2].children.length === 0) {
        if (i2 > 0) {
          siblings = path2[i2 - 1].children;
          siblings.splice(siblings.indexOf(path2[i2]), 1);
        } else
          this.clear();
      } else
        calcBBox(path2[i2], this.toBBox);
    }
  }
}
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i2 = 0; i2 < items.length; i2++) {
    if (equalsFn(item, items[i2]))
      return i2;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k4, p2, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i2 = k4; i2 < p2; i2++) {
    const child = node.children[i2];
    extend$2(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend$2(a8, b3) {
  a8.minX = Math.min(a8.minX, b3.minX);
  a8.minY = Math.min(a8.minY, b3.minY);
  a8.maxX = Math.max(a8.maxX, b3.maxX);
  a8.maxY = Math.max(a8.maxY, b3.maxY);
  return a8;
}
function compareNodeMinX(a8, b3) {
  return a8.minX - b3.minX;
}
function compareNodeMinY(a8, b3) {
  return a8.minY - b3.minY;
}
function bboxArea(a8) {
  return (a8.maxX - a8.minX) * (a8.maxY - a8.minY);
}
function bboxMargin(a8) {
  return a8.maxX - a8.minX + (a8.maxY - a8.minY);
}
function enlargedArea(a8, b3) {
  return (Math.max(b3.maxX, a8.maxX) - Math.min(b3.minX, a8.minX)) * (Math.max(b3.maxY, a8.maxY) - Math.min(b3.minY, a8.minY));
}
function intersectionArea(a8, b3) {
  const minX = Math.max(a8.minX, b3.minX);
  const minY = Math.max(a8.minY, b3.minY);
  const maxX = Math.min(a8.maxX, b3.maxX);
  const maxY = Math.min(a8.maxY, b3.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a8, b3) {
  return a8.minX <= b3.minX && a8.minY <= b3.minY && b3.maxX <= a8.maxX && b3.maxY <= a8.maxY;
}
function intersects$1(a8, b3) {
  return b3.minX <= a8.maxX && b3.minY <= a8.maxY && b3.maxX >= a8.minX && b3.maxY >= a8.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n2, compare3) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n2)
      continue;
    const mid = left + Math.ceil((right - left) / n2 / 2) * n2;
    quickselect(arr, mid, left, right, compare3);
    stack.push(left, mid, mid, right);
  }
}
class RpgCommonWorldMaps {
  constructor(id) {
    this.id = id;
    this.mapsTree = new RBush(500);
    this.maps = /* @__PURE__ */ new Map();
  }
  /**
   * Adding information from the map to the world
   *
   * > Maximum maps in world: 500
   *
   * @title Add Map in world
   * @method world.addMap(wordMapInfo,map)
   * @param {object} wordMapInfo
   * Object file:
   * ```ts
   * {
   *  fileName: string;
      height: number;
      width: number;
      x: number;
      y: number;
   * }
      ```
      `fileName` represents a file to the JSON file (TMX transformed) or directly the Tiled Map Editor object
   *
   * @param {class of RpgMap} map
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  addMap(wordMapInfo, map2) {
    const {
      x: x2,
      y: y2,
      height,
      width
    } = wordMapInfo;
    map2.prototype.worldMapParent = this;
    this.maps.set(map2.id, wordMapInfo);
    this.mapsTree.insert({
      minX: x2,
      minY: y2,
      maxX: x2 + width,
      maxY: y2 + height,
      map: map2
    });
  }
  updateMap(mapId, wordMapInfo) {
    const map2 = this.maps.get(mapId);
    if (map2) {
      const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
      if (!item)
        return false;
      this.maps.set(mapId, wordMapInfo);
      item.map.prototype.worldMapParent = this;
      item.minX = wordMapInfo.x;
      item.minY = wordMapInfo.y;
      item.maxX = wordMapInfo.x + wordMapInfo.width;
      item.maxY = wordMapInfo.y + wordMapInfo.height;
      return true;
    }
    return false;
  }
  /**
   * Remove map of the world
   * @title Remove map of the world
   * @method world.removeMap(mapId)
   * @param {string} mapId
   * @returns {boolean}
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  removeMap(mapId) {
    const map2 = this.maps.get(mapId);
    if (map2) {
      const item = this.mapsTree.all().find((item2) => item2.map.id == mapId);
      if (!item)
        return false;
      this.maps.delete(mapId);
      item.map.prototype.worldMapParent = void 0;
      this.mapsTree.remove(item);
      return true;
    }
    return false;
  }
  removeAllMaps() {
    this.maps.forEach((map2, id) => {
      this.removeMap(id);
    });
  }
  /**
   * Retrieve information from the world
   *
   * @title Retrieve information from the world
   * @method world.getMapInfo(id)
   * @param {string} id map id
   * @return {RpgTiledWorldMap | undefined}
   * {
   *  id?: string
   *  properties?: object
   *  fileName: string;
      height: number;
      width: number;
      x: number;
      y: number;
   * }
   * @since 3.0.0-beta.8
   * @memberof RpgWorldMaps
   */
  getMapInfo(id) {
    return this.maps.get(id);
  }
  /**
   * Retrieves neighboring maps according to positions or direction
   *
   * @title Retrieves neighboring maps
   * @method world.getAdjacentMaps(map,search)
   * @param {RpgMap} map The source map. We want to find the neighboring maps of the source map
   * @param { PositionBox | Direction | { x: number, y: number } } search Research method
   *  * PositionBox. An object of the following form:
   *  `{ minX: number, minY: number, maxX: number, maxY: number }`
   *  * Direction. Collect all the maps in the given direction (e.g. the maps at the top)
   *  * Point: { x: number, y: number }
   * @return { {class of RpgMap}[] }
   * @since 3.0.0-beta.8
   * @example
   * ```ts
   * world.getAdjacentMaps(mymap, Direction.Up) // returns [class of RpgMap]
   * ```
   * @memberof RpgWorldMaps
   */
  getAdjacentMaps(map2, search) {
    let position = {};
    const point = search;
    if (typeof search == "number") {
      const padding = 1;
      switch (search) {
        case Direction.Up:
          position = {
            minX: map2.worldX + padding,
            maxX: map2.worldX + map2.widthPx - padding,
            minY: map2.worldY - padding - 1,
            maxY: map2.worldY - padding
          };
          break;
        case Direction.Right:
          position = {
            minX: map2.worldX + map2.widthPx + padding,
            maxX: map2.worldX + map2.widthPx + padding + 1,
            minY: map2.worldY + padding,
            maxY: map2.worldY + map2.heightPx - padding
          };
          break;
        case Direction.Down:
          position = {
            minX: map2.worldX + padding,
            maxX: map2.worldX + map2.widthPx - padding,
            minY: map2.worldY + map2.heightPx + padding,
            maxY: map2.worldY + map2.heightPx + padding + 1
          };
          break;
        case Direction.Left:
          position = {
            minX: map2.worldX - padding,
            maxX: map2.worldX - padding - 1,
            minY: map2.worldY + padding,
            maxY: map2.worldY + map2.heightPx - padding
          };
          break;
      }
    } else if (point.x) {
      position = {
        minX: point.x,
        maxX: point.x,
        minY: point.y,
        maxY: point.y
      };
    } else {
      position = search;
    }
    const result = this.mapsTree.search(position);
    return result.map((ret) => ret.map);
  }
}
function hexToRGB(hex) {
  let r2 = parseInt(hex.substring(0, 2), 16);
  let g2 = parseInt(hex.substring(2, 4), 16);
  let b3 = parseInt(hex.substring(4, 6), 16);
  return [r2, g2, b3];
}
function RGBToHex(rgb) {
  let r2 = rgb[0].toString(16).padStart(2, "0");
  let g2 = rgb[1].toString(16).padStart(2, "0");
  let b3 = rgb[2].toString(16).padStart(2, "0");
  return r2 + g2 + b3;
}
function transitionColor(startColor, endColor, steps) {
  let startRGB = hexToRGB(startColor.replace("#", ""));
  let endRGB = hexToRGB(endColor.replace("#", ""));
  let deltaRGB = [(endRGB[0] - startRGB[0]) / steps, (endRGB[1] - startRGB[1]) / steps, (endRGB[2] - startRGB[2]) / steps];
  let colors = [];
  for (let i2 = 0; i2 < steps; i2++) {
    let color = [startRGB[0] + deltaRGB[0] * i2, startRGB[1] + deltaRGB[1] * i2, startRGB[2] + deltaRGB[2] * i2];
    colors.push(RGBToHex(color));
  }
  colors.push(endColor.replace("#", ""));
  return colors;
}
const DefaultInput = {
  [Control.Up]: {
    repeat: true,
    bind: Input.Up
  },
  [Control.Down]: {
    repeat: true,
    bind: Input.Down
  },
  [Control.Right]: {
    repeat: true,
    bind: Input.Right
  },
  [Control.Left]: {
    repeat: true,
    bind: Input.Left
  },
  [Control.Action]: {
    bind: [Input.Space, Input.Enter]
  },
  [Control.Back]: {
    bind: Input.Escape
  }
};
class InjectContext {
  constructor() {
    this.instances = /* @__PURE__ */ new Map();
  }
  inject(constructor, args = []) {
    const serviceName = constructor.name;
    if (!this.instances.has(serviceName)) {
      const instance = new constructor(this, ...args);
      if (instance["initialize"]) {
        instance["initialize"](...args);
      }
      this.instances.set(serviceName, instance);
    }
    return this.instances.get(serviceName);
  }
}
const GENERIC_KEY_SCHEMA = "@";
class Utils {
  static isObject(val) {
    return typeof val === "object" && !Array.isArray(val) && val != null;
  }
  static propertiesToArray(obj) {
    const addDelimiter = (a8, b3) => a8 ? `${a8}.${b3}` : b3;
    const paths = (obj2 = {}, head = "") => {
      return Object.entries(obj2).reduce((product, array2) => {
        const [key] = array2;
        const value = array2[1];
        const extraProp = Room.hasExtraProp(value);
        let fullPath = addDelimiter(head, key == "0" ? GENERIC_KEY_SCHEMA : key);
        if (extraProp) {
          if (value.$syncWithClient === false) {
            return product;
          }
        }
        if (key[0] != "_" && !extraProp && (Utils.isObject(value) || Array.isArray(value))) {
          if (Object.keys(value).length == 0) {
            return product.concat(fullPath);
          }
          return product.concat(paths(value, fullPath));
        } else {
          return product.concat(fullPath);
        }
      }, []);
    };
    return paths(obj);
  }
  static generateId(n2 = 5) {
    return Math.random().toString(36).substring(n2);
  }
  static async resolveValue(value) {
    if (value instanceof Promise) {
      return await value;
    }
    return value;
  }
  static set(obj, path2, value, onlyPlainObject = false) {
    if (Object(obj) !== obj)
      return obj;
    if (typeof path2 === "string") {
      path2 = path2.split(".");
    }
    let len = path2.length;
    if (!len)
      return obj;
    let current = obj;
    for (let i2 = 0; i2 < len - 1; i2++) {
      let segment = path2[i2];
      let nextSegment = path2[i2 + 1];
      let isNextNumeric = !isNaN(nextSegment) && isFinite(nextSegment);
      if (!current[segment] || typeof current[segment] !== "object") {
        current[segment] = isNextNumeric && !onlyPlainObject ? [] : {};
      }
      current = current[segment];
    }
    current[path2[len - 1]] = value;
    return obj;
  }
  static get(obj, path2) {
    const keys2 = path2.split(".");
    let current = obj;
    for (let key of keys2) {
      if (current[key] === void 0) {
        return void 0;
      }
      current = current[key];
    }
    return current;
  }
  static bufferFrom(input) {
    if (typeof input === "string") {
      let encoder2 = new TextEncoder();
      return encoder2.encode(input);
    } else if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
      return new Uint8Array(input);
    } else {
      throw new Error("Input type not supported");
    }
  }
}
var browser = {};
var encode$1 = {};
var encodeBuffer = {};
var writeCore = {};
var extBuffer = {};
var bufferish = {};
var bufferGlobal = c$2("undefined" !== typeof Buffer$2 && Buffer$2) || c$2(commonjsGlobal.Buffer) || c$2("undefined" !== typeof window && window.Buffer) || commonjsGlobal.Buffer;
function c$2(B3) {
  return B3 && B3.isBuffer && B3;
}
var toString$2 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
var bufferishArray = { exports: {} };
var hasRequiredBufferishArray;
function requireBufferishArray() {
  if (hasRequiredBufferishArray)
    return bufferishArray.exports;
  hasRequiredBufferishArray = 1;
  var Bufferish2 = requireBufferish();
  var exports = bufferishArray.exports = alloc2(0);
  exports.alloc = alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Array(size2);
  }
  function from2(value) {
    if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
      value = Bufferish2.Uint8Array.from(value);
    } else if (Bufferish2.isArrayBuffer(value)) {
      value = new Uint8Array(value);
    } else if (typeof value === "string") {
      return Bufferish2.from.call(exports, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return Array.prototype.slice.call(value);
  }
  return bufferishArray.exports;
}
var bufferishBuffer = { exports: {} };
var hasRequiredBufferishBuffer;
function requireBufferishBuffer() {
  if (hasRequiredBufferishBuffer)
    return bufferishBuffer.exports;
  hasRequiredBufferishBuffer = 1;
  var Bufferish2 = requireBufferish();
  var Buffer2 = Bufferish2.global;
  var exports = bufferishBuffer.exports = Bufferish2.hasBuffer ? alloc2(0) : [];
  exports.alloc = Bufferish2.hasBuffer && Buffer2.alloc || alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Buffer2(size2);
  }
  function from2(value) {
    if (!Bufferish2.isBuffer(value) && Bufferish2.isView(value)) {
      value = Bufferish2.Uint8Array.from(value);
    } else if (Bufferish2.isArrayBuffer(value)) {
      value = new Uint8Array(value);
    } else if (typeof value === "string") {
      return Bufferish2.from.call(exports, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (Buffer2.from && Buffer2.from.length !== 1) {
      return Buffer2.from(value);
    } else {
      return new Buffer2(value);
    }
  }
  return bufferishBuffer.exports;
}
var bufferishUint8array = { exports: {} };
var hasRequiredBufferishUint8array;
function requireBufferishUint8array() {
  if (hasRequiredBufferishUint8array)
    return bufferishUint8array.exports;
  hasRequiredBufferishUint8array = 1;
  var Bufferish2 = requireBufferish();
  var exports = bufferishUint8array.exports = Bufferish2.hasArrayBuffer ? alloc2(0) : [];
  exports.alloc = alloc2;
  exports.concat = Bufferish2.concat;
  exports.from = from2;
  function alloc2(size2) {
    return new Uint8Array(size2);
  }
  function from2(value) {
    if (Bufferish2.isView(value)) {
      var byteOffset = value.byteOffset;
      var byteLength2 = value.byteLength;
      value = value.buffer;
      if (value.byteLength !== byteLength2) {
        if (value.slice) {
          value = value.slice(byteOffset, byteOffset + byteLength2);
        } else {
          value = new Uint8Array(value);
          if (value.byteLength !== byteLength2) {
            value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
          }
        }
      }
    } else if (typeof value === "string") {
      return Bufferish2.from.call(exports, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return new Uint8Array(value);
  }
  return bufferishUint8array.exports;
}
var bufferishProto = {};
var bufferLite = {};
bufferLite.copy = copy2;
bufferLite.toString = toString$1;
bufferLite.write = write$1;
function write$1(string, offset) {
  var buffer2 = this;
  var index2 = offset || (offset |= 0);
  var length = string.length;
  var chr = 0;
  var i2 = 0;
  while (i2 < length) {
    chr = string.charCodeAt(i2++);
    if (chr < 128) {
      buffer2[index2++] = chr;
    } else if (chr < 2048) {
      buffer2[index2++] = 192 | chr >>> 6;
      buffer2[index2++] = 128 | chr & 63;
    } else if (chr < 55296 || chr > 57343) {
      buffer2[index2++] = 224 | chr >>> 12;
      buffer2[index2++] = 128 | chr >>> 6 & 63;
      buffer2[index2++] = 128 | chr & 63;
    } else {
      chr = (chr - 55296 << 10 | string.charCodeAt(i2++) - 56320) + 65536;
      buffer2[index2++] = 240 | chr >>> 18;
      buffer2[index2++] = 128 | chr >>> 12 & 63;
      buffer2[index2++] = 128 | chr >>> 6 & 63;
      buffer2[index2++] = 128 | chr & 63;
    }
  }
  return index2 - offset;
}
function toString$1(encoding, start, end) {
  var buffer2 = this;
  var index2 = start | 0;
  if (!end)
    end = buffer2.length;
  var string = "";
  var chr = 0;
  while (index2 < end) {
    chr = buffer2[index2++];
    if (chr < 128) {
      string += String.fromCharCode(chr);
      continue;
    }
    if ((chr & 224) === 192) {
      chr = (chr & 31) << 6 | buffer2[index2++] & 63;
    } else if ((chr & 240) === 224) {
      chr = (chr & 15) << 12 | (buffer2[index2++] & 63) << 6 | buffer2[index2++] & 63;
    } else if ((chr & 248) === 240) {
      chr = (chr & 7) << 18 | (buffer2[index2++] & 63) << 12 | (buffer2[index2++] & 63) << 6 | buffer2[index2++] & 63;
    }
    if (chr >= 65536) {
      chr -= 65536;
      string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
    } else {
      string += String.fromCharCode(chr);
    }
  }
  return string;
}
function copy2(target, targetStart, start, end) {
  var i2;
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (!targetStart)
    targetStart = 0;
  var len = end - start;
  if (target === this && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; i2--) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      target[i2 + targetStart] = this[i2 + start];
    }
  }
  return len;
}
var hasRequiredBufferishProto;
function requireBufferishProto() {
  if (hasRequiredBufferishProto)
    return bufferishProto;
  hasRequiredBufferishProto = 1;
  var BufferLite = bufferLite;
  bufferishProto.copy = copy3;
  bufferishProto.slice = slice2;
  bufferishProto.toString = toString4;
  bufferishProto.write = gen("write");
  var Bufferish2 = requireBufferish();
  var Buffer2 = Bufferish2.global;
  var isBufferShim = Bufferish2.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
  var brokenTypedArray = isBufferShim && !Buffer2.TYPED_ARRAY_SUPPORT;
  function copy3(target, targetStart, start, end) {
    var thisIsBuffer = Bufferish2.isBuffer(this);
    var targetIsBuffer = Bufferish2.isBuffer(target);
    if (thisIsBuffer && targetIsBuffer) {
      return this.copy(target, targetStart, start, end);
    } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish2.isView(this) && Bufferish2.isView(target)) {
      var buffer2 = start || end != null ? slice2.call(this, start, end) : this;
      target.set(buffer2, targetStart);
      return buffer2.length;
    } else {
      return BufferLite.copy.call(this, target, targetStart, start, end);
    }
  }
  function slice2(start, end) {
    var f3 = this.slice || !brokenTypedArray && this.subarray;
    if (f3)
      return f3.call(this, start, end);
    var target = Bufferish2.alloc.call(this, end - start);
    copy3.call(this, target, 0, start, end);
    return target;
  }
  function toString4(encoding, start, end) {
    var f3 = !isBufferShim && Bufferish2.isBuffer(this) ? this.toString : BufferLite.toString;
    return f3.apply(this, arguments);
  }
  function gen(method) {
    return wrap;
    function wrap() {
      var f3 = this[method] || BufferLite[method];
      return f3.apply(this, arguments);
    }
  }
  return bufferishProto;
}
var hasRequiredBufferish;
function requireBufferish() {
  if (hasRequiredBufferish)
    return bufferish;
  hasRequiredBufferish = 1;
  (function(exports) {
    var Buffer2 = exports.global = bufferGlobal;
    var hasBuffer = exports.hasBuffer = Buffer2 && !!Buffer2.isBuffer;
    var hasArrayBuffer = exports.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    var isArray2 = exports.isArray = isarray;
    exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer2 : _false;
    var isBuffer2 = exports.isBuffer = hasBuffer ? Buffer2.isBuffer : _false;
    var isView = exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports.alloc = alloc2;
    exports.concat = concat2;
    exports.from = from2;
    var BufferArray = exports.Array = requireBufferishArray();
    var BufferBuffer = exports.Buffer = requireBufferishBuffer();
    var BufferUint8Array = exports.Uint8Array = requireBufferishUint8array();
    var BufferProto2 = exports.prototype = requireBufferishProto();
    function from2(value) {
      if (typeof value === "string") {
        return fromString2.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc2(size2) {
      return auto(this).alloc(size2);
    }
    function concat2(list, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list, dryrun);
      }
      var ref = this !== exports && this || list[0];
      var result = alloc2.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list, append2);
      return result;
      function dryrun(buffer2) {
        length += buffer2.length;
      }
      function append2(buffer2) {
        offset += BufferProto2.copy.call(buffer2, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer2(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString2(value) {
      var expected = value.length * 3;
      var that = alloc2.call(this, expected);
      var actual = BufferProto2.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto2.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer2(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray2(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  })(bufferish);
  return bufferish;
}
extBuffer.ExtBuffer = ExtBuffer$1;
var Bufferish$5 = requireBufferish();
function ExtBuffer$1(buffer2, type) {
  if (!(this instanceof ExtBuffer$1))
    return new ExtBuffer$1(buffer2, type);
  this.buffer = Bufferish$5.from(buffer2);
  this.type = type;
}
var extPacker = {};
var hasRequiredExtPacker;
function requireExtPacker() {
  if (hasRequiredExtPacker)
    return extPacker;
  hasRequiredExtPacker = 1;
  extPacker.setExtPackers = setExtPackers;
  var Bufferish2 = requireBufferish();
  var Buffer2 = Bufferish2.global;
  var packTypedArray = Bufferish2.Uint8Array.from;
  var _encode;
  var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
  function setExtPackers(codec2) {
    codec2.addExtPacker(14, Error, [packError, encode2]);
    codec2.addExtPacker(1, EvalError, [packError, encode2]);
    codec2.addExtPacker(2, RangeError, [packError, encode2]);
    codec2.addExtPacker(3, ReferenceError, [packError, encode2]);
    codec2.addExtPacker(4, SyntaxError, [packError, encode2]);
    codec2.addExtPacker(5, TypeError, [packError, encode2]);
    codec2.addExtPacker(6, URIError, [packError, encode2]);
    codec2.addExtPacker(10, RegExp, [packRegExp, encode2]);
    codec2.addExtPacker(11, Boolean, [packValueOf, encode2]);
    codec2.addExtPacker(12, String, [packValueOf, encode2]);
    codec2.addExtPacker(13, Date, [Number, encode2]);
    codec2.addExtPacker(15, Number, [packValueOf, encode2]);
    if ("undefined" !== typeof Uint8Array) {
      codec2.addExtPacker(17, Int8Array, packTypedArray);
      codec2.addExtPacker(18, Uint8Array, packTypedArray);
      codec2.addExtPacker(19, Int16Array, packTypedArray);
      codec2.addExtPacker(20, Uint16Array, packTypedArray);
      codec2.addExtPacker(21, Int32Array, packTypedArray);
      codec2.addExtPacker(22, Uint32Array, packTypedArray);
      codec2.addExtPacker(23, Float32Array, packTypedArray);
      if ("undefined" !== typeof Float64Array) {
        codec2.addExtPacker(24, Float64Array, packTypedArray);
      }
      if ("undefined" !== typeof Uint8ClampedArray) {
        codec2.addExtPacker(25, Uint8ClampedArray, packTypedArray);
      }
      codec2.addExtPacker(26, ArrayBuffer, packTypedArray);
      codec2.addExtPacker(29, DataView, packTypedArray);
    }
    if (Bufferish2.hasBuffer) {
      codec2.addExtPacker(27, Buffer2, Bufferish2.from);
    }
  }
  function encode2(input) {
    if (!_encode)
      _encode = requireEncode().encode;
    return _encode(input);
  }
  function packValueOf(value) {
    return value.valueOf();
  }
  function packRegExp(value) {
    value = RegExp.prototype.toString.call(value).split("/");
    value.shift();
    var out = [value.pop()];
    out.unshift(value.join("/"));
    return out;
  }
  function packError(value) {
    var out = {};
    for (var key in ERROR_COLUMNS) {
      out[key] = value[key];
    }
    return out;
  }
  return extPacker;
}
var writeType = {};
var int64Buffer = {};
(function(exports) {
  !function(exports2) {
    var UNDEFINED = "undefined";
    var BUFFER = UNDEFINED !== typeof Buffer$2 && Buffer$2;
    var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
    var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
    var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
    var isArray2 = Array.isArray || _isArray;
    var BIT32 = 4294967296;
    var BIT24 = 16777216;
    var storage;
    factory2("Uint64BE", true, true);
    factory2("Int64BE", true, false);
    factory2("Uint64LE", false, true);
    factory2("Int64LE", false, false);
    function factory2(name2, bigendian, unsigned) {
      var posH = bigendian ? 0 : 4;
      var posL = bigendian ? 4 : 0;
      var pos0 = bigendian ? 0 : 3;
      var pos1 = bigendian ? 1 : 2;
      var pos2 = bigendian ? 2 : 1;
      var pos3 = bigendian ? 3 : 0;
      var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
      var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
      var proto = Int64.prototype;
      var isName = "is" + name2;
      var _isInt64 = "_" + isName;
      proto.buffer = void 0;
      proto.offset = 0;
      proto[_isInt64] = true;
      proto.toNumber = toNumber2;
      proto.toString = toString4;
      proto.toJSON = toNumber2;
      proto.toArray = toArray2;
      if (BUFFER)
        proto.toBuffer = toBuffer;
      if (UINT8ARRAY)
        proto.toArrayBuffer = toArrayBuffer;
      Int64[isName] = isInt64;
      exports2[name2] = Int64;
      return Int64;
      function Int64(buffer2, offset, value, raddix) {
        if (!(this instanceof Int64))
          return new Int64(buffer2, offset, value, raddix);
        return init2(this, buffer2, offset, value, raddix);
      }
      function isInt64(b3) {
        return !!(b3 && b3[_isInt64]);
      }
      function init2(that, buffer2, offset, value, raddix) {
        if (UINT8ARRAY && ARRAYBUFFER) {
          if (buffer2 instanceof ARRAYBUFFER)
            buffer2 = new UINT8ARRAY(buffer2);
          if (value instanceof ARRAYBUFFER)
            value = new UINT8ARRAY(value);
        }
        if (!buffer2 && !offset && !value && !storage) {
          that.buffer = newArray(ZERO, 0);
          return;
        }
        if (!isValidBuffer(buffer2, offset)) {
          var _storage = storage || Array;
          raddix = offset;
          value = buffer2;
          offset = 0;
          buffer2 = new _storage(8);
        }
        that.buffer = buffer2;
        that.offset = offset |= 0;
        if (UNDEFINED === typeof value)
          return;
        if ("string" === typeof value) {
          fromString2(buffer2, offset, value, raddix || 10);
        } else if (isValidBuffer(value, raddix)) {
          fromArray(buffer2, offset, value, raddix);
        } else if ("number" === typeof raddix) {
          writeInt32(buffer2, offset + posH, value);
          writeInt32(buffer2, offset + posL, raddix);
        } else if (value > 0) {
          fromPositive(buffer2, offset, value);
        } else if (value < 0) {
          fromNegative(buffer2, offset, value);
        } else {
          fromArray(buffer2, offset, ZERO, 0);
        }
      }
      function fromString2(buffer2, offset, str2, raddix) {
        var pos = 0;
        var len = str2.length;
        var high = 0;
        var low = 0;
        if (str2[0] === "-")
          pos++;
        var sign2 = pos;
        while (pos < len) {
          var chr = parseInt(str2[pos++], raddix);
          if (!(chr >= 0))
            break;
          low = low * raddix + chr;
          high = high * raddix + Math.floor(low / BIT32);
          low %= BIT32;
        }
        if (sign2) {
          high = ~high;
          if (low) {
            low = BIT32 - low;
          } else {
            high++;
          }
        }
        writeInt32(buffer2, offset + posH, high);
        writeInt32(buffer2, offset + posL, low);
      }
      function toNumber2() {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        if (!unsigned)
          high |= 0;
        return high ? high * BIT32 + low : low;
      }
      function toString4(radix) {
        var buffer2 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer2, offset + posH);
        var low = readInt32(buffer2, offset + posL);
        var str2 = "";
        var sign2 = !unsigned && high & 2147483648;
        if (sign2) {
          high = ~high;
          low = BIT32 - low;
        }
        radix = radix || 10;
        while (1) {
          var mod = high % radix * BIT32 + low;
          high = Math.floor(high / radix);
          low = Math.floor(mod / radix);
          str2 = (mod % radix).toString(radix) + str2;
          if (!high && !low)
            break;
        }
        if (sign2) {
          str2 = "-" + str2;
        }
        return str2;
      }
      function writeInt32(buffer2, offset, value) {
        buffer2[offset + pos3] = value & 255;
        value = value >> 8;
        buffer2[offset + pos2] = value & 255;
        value = value >> 8;
        buffer2[offset + pos1] = value & 255;
        value = value >> 8;
        buffer2[offset + pos0] = value & 255;
      }
      function readInt32(buffer2, offset) {
        return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16) + (buffer2[offset + pos2] << 8) + buffer2[offset + pos3];
      }
    }
    function toArray2(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage = null;
      if (raw !== false && offset === 0 && buffer2.length === 8 && isArray2(buffer2))
        return buffer2;
      return newArray(buffer2, offset);
    }
    function toBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      storage = BUFFER;
      if (raw !== false && offset === 0 && buffer2.length === 8 && Buffer$2.isBuffer(buffer2))
        return buffer2;
      var dest = new BUFFER(8);
      fromArray(dest, 0, buffer2, offset);
      return dest;
    }
    function toArrayBuffer(raw) {
      var buffer2 = this.buffer;
      var offset = this.offset;
      var arrbuf = buffer2.buffer;
      storage = UINT8ARRAY;
      if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
        return arrbuf;
      var dest = new UINT8ARRAY(8);
      fromArray(dest, 0, buffer2, offset);
      return dest.buffer;
    }
    function isValidBuffer(buffer2, offset) {
      var len = buffer2 && buffer2.length;
      offset |= 0;
      return len && offset + 8 <= len && "string" !== typeof buffer2[offset];
    }
    function fromArray(destbuf, destoff, srcbuf, srcoff) {
      destoff |= 0;
      srcoff |= 0;
      for (var i2 = 0; i2 < 8; i2++) {
        destbuf[destoff++] = srcbuf[srcoff++] & 255;
      }
    }
    function newArray(buffer2, offset) {
      return Array.prototype.slice.call(buffer2, offset, offset + 8);
    }
    function fromPositiveBE(buffer2, offset, value) {
      var pos = offset + 8;
      while (pos > offset) {
        buffer2[--pos] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeBE(buffer2, offset, value) {
      var pos = offset + 8;
      value++;
      while (pos > offset) {
        buffer2[--pos] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function fromPositiveLE(buffer2, offset, value) {
      var end = offset + 8;
      while (offset < end) {
        buffer2[offset++] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeLE(buffer2, offset, value) {
      var end = offset + 8;
      value++;
      while (offset < end) {
        buffer2[offset++] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function _isArray(val) {
      return !!val && "[object Array]" == Object.prototype.toString.call(val);
    }
  }(typeof exports.nodeName !== "string" ? exports : commonjsGlobal || {});
})(int64Buffer);
var writeToken = {};
var ieee754$2 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
};
ieee754$2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e3, m2, c3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c3 = Math.pow(2, -e3)) < 1) {
      e3--;
      c3 *= 2;
    }
    if (e3 + eBias >= 1) {
      value += rt / c3;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c3 >= 2) {
      e3++;
      c3 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m2 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m2 = (value * c3 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
};
var writeUint8 = {};
var constant$1 = writeUint8.uint8 = new Array(256);
for (var i$2 = 0; i$2 <= 255; i$2++) {
  constant$1[i$2] = write0(i$2);
}
function write0(type) {
  return function(encoder2) {
    var offset = encoder2.reserve(1);
    encoder2.buffer[offset] = type;
  };
}
var ieee754$1 = ieee754$2;
var Int64Buffer$2 = int64Buffer;
var Uint64BE$2 = Int64Buffer$2.Uint64BE;
var Int64BE$2 = Int64Buffer$2.Int64BE;
var uint8$2 = writeUint8.uint8;
var Bufferish$4 = requireBufferish();
var Buffer$1 = Bufferish$4.global;
var IS_BUFFER_SHIM = Bufferish$4.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer$1;
var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer$1.TYPED_ARRAY_SUPPORT;
var Buffer_prototype = Bufferish$4.hasBuffer && Buffer$1.prototype || {};
writeToken.getWriteToken = getWriteToken;
function getWriteToken(options2) {
  if (options2 && options2.uint8array) {
    return init_uint8array();
  } else if (NO_TYPED_ARRAY || Bufferish$4.hasBuffer && options2 && options2.safe) {
    return init_safe();
  } else {
    return init_token$1();
  }
}
function init_uint8array() {
  var token = init_token$1();
  token[202] = writeN(202, 4, writeFloatBE2);
  token[203] = writeN(203, 8, writeDoubleBE2);
  return token;
}
function init_token$1() {
  var token = uint8$2.slice();
  token[196] = write1(196);
  token[197] = write2(197);
  token[198] = write4(198);
  token[199] = write1(199);
  token[200] = write2(200);
  token[201] = write4(201);
  token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE2, true);
  token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE2, true);
  token[204] = write1(204);
  token[205] = write2(205);
  token[206] = write4(206);
  token[207] = writeN(207, 8, writeUInt64BE);
  token[208] = write1(208);
  token[209] = write2(209);
  token[210] = write4(210);
  token[211] = writeN(211, 8, writeInt64BE);
  token[217] = write1(217);
  token[218] = write2(218);
  token[219] = write4(219);
  token[220] = write2(220);
  token[221] = write4(221);
  token[222] = write2(222);
  token[223] = write4(223);
  return token;
}
function init_safe() {
  var token = uint8$2.slice();
  token[196] = writeN(196, 1, Buffer$1.prototype.writeUInt8);
  token[197] = writeN(197, 2, Buffer$1.prototype.writeUInt16BE);
  token[198] = writeN(198, 4, Buffer$1.prototype.writeUInt32BE);
  token[199] = writeN(199, 1, Buffer$1.prototype.writeUInt8);
  token[200] = writeN(200, 2, Buffer$1.prototype.writeUInt16BE);
  token[201] = writeN(201, 4, Buffer$1.prototype.writeUInt32BE);
  token[202] = writeN(202, 4, Buffer$1.prototype.writeFloatBE);
  token[203] = writeN(203, 8, Buffer$1.prototype.writeDoubleBE);
  token[204] = writeN(204, 1, Buffer$1.prototype.writeUInt8);
  token[205] = writeN(205, 2, Buffer$1.prototype.writeUInt16BE);
  token[206] = writeN(206, 4, Buffer$1.prototype.writeUInt32BE);
  token[207] = writeN(207, 8, writeUInt64BE);
  token[208] = writeN(208, 1, Buffer$1.prototype.writeInt8);
  token[209] = writeN(209, 2, Buffer$1.prototype.writeInt16BE);
  token[210] = writeN(210, 4, Buffer$1.prototype.writeInt32BE);
  token[211] = writeN(211, 8, writeInt64BE);
  token[217] = writeN(217, 1, Buffer$1.prototype.writeUInt8);
  token[218] = writeN(218, 2, Buffer$1.prototype.writeUInt16BE);
  token[219] = writeN(219, 4, Buffer$1.prototype.writeUInt32BE);
  token[220] = writeN(220, 2, Buffer$1.prototype.writeUInt16BE);
  token[221] = writeN(221, 4, Buffer$1.prototype.writeUInt32BE);
  token[222] = writeN(222, 2, Buffer$1.prototype.writeUInt16BE);
  token[223] = writeN(223, 4, Buffer$1.prototype.writeUInt32BE);
  return token;
}
function write1(type) {
  return function(encoder2, value) {
    var offset = encoder2.reserve(2);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset] = value;
  };
}
function write2(type) {
  return function(encoder2, value) {
    var offset = encoder2.reserve(3);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset++] = value >>> 8;
    buffer2[offset] = value;
  };
}
function write4(type) {
  return function(encoder2, value) {
    var offset = encoder2.reserve(5);
    var buffer2 = encoder2.buffer;
    buffer2[offset++] = type;
    buffer2[offset++] = value >>> 24;
    buffer2[offset++] = value >>> 16;
    buffer2[offset++] = value >>> 8;
    buffer2[offset] = value;
  };
}
function writeN(type, len, method, noAssert) {
  return function(encoder2, value) {
    var offset = encoder2.reserve(len + 1);
    encoder2.buffer[offset++] = type;
    method.call(encoder2.buffer, value, offset, noAssert);
  };
}
function writeUInt64BE(value, offset) {
  new Uint64BE$2(this, offset, value);
}
function writeInt64BE(value, offset) {
  new Int64BE$2(this, offset, value);
}
function writeFloatBE2(value, offset) {
  ieee754$1.write(this, value, offset, false, 23, 4);
}
function writeDoubleBE2(value, offset) {
  ieee754$1.write(this, value, offset, false, 52, 8);
}
var IS_ARRAY$1 = isarray;
var Int64Buffer$1 = int64Buffer;
var Uint64BE$1 = Int64Buffer$1.Uint64BE;
var Int64BE$1 = Int64Buffer$1.Int64BE;
var Bufferish$3 = requireBufferish();
var BufferProto$1 = requireBufferishProto();
var WriteToken = writeToken;
var uint8$1 = writeUint8.uint8;
var ExtBuffer = extBuffer.ExtBuffer;
var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
var HAS_MAP$1 = "undefined" !== typeof Map;
var extmap = [];
extmap[1] = 212;
extmap[2] = 213;
extmap[4] = 214;
extmap[8] = 215;
extmap[16] = 216;
writeType.getWriteType = getWriteType;
function getWriteType(options2) {
  var token = WriteToken.getWriteToken(options2);
  var useraw = options2 && options2.useraw;
  var binarraybuffer = HAS_UINT8ARRAY && options2 && options2.binarraybuffer;
  var isBuffer2 = binarraybuffer ? Bufferish$3.isArrayBuffer : Bufferish$3.isBuffer;
  var bin = binarraybuffer ? bin_arraybuffer2 : bin_buffer2;
  var usemap = HAS_MAP$1 && options2 && options2.usemap;
  var map2 = usemap ? map_to_map2 : obj_to_map;
  var writeType2 = {
    "boolean": bool,
    "function": nil,
    "number": number,
    "object": useraw ? object_raw : object,
    "string": _string(useraw ? raw_head_size : str_head_size),
    "symbol": nil,
    "undefined": nil
  };
  return writeType2;
  function bool(encoder2, value) {
    var type = value ? 195 : 194;
    token[type](encoder2, value);
  }
  function number(encoder2, value) {
    var ivalue = value | 0;
    var type;
    if (value !== ivalue) {
      type = 203;
      token[type](encoder2, value);
      return;
    } else if (-32 <= ivalue && ivalue <= 127) {
      type = ivalue & 255;
    } else if (0 <= ivalue) {
      type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
    } else {
      type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
    }
    token[type](encoder2, ivalue);
  }
  function uint64(encoder2, value) {
    var type = 207;
    token[type](encoder2, value.toArray());
  }
  function int64(encoder2, value) {
    var type = 211;
    token[type](encoder2, value.toArray());
  }
  function str_head_size(length) {
    return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
  }
  function raw_head_size(length) {
    return length < 32 ? 1 : length <= 65535 ? 3 : 5;
  }
  function _string(head_size) {
    return string;
    function string(encoder2, value) {
      var length = value.length;
      var maxsize = 5 + length * 3;
      encoder2.offset = encoder2.reserve(maxsize);
      var buffer2 = encoder2.buffer;
      var expected = head_size(length);
      var start = encoder2.offset + expected;
      length = BufferProto$1.write.call(buffer2, value, start);
      var actual = head_size(length);
      if (expected !== actual) {
        var targetStart = start + actual - expected;
        var end = start + length;
        BufferProto$1.copy.call(buffer2, buffer2, targetStart, start, end);
      }
      var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
      token[type](encoder2, length);
      encoder2.offset += length;
    }
  }
  function object(encoder2, value) {
    if (value === null)
      return nil(encoder2, value);
    if (isBuffer2(value))
      return bin(encoder2, value);
    if (IS_ARRAY$1(value))
      return array2(encoder2, value);
    if (Uint64BE$1.isUint64BE(value))
      return uint64(encoder2, value);
    if (Int64BE$1.isInt64BE(value))
      return int64(encoder2, value);
    var packer = encoder2.codec.getExtPacker(value);
    if (packer)
      value = packer(value);
    if (value instanceof ExtBuffer)
      return ext2(encoder2, value);
    map2(encoder2, value);
  }
  function object_raw(encoder2, value) {
    if (isBuffer2(value))
      return raw(encoder2, value);
    object(encoder2, value);
  }
  function nil(encoder2, value) {
    var type = 192;
    token[type](encoder2, value);
  }
  function array2(encoder2, value) {
    var length = value.length;
    var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
    token[type](encoder2, length);
    var encode2 = encoder2.codec.encode;
    for (var i2 = 0; i2 < length; i2++) {
      encode2(encoder2, value[i2]);
    }
  }
  function bin_buffer2(encoder2, value) {
    var length = value.length;
    var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
    token[type](encoder2, length);
    encoder2.send(value);
  }
  function bin_arraybuffer2(encoder2, value) {
    bin_buffer2(encoder2, new Uint8Array(value));
  }
  function ext2(encoder2, value) {
    var buffer2 = value.buffer;
    var length = buffer2.length;
    var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
    token[type](encoder2, length);
    uint8$1[value.type](encoder2);
    encoder2.send(buffer2);
  }
  function obj_to_map(encoder2, value) {
    var keys2 = Object.keys(value);
    var length = keys2.length;
    var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
    token[type](encoder2, length);
    var encode2 = encoder2.codec.encode;
    keys2.forEach(function(key) {
      encode2(encoder2, key);
      encode2(encoder2, value[key]);
    });
  }
  function map_to_map2(encoder2, value) {
    if (!(value instanceof Map))
      return obj_to_map(encoder2, value);
    var length = value.size;
    var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
    token[type](encoder2, length);
    var encode2 = encoder2.codec.encode;
    value.forEach(function(val, key, m2) {
      encode2(encoder2, key);
      encode2(encoder2, val);
    });
  }
  function raw(encoder2, value) {
    var length = value.length;
    var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
    token[type](encoder2, length);
    encoder2.send(value);
  }
}
var codecBase = {};
var IS_ARRAY = isarray;
codecBase.createCodec = createCodec;
codecBase.install = install;
codecBase.filter = filter2;
var Bufferish$2 = requireBufferish();
function Codec(options2) {
  if (!(this instanceof Codec))
    return new Codec(options2);
  this.options = options2;
  this.init();
}
Codec.prototype.init = function() {
  var options2 = this.options;
  if (options2 && options2.uint8array) {
    this.bufferish = Bufferish$2.Uint8Array;
  }
  return this;
};
function install(props) {
  for (var key in props) {
    Codec.prototype[key] = add$1(Codec.prototype[key], props[key]);
  }
}
function add$1(a8, b3) {
  return a8 && b3 ? ab : a8 || b3;
  function ab() {
    a8.apply(this, arguments);
    return b3.apply(this, arguments);
  }
}
function join(filters2) {
  filters2 = filters2.slice();
  return function(value) {
    return filters2.reduce(iterator2, value);
  };
  function iterator2(value, filter3) {
    return filter3(value);
  }
}
function filter2(filter3) {
  return IS_ARRAY(filter3) ? join(filter3) : filter3;
}
function createCodec(options2) {
  return new Codec(options2);
}
codecBase.preset = createCodec({ preset: true });
var hasRequiredWriteCore;
function requireWriteCore() {
  if (hasRequiredWriteCore)
    return writeCore;
  hasRequiredWriteCore = 1;
  var ExtBuffer2 = extBuffer.ExtBuffer;
  var ExtPacker = requireExtPacker();
  var WriteType = writeType;
  var CodecBase = codecBase;
  CodecBase.install({
    addExtPacker,
    getExtPacker,
    init: init2
  });
  writeCore.preset = init2.call(CodecBase.preset);
  function getEncoder(options2) {
    var writeType2 = WriteType.getWriteType(options2);
    return encode2;
    function encode2(encoder2, value) {
      var func = writeType2[typeof value];
      if (!func)
        throw new Error('Unsupported type "' + typeof value + '": ' + value);
      func(encoder2, value);
    }
  }
  function init2() {
    var options2 = this.options;
    this.encode = getEncoder(options2);
    if (options2 && options2.preset) {
      ExtPacker.setExtPackers(this);
    }
    return this;
  }
  function addExtPacker(etype, Class2, packer) {
    packer = CodecBase.filter(packer);
    var name2 = Class2.name;
    if (name2 && name2 !== "Object") {
      var packers = this.extPackers || (this.extPackers = {});
      packers[name2] = extPacker2;
    } else {
      var list = this.extEncoderList || (this.extEncoderList = []);
      list.unshift([Class2, extPacker2]);
    }
    function extPacker2(value) {
      if (packer)
        value = packer(value);
      return new ExtBuffer2(value, etype);
    }
  }
  function getExtPacker(value) {
    var packers = this.extPackers || (this.extPackers = {});
    var c3 = value.constructor;
    var e3 = c3 && c3.name && packers[c3.name];
    if (e3)
      return e3;
    var list = this.extEncoderList || (this.extEncoderList = []);
    var len = list.length;
    for (var i2 = 0; i2 < len; i2++) {
      var pair = list[i2];
      if (c3 === pair[0])
        return pair[1];
    }
  }
  return writeCore;
}
var flexBuffer = {};
flexBuffer.FlexDecoder = FlexDecoder;
flexBuffer.FlexEncoder = FlexEncoder;
var Bufferish$1 = requireBufferish();
var MIN_BUFFER_SIZE = 2048;
var MAX_BUFFER_SIZE = 65536;
var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
function FlexDecoder() {
  if (!(this instanceof FlexDecoder))
    return new FlexDecoder();
}
function FlexEncoder() {
  if (!(this instanceof FlexEncoder))
    return new FlexEncoder();
}
FlexDecoder.mixin = mixinFactory(getDecoderMethods());
FlexDecoder.mixin(FlexDecoder.prototype);
FlexEncoder.mixin = mixinFactory(getEncoderMethods());
FlexEncoder.mixin(FlexEncoder.prototype);
function getDecoderMethods() {
  return {
    bufferish: Bufferish$1,
    write: write5,
    fetch: fetch$1,
    flush,
    push,
    pull,
    read: read$1,
    reserve,
    offset: 0
  };
  function write5(chunk) {
    var prev = this.offset ? Bufferish$1.prototype.slice.call(this.buffer, this.offset) : this.buffer;
    this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
    this.offset = 0;
  }
  function flush() {
    while (this.offset < this.buffer.length) {
      var start = this.offset;
      var value;
      try {
        value = this.fetch();
      } catch (e3) {
        if (e3 && e3.message != BUFFER_SHORTAGE)
          throw e3;
        this.offset = start;
        break;
      }
      this.push(value);
    }
  }
  function reserve(length) {
    var start = this.offset;
    var end = start + length;
    if (end > this.buffer.length)
      throw new Error(BUFFER_SHORTAGE);
    this.offset = end;
    return start;
  }
}
function getEncoderMethods() {
  return {
    bufferish: Bufferish$1,
    write: write3,
    fetch: fetch2,
    flush,
    push,
    pull: pull2,
    read: read$1,
    reserve,
    send,
    maxBufferSize: MAX_BUFFER_SIZE,
    minBufferSize: MIN_BUFFER_SIZE,
    offset: 0,
    start: 0
  };
  function fetch2() {
    var start = this.start;
    if (start < this.offset) {
      var end = this.start = this.offset;
      return Bufferish$1.prototype.slice.call(this.buffer, start, end);
    }
  }
  function flush() {
    while (this.start < this.offset) {
      var value = this.fetch();
      if (value)
        this.push(value);
    }
  }
  function pull2() {
    var buffers = this.buffers || (this.buffers = []);
    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
    buffers.length = 0;
    return chunk;
  }
  function reserve(length) {
    var req = length | 0;
    if (this.buffer) {
      var size2 = this.buffer.length;
      var start = this.offset | 0;
      var end = start + req;
      if (end < size2) {
        this.offset = end;
        return start;
      }
      this.flush();
      length = Math.max(length, Math.min(size2 * 2, this.maxBufferSize));
    }
    length = Math.max(length, this.minBufferSize);
    this.buffer = this.bufferish.alloc(length);
    this.start = 0;
    this.offset = req;
    return 0;
  }
  function send(buffer2) {
    var length = buffer2.length;
    if (length > this.minBufferSize) {
      this.flush();
      this.push(buffer2);
    } else {
      var offset = this.reserve(length);
      Bufferish$1.prototype.copy.call(buffer2, this.buffer, offset);
    }
  }
}
function write3() {
  throw new Error("method not implemented: write()");
}
function fetch$1() {
  throw new Error("method not implemented: fetch()");
}
function read$1() {
  var length = this.buffers && this.buffers.length;
  if (!length)
    return this.fetch();
  this.flush();
  return this.pull();
}
function push(chunk) {
  var buffers = this.buffers || (this.buffers = []);
  buffers.push(chunk);
}
function pull() {
  var buffers = this.buffers || (this.buffers = []);
  return buffers.shift();
}
function mixinFactory(source) {
  return mixin;
  function mixin(target) {
    for (var key in source) {
      target[key] = source[key];
    }
    return target;
  }
}
var hasRequiredEncodeBuffer;
function requireEncodeBuffer() {
  if (hasRequiredEncodeBuffer)
    return encodeBuffer;
  hasRequiredEncodeBuffer = 1;
  encodeBuffer.EncodeBuffer = EncodeBuffer2;
  var preset = requireWriteCore().preset;
  var FlexEncoder2 = flexBuffer.FlexEncoder;
  FlexEncoder2.mixin(EncodeBuffer2.prototype);
  function EncodeBuffer2(options2) {
    if (!(this instanceof EncodeBuffer2))
      return new EncodeBuffer2(options2);
    if (options2) {
      this.options = options2;
      if (options2.codec) {
        var codec2 = this.codec = options2.codec;
        if (codec2.bufferish)
          this.bufferish = codec2.bufferish;
      }
    }
  }
  EncodeBuffer2.prototype.codec = preset;
  EncodeBuffer2.prototype.write = function(input) {
    this.codec.encode(this, input);
  };
  return encodeBuffer;
}
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode)
    return encode$1;
  hasRequiredEncode = 1;
  encode$1.encode = encode2;
  var EncodeBuffer2 = requireEncodeBuffer().EncodeBuffer;
  function encode2(input, options2) {
    var encoder2 = new EncodeBuffer2(options2);
    encoder2.write(input);
    return encoder2.read();
  }
  return encode$1;
}
var decode = {};
var decodeBuffer = {};
var readCore = {};
var extUnpacker = {};
var hasRequiredExtUnpacker;
function requireExtUnpacker() {
  if (hasRequiredExtUnpacker)
    return extUnpacker;
  hasRequiredExtUnpacker = 1;
  extUnpacker.setExtUnpackers = setExtUnpackers;
  var Bufferish2 = requireBufferish();
  var Buffer2 = Bufferish2.global;
  var _decode;
  var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
  function setExtUnpackers(codec2) {
    codec2.addExtUnpacker(14, [decode2, unpackError(Error)]);
    codec2.addExtUnpacker(1, [decode2, unpackError(EvalError)]);
    codec2.addExtUnpacker(2, [decode2, unpackError(RangeError)]);
    codec2.addExtUnpacker(3, [decode2, unpackError(ReferenceError)]);
    codec2.addExtUnpacker(4, [decode2, unpackError(SyntaxError)]);
    codec2.addExtUnpacker(5, [decode2, unpackError(TypeError)]);
    codec2.addExtUnpacker(6, [decode2, unpackError(URIError)]);
    codec2.addExtUnpacker(10, [decode2, unpackRegExp]);
    codec2.addExtUnpacker(11, [decode2, unpackClass(Boolean)]);
    codec2.addExtUnpacker(12, [decode2, unpackClass(String)]);
    codec2.addExtUnpacker(13, [decode2, unpackClass(Date)]);
    codec2.addExtUnpacker(15, [decode2, unpackClass(Number)]);
    if ("undefined" !== typeof Uint8Array) {
      codec2.addExtUnpacker(17, unpackClass(Int8Array));
      codec2.addExtUnpacker(18, unpackClass(Uint8Array));
      codec2.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
      codec2.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
      codec2.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
      codec2.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
      codec2.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
      if ("undefined" !== typeof Float64Array) {
        codec2.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
      }
      if ("undefined" !== typeof Uint8ClampedArray) {
        codec2.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
      }
      codec2.addExtUnpacker(26, unpackArrayBuffer);
      codec2.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
    }
    if (Bufferish2.hasBuffer) {
      codec2.addExtUnpacker(27, unpackClass(Buffer2));
    }
  }
  function decode2(input) {
    if (!_decode)
      _decode = requireDecode().decode;
    return _decode(input);
  }
  function unpackRegExp(value) {
    return RegExp.apply(null, value);
  }
  function unpackError(Class2) {
    return function(value) {
      var out = new Class2();
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    };
  }
  function unpackClass(Class2) {
    return function(value) {
      return new Class2(value);
    };
  }
  function unpackArrayBuffer(value) {
    return new Uint8Array(value).buffer;
  }
  return extUnpacker;
}
var readFormat = {};
var ieee754 = ieee754$2;
var Int64Buffer = int64Buffer;
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;
readFormat.getReadFormat = getReadFormat;
readFormat.readUint8 = uint8;
var Bufferish = requireBufferish();
var BufferProto = requireBufferishProto();
var HAS_MAP = "undefined" !== typeof Map;
var NO_ASSERT = true;
function getReadFormat(options2) {
  var binarraybuffer = Bufferish.hasArrayBuffer && options2 && options2.binarraybuffer;
  var int64 = options2 && options2.int64;
  var usemap = HAS_MAP && options2 && options2.usemap;
  var readFormat2 = {
    map: usemap ? map_to_map : map_to_obj,
    array,
    str,
    bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
    ext: ext$1,
    uint8,
    uint16,
    uint32,
    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
    int8,
    int16,
    int32,
    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
    float32: read(4, readFloatBE2),
    float64: read(8, readDoubleBE2)
  };
  return readFormat2;
}
function map_to_obj(decoder2, len) {
  var value = {};
  var i2;
  var k4 = new Array(len);
  var v2 = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (i2 = 0; i2 < len; i2++) {
    k4[i2] = decode2(decoder2);
    v2[i2] = decode2(decoder2);
  }
  for (i2 = 0; i2 < len; i2++) {
    value[k4[i2]] = v2[i2];
  }
  return value;
}
function map_to_map(decoder2, len) {
  var value = /* @__PURE__ */ new Map();
  var i2;
  var k4 = new Array(len);
  var v2 = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (i2 = 0; i2 < len; i2++) {
    k4[i2] = decode2(decoder2);
    v2[i2] = decode2(decoder2);
  }
  for (i2 = 0; i2 < len; i2++) {
    value.set(k4[i2], v2[i2]);
  }
  return value;
}
function array(decoder2, len) {
  var value = new Array(len);
  var decode2 = decoder2.codec.decode;
  for (var i2 = 0; i2 < len; i2++) {
    value[i2] = decode2(decoder2);
  }
  return value;
}
function str(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  return BufferProto.toString.call(decoder2.buffer, "utf-8", start, end);
}
function bin_buffer(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return Bufferish.from(buf);
}
function bin_arraybuffer(decoder2, len) {
  var start = decoder2.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return Bufferish.Uint8Array.from(buf).buffer;
}
function ext$1(decoder2, len) {
  var start = decoder2.reserve(len + 1);
  var type = decoder2.buffer[start++];
  var end = start + len;
  var unpack = decoder2.codec.getExtUnpacker(type);
  if (!unpack)
    throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
  var buf = BufferProto.slice.call(decoder2.buffer, start, end);
  return unpack(buf);
}
function uint8(decoder2) {
  var start = decoder2.reserve(1);
  return decoder2.buffer[start];
}
function int8(decoder2) {
  var start = decoder2.reserve(1);
  var value = decoder2.buffer[start];
  return value & 128 ? value - 256 : value;
}
function uint16(decoder2) {
  var start = decoder2.reserve(2);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] << 8 | buffer2[start];
}
function int16(decoder2) {
  var start = decoder2.reserve(2);
  var buffer2 = decoder2.buffer;
  var value = buffer2[start++] << 8 | buffer2[start];
  return value & 32768 ? value - 65536 : value;
}
function uint32(decoder2) {
  var start = decoder2.reserve(4);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] * 16777216 + (buffer2[start++] << 16) + (buffer2[start++] << 8) + buffer2[start];
}
function int32(decoder2) {
  var start = decoder2.reserve(4);
  var buffer2 = decoder2.buffer;
  return buffer2[start++] << 24 | buffer2[start++] << 16 | buffer2[start++] << 8 | buffer2[start];
}
function read(len, method) {
  return function(decoder2) {
    var start = decoder2.reserve(len);
    return method.call(decoder2.buffer, start, NO_ASSERT);
  };
}
function readUInt64BE(start) {
  return new Uint64BE(this, start).toNumber();
}
function readInt64BE(start) {
  return new Int64BE(this, start).toNumber();
}
function readUInt64BE_int64(start) {
  return new Uint64BE(this, start);
}
function readInt64BE_int64(start) {
  return new Int64BE(this, start);
}
function readFloatBE2(start) {
  return ieee754.read(this, start, false, 23, 4);
}
function readDoubleBE2(start) {
  return ieee754.read(this, start, false, 52, 8);
}
var readToken = {};
var ReadFormat = readFormat;
readToken.getReadToken = getReadToken;
function getReadToken(options2) {
  var format2 = ReadFormat.getReadFormat(options2);
  if (options2 && options2.useraw) {
    return init_useraw(format2);
  } else {
    return init_token(format2);
  }
}
function init_token(format2) {
  var i2;
  var token = new Array(256);
  for (i2 = 0; i2 <= 127; i2++) {
    token[i2] = constant(i2);
  }
  for (i2 = 128; i2 <= 143; i2++) {
    token[i2] = fix(i2 - 128, format2.map);
  }
  for (i2 = 144; i2 <= 159; i2++) {
    token[i2] = fix(i2 - 144, format2.array);
  }
  for (i2 = 160; i2 <= 191; i2++) {
    token[i2] = fix(i2 - 160, format2.str);
  }
  token[192] = constant(null);
  token[193] = null;
  token[194] = constant(false);
  token[195] = constant(true);
  token[196] = flex(format2.uint8, format2.bin);
  token[197] = flex(format2.uint16, format2.bin);
  token[198] = flex(format2.uint32, format2.bin);
  token[199] = flex(format2.uint8, format2.ext);
  token[200] = flex(format2.uint16, format2.ext);
  token[201] = flex(format2.uint32, format2.ext);
  token[202] = format2.float32;
  token[203] = format2.float64;
  token[204] = format2.uint8;
  token[205] = format2.uint16;
  token[206] = format2.uint32;
  token[207] = format2.uint64;
  token[208] = format2.int8;
  token[209] = format2.int16;
  token[210] = format2.int32;
  token[211] = format2.int64;
  token[212] = fix(1, format2.ext);
  token[213] = fix(2, format2.ext);
  token[214] = fix(4, format2.ext);
  token[215] = fix(8, format2.ext);
  token[216] = fix(16, format2.ext);
  token[217] = flex(format2.uint8, format2.str);
  token[218] = flex(format2.uint16, format2.str);
  token[219] = flex(format2.uint32, format2.str);
  token[220] = flex(format2.uint16, format2.array);
  token[221] = flex(format2.uint32, format2.array);
  token[222] = flex(format2.uint16, format2.map);
  token[223] = flex(format2.uint32, format2.map);
  for (i2 = 224; i2 <= 255; i2++) {
    token[i2] = constant(i2 - 256);
  }
  return token;
}
function init_useraw(format2) {
  var i2;
  var token = init_token(format2).slice();
  token[217] = token[196];
  token[218] = token[197];
  token[219] = token[198];
  for (i2 = 160; i2 <= 191; i2++) {
    token[i2] = fix(i2 - 160, format2.bin);
  }
  return token;
}
function constant(value) {
  return function() {
    return value;
  };
}
function flex(lenFunc, decodeFunc) {
  return function(decoder2) {
    var len = lenFunc(decoder2);
    return decodeFunc(decoder2, len);
  };
}
function fix(len, method) {
  return function(decoder2) {
    return method(decoder2, len);
  };
}
var hasRequiredReadCore;
function requireReadCore() {
  if (hasRequiredReadCore)
    return readCore;
  hasRequiredReadCore = 1;
  var ExtBuffer2 = extBuffer.ExtBuffer;
  var ExtUnpacker = requireExtUnpacker();
  var readUint8 = readFormat.readUint8;
  var ReadToken = readToken;
  var CodecBase = codecBase;
  CodecBase.install({
    addExtUnpacker,
    getExtUnpacker,
    init: init2
  });
  readCore.preset = init2.call(CodecBase.preset);
  function getDecoder(options2) {
    var readToken2 = ReadToken.getReadToken(options2);
    return decode2;
    function decode2(decoder2) {
      var type = readUint8(decoder2);
      var func = readToken2[type];
      if (!func)
        throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
      return func(decoder2);
    }
  }
  function init2() {
    var options2 = this.options;
    this.decode = getDecoder(options2);
    if (options2 && options2.preset) {
      ExtUnpacker.setExtUnpackers(this);
    }
    return this;
  }
  function addExtUnpacker(etype, unpacker) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    unpackers[etype] = CodecBase.filter(unpacker);
  }
  function getExtUnpacker(type) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    return unpackers[type] || extUnpacker2;
    function extUnpacker2(buffer2) {
      return new ExtBuffer2(buffer2, type);
    }
  }
  return readCore;
}
var hasRequiredDecodeBuffer;
function requireDecodeBuffer() {
  if (hasRequiredDecodeBuffer)
    return decodeBuffer;
  hasRequiredDecodeBuffer = 1;
  decodeBuffer.DecodeBuffer = DecodeBuffer2;
  var preset = requireReadCore().preset;
  var FlexDecoder2 = flexBuffer.FlexDecoder;
  FlexDecoder2.mixin(DecodeBuffer2.prototype);
  function DecodeBuffer2(options2) {
    if (!(this instanceof DecodeBuffer2))
      return new DecodeBuffer2(options2);
    if (options2) {
      this.options = options2;
      if (options2.codec) {
        var codec2 = this.codec = options2.codec;
        if (codec2.bufferish)
          this.bufferish = codec2.bufferish;
      }
    }
  }
  DecodeBuffer2.prototype.codec = preset;
  DecodeBuffer2.prototype.fetch = function() {
    return this.codec.decode(this);
  };
  return decodeBuffer;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode)
    return decode;
  hasRequiredDecode = 1;
  decode.decode = decode$1;
  var DecodeBuffer2 = requireDecodeBuffer().DecodeBuffer;
  function decode$1(input, options2) {
    var decoder2 = new DecodeBuffer2(options2);
    decoder2.write(input);
    return decoder2.read();
  }
  return decode;
}
var encoder = {};
var eventLite = { exports: {} };
/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
(function(module) {
  function EventLite2() {
    if (!(this instanceof EventLite2))
      return new EventLite2();
  }
  (function(EventLite3) {
    module.exports = EventLite3;
    var LISTENERS = "listeners";
    var methods = {
      on: on2,
      once: once3,
      off: off2,
      emit: emit3
    };
    mixin(EventLite3.prototype);
    EventLite3.mixin = mixin;
    function mixin(target) {
      for (var key in methods) {
        target[key] = methods[key];
      }
      return target;
    }
    function on2(type, func) {
      getListeners(this, type).push(func);
      return this;
    }
    function once3(type, func) {
      var that = this;
      wrap.originalListener = func;
      getListeners(that, type).push(wrap);
      return that;
      function wrap() {
        off2.call(that, type, wrap);
        func.apply(this, arguments);
      }
    }
    function off2(type, func) {
      var that = this;
      var listners;
      if (!arguments.length) {
        delete that[LISTENERS];
      } else if (!func) {
        listners = that[LISTENERS];
        if (listners) {
          delete listners[type];
          if (!Object.keys(listners).length)
            return off2.call(that);
        }
      } else {
        listners = getListeners(that, type, true);
        if (listners) {
          listners = listners.filter(ne);
          if (!listners.length)
            return off2.call(that, type);
          that[LISTENERS][type] = listners;
        }
      }
      return that;
      function ne(test) {
        return test !== func && test.originalListener !== func;
      }
    }
    function emit3(type, value) {
      var that = this;
      var listeners2 = getListeners(that, type, true);
      if (!listeners2)
        return false;
      var arglen = arguments.length;
      if (arglen === 1) {
        listeners2.forEach(zeroarg);
      } else if (arglen === 2) {
        listeners2.forEach(onearg);
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        listeners2.forEach(moreargs);
      }
      return !!listeners2.length;
      function zeroarg(func) {
        func.call(that);
      }
      function onearg(func) {
        func.call(that, value);
      }
      function moreargs(func) {
        func.apply(that, args);
      }
    }
    function getListeners(that, type, readonly2) {
      if (readonly2 && !that[LISTENERS])
        return;
      var listeners2 = that[LISTENERS] || (that[LISTENERS] = {});
      return listeners2[type] || (listeners2[type] = []);
    }
  })(EventLite2);
})(eventLite);
var eventLiteExports = eventLite.exports;
encoder.Encoder = Encoder;
var EventLite$1 = eventLiteExports;
var EncodeBuffer = requireEncodeBuffer().EncodeBuffer;
function Encoder(options2) {
  if (!(this instanceof Encoder))
    return new Encoder(options2);
  EncodeBuffer.call(this, options2);
}
Encoder.prototype = new EncodeBuffer();
EventLite$1.mixin(Encoder.prototype);
Encoder.prototype.encode = function(chunk) {
  this.write(chunk);
  this.emit("data", this.read());
};
Encoder.prototype.end = function(chunk) {
  if (arguments.length)
    this.encode(chunk);
  this.flush();
  this.emit("end");
};
var decoder = {};
decoder.Decoder = Decoder;
var EventLite = eventLiteExports;
var DecodeBuffer = requireDecodeBuffer().DecodeBuffer;
function Decoder(options2) {
  if (!(this instanceof Decoder))
    return new Decoder(options2);
  DecodeBuffer.call(this, options2);
}
Decoder.prototype = new DecodeBuffer();
EventLite.mixin(Decoder.prototype);
Decoder.prototype.decode = function(chunk) {
  if (arguments.length)
    this.write(chunk);
  this.flush();
};
Decoder.prototype.push = function(chunk) {
  this.emit("data", chunk);
};
Decoder.prototype.end = function(chunk) {
  this.decode(chunk);
  this.emit("end");
};
var ext = {};
requireReadCore();
requireWriteCore();
ext.createCodec = codecBase.createCodec;
var codec = {};
requireReadCore();
requireWriteCore();
codec.codec = {
  preset: codecBase.preset
};
browser.encode = requireEncode().encode;
browser.decode = requireDecode().decode;
browser.Encoder = encoder.Encoder;
browser.Decoder = decoder.Decoder;
browser.createCodec = ext.createCodec;
browser.codec = codec.codec;
class Packet {
  constructor(data, roomId) {
    this.data = data;
    this.roomId = roomId;
  }
  get body() {
    return this.data;
  }
  message(otherData) {
    return [this.roomId, Date.now(), otherData ?? this.data];
  }
  clone(data) {
    return new Packet(data, this.roomId);
  }
  encode(otherData) {
    return browser.encode(this.message(otherData));
  }
}
const { get: get$4, set: set$3 } = Utils;
class TransmitterClass {
  constructor() {
    this.encode = true;
    this.packets = {};
  }
  addPacket(room2, obj) {
    const { id } = room2;
    if (!id)
      return;
    if (!this.packets[id])
      this.packets[id] = [];
    this.packets[id].push(new Packet(obj, id));
  }
  forEach(cb) {
    for (let roomId in this.packets) {
      cb(this.packets[roomId], roomId);
    }
  }
  getPackets(room2) {
    if (!room2.id)
      return;
    return this.packets[room2.id];
  }
  clear(room2) {
    if (room2 && room2.id) {
      this.packets[room2.id] = [];
    } else {
      this.packets = {};
    }
  }
  error(user, error2) {
    const err = error2 instanceof Error ? error2.toObject ? error2.toObject() : error2.message : error2;
    user._socket.emit("error", err);
  }
  async emit(user, packet, room2) {
    let data = packet.body;
    if (room2.$additionalEmitProperties) {
      let additionalData = await Utils.resolveValue(room2.$additionalEmitProperties(user, packet.body));
      if (additionalData !== void 0) {
        if (typeof additionalData === "string") {
          additionalData = [additionalData];
        }
        if (Array.isArray(additionalData)) {
          const newData = structuredClone(data);
          for (let path2 of additionalData) {
            set$3(newData, path2, get$4(room2, path2));
          }
          data = newData;
        } else {
          data = { ...data, ...additionalData };
        }
      }
    }
    user._socket.emit("w", this.encode ? packet.encode(data) : packet.message(data));
  }
}
const Transmitter = new TransmitterClass();
var UserState;
(function(UserState2) {
  UserState2["Connected"] = "C";
  UserState2["Disconnected"] = "D";
})(UserState || (UserState = {}));
let User$1 = class User {
  constructor() {
    this.$state = UserState.Connected;
    this._secretSessionId = "";
    this._rooms = [];
  }
};
User$1.schema = {
  $state: String
};
class CustomError extends Error {
  constructor(customMessage) {
    super(customMessage);
    this.customMessage = customMessage;
    this.status = 500;
    this.code = "INTERNAL_SERVER_ERROR";
    this.message = "Internal Server error";
  }
  toObject() {
    return {
      message: this.customMessage || this.message,
      status: this.status,
      code: this.code
    };
  }
}
class NotAuthorized extends CustomError {
  constructor(customMessage) {
    super(customMessage);
    this.status = 401;
    this.code = "NOT_AUTHORIZED";
    this.message = "Not authorized";
  }
}
const { set: set$2, get: get$3 } = Utils;
class Room {
  static hasExtraProp(obj) {
    return obj.$default !== void 0 || obj.$syncWithClient !== void 0 || obj.$permanent !== void 0 || obj.$validate !== void 0 || obj.$effects !== void 0 || obj.$type !== void 0;
  }
  static compileSchema(schema, room2) {
    const dict = {};
    const masks = {};
    const permanentObject = [];
    function specialObject(val, p2) {
      if (Room.hasExtraProp(val)) {
        if (val.$permanent ?? true)
          permanentObject.push(p2);
        if (room2 && val.$default !== void 0)
          ;
        if (val.$syncWithClient === false) {
          return;
        }
        dict[p2] = {
          ...val
        };
      } else {
        dict[p2] = val;
        masks[p2] = Utils.propertiesToArray(val);
        compile2(val, p2);
      }
    }
    function compile2(schema2, path2 = "") {
      for (let prop in schema2) {
        const val = schema2[prop];
        let p2 = (path2 ? path2 + "." : "") + prop;
        if (Array.isArray(val)) {
          dict[p2] = GENERIC_KEY_SCHEMA;
          p2 += "." + GENERIC_KEY_SCHEMA;
          if (val[0] === void 0)
            val[0] = {};
          if (Utils.isObject(val[0])) {
            specialObject(val[0], p2);
          } else {
            dict[p2] = val[0];
            compile2(val[0], p2);
          }
        } else if (Utils.isObject(val)) {
          specialObject(val, p2);
        } else {
          permanentObject.push(p2);
          dict[p2] = val;
        }
      }
    }
    compile2(schema);
    return {
      masks,
      dict,
      permanentObject
    };
  }
  constructor(options2) {
    this.options = options2;
    this.memoryTotalObject = {};
    this.memoryObject = {};
    this.permanentObject = [];
    this.propagateOldRoom = true;
    if (options2.propagateOldRoom) {
      this.propagateOldRoom = options2.propagateOldRoom;
    }
  }
  async join(user, room2) {
    if (room2["canJoin"]) {
      const authBool = await Utils.resolveValue(room2["canJoin"](user, user._socket));
      if (authBool === false || typeof authBool == "string") {
        Transmitter.error(user, new NotAuthorized(authBool));
        return false;
      }
    }
    if (World$1.agonesSDK) {
      await World$1.agonesSDK.allocate();
    }
    let firstJoin = !room2.users[user.id];
    room2.users[user.id] = user;
    const userProxy = World$1.users[user.id]["proxy"];
    userProxy.$state = UserState.Connected;
    if (firstJoin) {
      if (room2["onJoin"])
        await Utils.resolveValue(room2["onJoin"](userProxy));
    }
    if (this.getUsersLength(room2) == 1) {
      this.memoryTotalObject = Room.extractObjectOfRoom(room2, room2.$schema);
    }
    const packet = new Packet({
      ...this.memoryTotalObject,
      join: firstJoin
    }, room2.id);
    await Transmitter.emit(userProxy, packet, room2);
    return true;
  }
  async leave(user, room2) {
    if (room2["onLeave"])
      room2["onLeave"](user);
    const index2 = user._rooms.findIndex((id) => room2.id == id);
    user._rooms.splice(index2, 1);
    delete room2.users[user.id];
    delete World$1.users[user.id]["proxy"];
    if (World$1.nbUsers == 0 && World$1.agonesSDK) {
      const { onBeforeShutdown, shutdownIfNotPlayers } = World$1.agonesOptions;
      if (shutdownIfNotPlayers) {
        if (onBeforeShutdown)
          await onBeforeShutdown();
        await World$1.agonesSDK.shutdown();
      }
    }
  }
  getUsersLength(room2) {
    return Object.keys(room2.users).length;
  }
  addInputs(room2, obj) {
    room2.$schema = {
      ...obj,
      ...room2.$schema
    };
  }
  snapshotUser(room2, userId) {
    const userSchema = this.permanentObject.filter((path2) => path2.startsWith("users.@")).map((path2) => path2.replace("users.@.", ""));
    const userObject = room2.users[userId];
    if (!userObject)
      return null;
    return Room.extractObjectOfRoom(userObject, userSchema);
  }
  snapshot(room2) {
    return Room.extractObjectOfRoom(room2, this.permanentObject);
  }
  setProxy(room2) {
    const self2 = this;
    const { dict, permanentObject, masks } = Room.compileSchema(room2.$schema, room2);
    const proxifiedObjects = /* @__PURE__ */ new WeakSet();
    this.permanentObject = permanentObject;
    room2.$dict = dict;
    const getInfoDict = (path2, key, dictPath) => {
      const basePath = dict[dictPath];
      const p2 = (path2 ? path2 + "." : "") + key;
      const genericPath = (dictPath ? dictPath + "." : "") + (basePath == GENERIC_KEY_SCHEMA ? GENERIC_KEY_SCHEMA : key);
      return {
        fullPath: p2,
        genericPath,
        infoDict: dict[genericPath],
        mask: masks[genericPath]
      };
    };
    function deepProxy(object, path2 = "", dictPath = "") {
      if (proxifiedObjects.has(object)) {
        return object;
      }
      return new Proxy(object, {
        set(target, key, val, receiver) {
          const { fullPath: p2, infoDict, genericPath, mask } = getInfoDict(path2, key, dictPath);
          if (typeof val == "object" && infoDict && val != null) {
            const valProxy = deepProxy(val, p2, genericPath);
            proxifiedObjects.add(valProxy);
            if (path2 == "users") {
              if (!room2.users[key]) {
                if (!valProxy._rooms)
                  valProxy._rooms = [];
                valProxy._rooms.push(room2.id);
                if (!valProxy.id)
                  valProxy.id = Utils.generateId();
              }
              World$1.users[key]["proxy"] = valProxy;
            }
            Reflect.set(target, key, val, receiver);
            val = target[key];
          } else {
            if (infoDict == null ? void 0 : infoDict.$validate) {
              const { error: error2 } = infoDict.$validate.validate(val);
              if (error2)
                return true;
            }
            Reflect.set(target, key, val, receiver);
            val = target[key];
          }
          if (key == "length" && dict[dictPath] == GENERIC_KEY_SCHEMA) {
            return true;
          }
          if (infoDict) {
            if (infoDict.$effects) {
              for (let propEffect of infoDict.$effects) {
                let pathEffect = "";
                if (propEffect.startsWith("$this")) {
                  if (p2) {
                    const pSplit = p2.split(".");
                    pSplit[pSplit.length - 1] = propEffect.replace("$this.", "");
                    pathEffect = pSplit.join(".");
                  } else {
                    pathEffect = propEffect.replace("$this.", "");
                  }
                } else {
                  pathEffect = propEffect;
                }
                self2.editMemoryObject(pathEffect, room2);
              }
            }
            let newObj;
            if (Utils.isObject(infoDict) && val != null && !Room.hasExtraProp(infoDict)) {
              newObj = Room.extractObjectOfRoom(val, mask);
            } else if (infoDict == GENERIC_KEY_SCHEMA) {
              newObj = {};
              if (Object.keys(val).length == 0) {
                newObj["$reset"] = true;
              }
              for (let key2 in val) {
                const item = val[key2];
                if (typeof item == "string" || typeof item == "number" || typeof item == "boolean") {
                  newObj[key2] = item;
                  continue;
                }
                newObj[key2] = Room.extractObjectOfRoom(item, dict[genericPath + "." + GENERIC_KEY_SCHEMA]);
              }
            } else {
              newObj = val;
            }
            self2.detectChanges(room2, newObj, p2);
          }
          return true;
        },
        get(target, key, receiver) {
          const toProxy = (val2, path3) => {
            if (typeof key != "string") {
              return val2;
            }
            if (key[0] == "_" || val2 == null) {
              return val2;
            }
            const { fullPath: p2, infoDict, genericPath } = getInfoDict(path3, key, dictPath);
            if (typeof val2 == "object" && infoDict) {
              val2 = deepProxy(val2, p2, genericPath);
              proxifiedObjects.add(val2);
            }
            return val2;
          };
          let val = Reflect.get(target, key, receiver);
          val = toProxy(val, path2);
          return val;
        },
        deleteProperty(target, key) {
          const { fullPath: p2, infoDict } = getInfoDict(path2, key, dictPath);
          Reflect.deleteProperty(target, key);
          if (infoDict)
            self2.detectChanges(room2, null, p2);
          return true;
        }
      });
    }
    return deepProxy(room2);
  }
  add(id, room2) {
    room2.id = id;
    room2.$dict = {};
    if (!room2.$schema)
      room2.$schema = {};
    if (!room2.$schema.users)
      room2.$schema.users = [User$1.schema];
    if (!room2.$inputs)
      room2.$inputs = {};
    if (!room2.users)
      room2.users = {};
    if (room2.$inputs)
      this.addInputs(room2, room2.$inputs);
    room2.$detectChanges = () => {
    };
    room2.$setSchema = (schema) => {
      room2.$schema = schema;
      return this.setProxy(room2);
    };
    room2.$patchSchema = (schema) => {
      room2.$schema = {
        ...room2.$schema,
        ...schema
      };
      return this.setProxy(room2);
    };
    room2.$snapshot = () => {
      return this.snapshot(room2);
    };
    room2.$snapshotUser = (userId) => {
      return this.snapshotUser(room2, userId);
    };
    room2.$join = async (user) => {
      if (typeof user == "string") {
        user = World$1.users[user];
      }
      if (user) {
        return this.join(user, room2);
      }
      return false;
    };
    room2.$leave = async (user) => {
      if (typeof user == "string") {
        user = World$1.users[user]["proxy"];
      }
      await this.leave(user, room2);
    };
    room2.$currentState = () => this.memoryObject;
    room2.$setCurrentState = (path2, value) => {
      this.editMemoryObject(path2, value === void 0 ? room2 : value);
    };
    room2.$clearCurrentState = () => {
      this.memoryObject = {};
    };
    room2.$parent = this;
    this.proxyRoom = room2 = this.setProxy(room2);
    if (this.proxyRoom["onInit"])
      this.proxyRoom["onInit"]();
    return this.proxyRoom;
  }
  static extractObjectOfRoom(room2, schema) {
    const newObj = {};
    const _schema = Array.isArray(schema) ? schema : Utils.propertiesToArray(schema);
    const regex = new RegExp("^(.*?)\\.\\" + GENERIC_KEY_SCHEMA);
    function extractAndSet(obj, path2) {
      if (path2.endsWith("@")) {
        return;
      }
      const match = regex.exec(path2);
      if (match) {
        const generic = get$3(room2, match[1]);
        if (generic && typeof generic === "object") {
          for (let key in generic) {
            if (generic.hasOwnProperty(key)) {
              extractAndSet(obj, path2.replace(GENERIC_KEY_SCHEMA, key));
            }
          }
        }
      } else {
        set$2(obj, path2, get$3(room2, path2));
      }
    }
    for (let path2 of _schema) {
      extractAndSet(newObj, path2);
    }
    return newObj;
  }
  detectChanges(room2, obj, path2) {
    const change = (room3) => {
      const roomInstance = room3.$parent;
      roomInstance.editMemoryObject(path2, obj);
      set$2(roomInstance.memoryTotalObject, path2, obj);
      if (roomInstance.proxyRoom["onChanges"])
        roomInstance.proxyRoom["onChanges"](roomInstance.memoryObject);
      const id = room3.id;
      World$1.changes.next({
        ...World$1.changes.value,
        [id]: room3
      });
    };
    if (obj != null) {
      const [prop, userId] = path2.split(".");
      if (prop == "users") {
        if (!this.propagateOldRoom && !room2.users[userId]) {
          return;
        }
        World$1.forEachUserRooms(userId, change);
        return;
      }
    }
    change(room2);
  }
  editMemoryObject(path2, roomOrValue) {
    if (roomOrValue && typeof roomOrValue == "object" && "$currentState" in roomOrValue) {
      set$2(this.memoryObject, path2, get$3(roomOrValue, path2), true);
    } else {
      set$2(this.memoryObject, path2, roomOrValue, true);
    }
  }
}
Room.propNameUsers = "users";
class TransportCommon {
  onConnected(cb) {
    this.onConnectedCb = cb;
  }
  onJoin(cb) {
    this.onJoinCb = cb;
  }
  onInput(cb) {
    this.onInputCb = cb;
  }
  onAction(cb) {
    this.onActionCb = cb;
  }
  onDisconnected(cb) {
    this.onDisconnectedCb = cb;
  }
}
function isFunction$4(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction$4(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e3) {
          errors2 = e3 instanceof UnsubscriptionError ? e3.errors : [e3];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError) {
                errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction$4(value.remove) && isFunction$4(value.add) && isFunction$4(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction$4(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error2, complete) {
    return new SafeSubscriber(next, error2, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction$4(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error2 !== null && error2 !== void 0 ? error2 : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error2) {
  {
    reportUnhandledError(error2);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction$4(value.next) && isFunction$4(value.error) && isFunction$4(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
class Transport extends TransportCommon {
  constructor(io, options2 = {}) {
    super();
    this.io = io;
    this.options = options2;
    this.bandwidthData = {};
    this.WINDOW_SECONDS = 10;
    io.on("connection", (socket) => {
      const id = socket.playerId;
      this.bandwidthData[id] = new BehaviorSubject({
        incoming: [],
        outgoing: []
      });
      this.handleConnection(socket, id);
      socket.on(":input", ({ prop, value }) => this.onInputCb(id, prop, value));
      socket.on(":action", ({ name: name2, value }) => this.onActionCb(id, name2, value));
      if (options2.clientCanJoinRoom)
        socket.on(":join", (roomId) => this.onJoinCb(roomId, id));
      socket.on("disconnect", () => {
        var _a;
        (_a = this.bandwidthData[id]) == null ? void 0 : _a.unsubscribe();
        delete this.bandwidthData[id];
        this.onDisconnectedCb(id);
      });
    });
    this.use();
  }
  handleConnection(socket, id) {
    this.onConnectedCb(socket, id);
  }
  use() {
    var _a, _b;
    const { maxKbpsIncoming, maxKbpsOutgoing, auth } = this.options;
    (_b = (_a = this.io).use) == null ? void 0 : _b.call(_a, async (socket, next) => {
      let playerId;
      if (auth) {
        try {
          playerId = await Utils.resolveValue(auth(socket));
        } catch (err) {
          socket.disconnect();
          next(new NotAuthorized(err).toObject());
          return;
        }
      }
      if (!playerId)
        playerId = Utils.generateId(5);
      socket.playerId = playerId;
      socket.use((packet, nextMiddleware) => {
        var _a2, _b2;
        if (packet && packet[1]) {
          const packetSize = Utils.bufferFrom(JSON.stringify(packet)).length - 2;
          const data = { size: packetSize, timestamp: Date.now() };
          this.updateBandwidthData(playerId, { incoming: data });
          const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.incoming) || []);
          if (maxKbpsIncoming && kbps > maxKbpsIncoming) {
            socket.disconnect();
            return;
          }
          this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.incoming) || []);
        }
        nextMiddleware();
      });
      const originalEmit = socket.emit;
      socket.emit = (...args) => {
        var _a2, _b2;
        const packetSize = Utils.bufferFrom(JSON.stringify(args)).length - 2;
        const data = { size: packetSize, timestamp: Date.now() };
        this.updateBandwidthData(playerId, { outgoing: data });
        const kbps = this.calculateKbps(((_a2 = this.bandwidthData[playerId]) == null ? void 0 : _a2.value.outgoing) || []);
        if (maxKbpsOutgoing && kbps > maxKbpsOutgoing) {
          socket.disconnect();
          return;
        }
        this.cleanOldData(((_b2 = this.bandwidthData[playerId]) == null ? void 0 : _b2.value.outgoing) || []);
        originalEmit.apply(socket, args);
      };
      next();
    });
  }
  updateBandwidthData(socketId, data) {
    var _a, _b;
    const currentData = ((_a = this.bandwidthData[socketId]) == null ? void 0 : _a.value) || { incoming: [], outgoing: [] };
    if (data.incoming) {
      currentData.incoming.push(data.incoming);
    }
    if (data.outgoing) {
      currentData.outgoing.push(data.outgoing);
    }
    (_b = this.bandwidthData[socketId]) == null ? void 0 : _b.next(currentData);
  }
  cleanOldData(dataArray) {
    const cutOff = Date.now() - this.WINDOW_SECONDS * 1e3;
    while (dataArray.length > 0 && dataArray[0].timestamp < cutOff) {
      dataArray.shift();
    }
  }
  calculateKbps(dataArray) {
    const totalBytes = dataArray.reduce((acc, entry) => acc + entry.size, 0);
    return totalBytes * 8 / (this.WINDOW_SECONDS * 1e3);
  }
  getTelemetry() {
    const socketsData = {};
    let totalKbps = 0;
    for (const [socketId, bandwidth] of Object.entries(this.bandwidthData)) {
      const socketData = bandwidth.value;
      const incomingKbps = this.calculateKbps(socketData.incoming);
      const outgoingKbps = this.calculateKbps(socketData.outgoing);
      socketsData[socketId] = { incomingKbps, outgoingKbps };
      totalKbps += incomingKbps + outgoingKbps;
    }
    return {
      sockets: socketsData,
      totalKbps
    };
  }
}
let WorldClass$1 = class WorldClass {
  constructor() {
    this.rooms = /* @__PURE__ */ new Map();
    this.users = {};
    this.userClass = User$1;
    this.timeoutDisconnect = 0;
    this.changes = new BehaviorSubject({});
    this._transport = null;
    this.agonesSDK = null;
    this.agonesOptions = {};
  }
  /**
   * Define user class
   *
   * @method setUserClass()
   * @returns {void}
   */
  setUserClass(userClass) {
    this.userClass = userClass;
  }
  setAgones(agones, options2 = {}) {
    this.agonesSDK = agones;
    this.agonesOptions = options2;
  }
  /**
   * Define transportation. You can set socket.io as default
   *
   * @method transport()
   * @param {object} io
   * @returns {Transport}
   */
  transport(io, options2 = {}) {
    if (options2.timeoutDisconnect) {
      this.timeoutDisconnect = options2.timeoutDisconnect;
    }
    const transport = new Transport(io, options2);
    transport.onConnected(this.connectUser.bind(this));
    transport.onDisconnected(this.disconnectUser.bind(this));
    transport.onJoin(this.joinRoom.bind(this));
    transport.onInput((id, prop, value) => {
      this.forEachUserRooms(id, (room2, user) => {
        try {
          if (room2.$inputs && room2.$inputs[prop]) {
            room2[prop] = value;
          }
        } catch (err) {
          Transmitter.error(user, err);
        }
      });
    });
    transport.onAction((id, name2, value) => {
      this.forEachUserRooms(id, async (room2, user) => {
        if (room2.$actions && room2.$actions[name2]) {
          try {
            room2[name2](user, value);
          } catch (err) {
            Transmitter.error(user, err);
          }
        }
      });
    });
    return this._transport = transport;
  }
  /**
   * Loop over all rooms of a user
   *
   * Example
   *
   * ```js
   * World.forEachUserRooms('userid', (room, user) => {
   *      console.log(room.id)
   * })
   * ```
   *
   * @method forEachUserRooms()
   * @param {string} userId
   * @param {(room: RoomClass, user: User)} cb
   * @returns {void}
   */
  forEachUserRooms(userId, cb) {
    const user = this.getUser(userId, true);
    if (!user)
      return;
    for (let roomId of user._rooms) {
      const room2 = this.getRoom(roomId);
      cb(room2, user);
    }
  }
  /**
  * Retrieves all users in the world
  *
  * @method getUsers()
  * @returns { {[id: string]: User} }
  */
  getUsers() {
    return this.users;
  }
  /**
   * Get a user in the world
   *
   * @param {string} id User Id
   * @param {boolean} [getProxy] Retrieves the proxied user. (true by default)
   * @returns {User | null}
   */
  getUser(id, getProxy = true) {
    if (!this.users[id])
      return null;
    if (getProxy && this.users[id]["proxy"]) {
      return this.users[id]["proxy"];
    }
    return this.users[id];
  }
  setUser(user, socket) {
    if (socket)
      user._socket = socket;
    user._rooms = [];
    this.users[user.id] = user;
    return this.users[user.id];
  }
  get nbUsers() {
    return Object.keys(this.users).length;
  }
  /**
   * Send the packages to the rooms.
   *
   * @method send()
   */
  async send() {
    for (let [_2, room2] of this.rooms) {
      const obj = room2.$currentState();
      if (Object.keys(obj).length == 0) {
        continue;
      }
      Transmitter.addPacket(room2, obj);
      for (let id in room2.users) {
        const user = room2.users[id];
        const packets = Transmitter.getPackets(room2);
        if (packets) {
          for (let packet of packets) {
            await Transmitter.emit(user, packet, room2);
          }
        }
      }
      room2.$clearCurrentState();
    }
    Transmitter.clear();
  }
  /**
   * Connect a user
   *
   * @method connectUser()
   * @param {object} socket
   * @param {id} userId
   * @param {object} options
   *  - getUserInstance: function that returns a new instance of the user
   * @returns {User}
   */
  connectUser(socket, id, options2 = {}) {
    var _a;
    const existingUser = this.getUser(id, false);
    if (existingUser) {
      if (existingUser._timeoutDisconnect) {
        clearTimeout(existingUser._timeoutDisconnect);
        delete existingUser._timeoutDisconnect;
      }
      existingUser._socket = socket;
      existingUser.$state = UserState.Connected;
      return existingUser;
    }
    const user = ((_a = options2.getUserInstance) == null ? void 0 : _a.call(options2, socket)) ?? new this.userClass();
    user.id = id;
    socket.emit("uid", id);
    this.setUser(user, socket);
    return user;
  }
  /**
   * Removes the user from all rooms and removes him from the world
   *
   * @method disconnectUser()
   * @param {string} userId
   * @returns {void}
   */
  disconnectUser(userId) {
    return new Promise((resolve2, reject) => {
      const user = this.getUser(userId);
      if (!user)
        return resolve2();
      user.$state = UserState.Disconnected;
      const leave = () => {
        const leaveAllPromises = [];
        this.forEachUserRooms(userId, async (room2, user2) => {
          if (room2.$leave)
            leaveAllPromises.push(room2.$leave(user2));
        });
        delete this.users[userId];
        Promise.all(leaveAllPromises).then(resolve2).catch((err) => {
          Transmitter.error(user, err);
          reject(err);
        });
      };
      if (!this.timeoutDisconnect) {
        leave();
        return;
      }
      user._timeoutDisconnect = setTimeout(leave, this.timeoutDisconnect);
    });
  }
  httpUpgrade(httpServer, io) {
    httpServer.removeAllListeners("upgrade");
    httpServer.on("upgrade", (req, socket, head) => {
      if (req.url.startsWith("/socket.io/")) {
        io.engine.handleUpgrade(req, socket, head);
      } else {
        socket.destroy();
      }
    });
  }
  async joinOrLeaveRoom(type, roomId, userId) {
    const room2 = this.getRoom(roomId);
    if (!room2)
      return;
    if (room2[type]) {
      try {
        await room2[type](this.getUser(userId, false));
      } catch (err) {
        Transmitter.error(this.getUser(userId, false), err);
        throw err;
      }
    }
    return room2;
  }
  /**
   * Leave an existing room
   *
   * @param {string} roomId
   * @param {string} userId
   * @returns {RoomClass | undefined}
   */
  async leaveRoom(roomId, userId) {
    return this.joinOrLeaveRoom("$leave", roomId, userId);
  }
  /**
   * Join an existing room
   *
   * @param {string} roomId
   * @param {string} userId
   * @returns {RoomClass | undefined}
   */
  async joinRoom(roomId, userId) {
    return this.joinOrLeaveRoom("$join", roomId, userId);
  }
  /**
   * Add Room
   *
   * Example 1:
   *
   * ```js
   * class ChessRoom {
   *
   * }
   *
   * World.addRoom('myroom', ChessRoom)
   * ```
   *
   * Example 2:
   *
   * ```js
   * class ChessRoom {
   *  constructor(name) { }
   * }
   *
   * World.addRoom('myroom', new ChessRoom('test'))
   * ```
   *
   * @param {string} id room id
   * @param {Class or instance of Class} roomClass
   * @returns instance of Class
   */
  addRoom(id, roomClass, options2 = {}) {
    if (roomClass.constructor.name == "Function") {
      roomClass = new roomClass();
    }
    const room2 = new Room(options2).add(id, roomClass);
    this.rooms.set(id, room2);
    if (this.agonesSDK) {
      this.agonesSDK.setLabel("room.id", id);
    }
    return room2;
  }
  /**
   * Get an existing room
   *
   * @param {string} roomId
   * @returns {RoomClass}
   */
  getRoom(id) {
    return this.rooms.get(id);
  }
  /**
   * Recover the rooms of the world
   *
   * @param {string} roomId
   * @returns {Map<string, RoomClass>}
   */
  getRooms() {
    return this.rooms;
  }
  /**
   * Delete the room
   *
   * @param {string} roomId
   * @returns {void}
   */
  removeRoom(id) {
    this.rooms.delete(id);
  }
  /**
   * Remove all rooms and users
   */
  clear() {
    var _a, _b;
    this.rooms.clear();
    this.changes.next({});
    this.users = {};
    if (this._transport) {
      (_b = (_a = this._transport.io) == null ? void 0 : _a.clear) == null ? void 0 : _b.call(_a);
    }
  }
};
const World$1 = new WorldClass$1();
class MiddlewareHandler {
  constructor() {
    this.middlewares = [];
  }
  use(middleware) {
    this.middlewares.push(middleware);
  }
  run(socket, finalCallback = (err) => {
  }) {
    let index2 = 0;
    const next = (err) => {
      if (err) {
        finalCallback(err);
        return;
      }
      if (index2 >= this.middlewares.length) {
        finalCallback();
        return;
      }
      const middleware = this.middlewares[index2];
      index2 += 1;
      middleware(socket, next);
    };
    next();
  }
  clear() {
    this.middlewares = [];
  }
}
class MockIo2 {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
    this.eventsOnce = /* @__PURE__ */ new Map();
  }
  on(name2, value) {
    this.events.set(name2, [...this.events.get(name2) || [], value]);
  }
  off(name2) {
    if (this.eventsOnce.has(name2)) {
      this.eventsOnce.delete(name2);
      return;
    }
    this.events.delete(name2);
  }
  once(name2, value) {
    this.eventsOnce.set(name2, value);
  }
  _trigger(name2, data, client) {
    const events2 = this.events.get(name2) || [];
    for (const event of events2) {
      event(data, client);
    }
    const eventOnce = this.eventsOnce.get(name2);
    if (eventOnce) {
      eventOnce(data, client);
      this.eventsOnce.delete(name2);
    }
  }
}
class MockSocket2 extends MockIo2 {
  constructor(handshake, client) {
    super();
    this.handshake = handshake;
    this.client = client;
    this.middlewares = new MiddlewareHandler();
    this.id = client.fakeId ?? "" + Math.random();
    this.client.id = this.id;
  }
  emit(name2, data) {
    this.client._trigger(name2, data);
  }
  removeAllListeners(name2) {
    return this.off(name2);
  }
  use(cb) {
    this.middlewares.use(cb);
  }
  disconnect() {
  }
}
class MockClientIo extends MockIo2 {
  constructor(fakeId) {
    super();
    this.fakeId = fakeId;
    this.id = "";
    this._socket = null;
  }
  async connection(handshake) {
    this._socket = await serverIo$1.connection(this, handshake);
    this._trigger("connect", void 0);
    return this;
  }
  emit(name2, data) {
    if (!this._socket)
      throw new Error("Client not connected");
    this._socket.middlewares.run([name2, data], (err) => {
      if (err) {
        this._trigger("error", err);
        return;
      }
      serverIo$1.emit(name2, data, this.id);
    });
    return this;
  }
  disconnect() {
    this.emit("disconnect", void 0);
  }
}
class MockServerIo2 extends MockIo2 {
  constructor() {
    super(...arguments);
    this.clients = /* @__PURE__ */ new Map();
    this.middlewares = new MiddlewareHandler();
  }
  connection(client, handshake) {
    return new Promise((resolve2, reject) => {
      const socket = new MockSocket2(handshake, client);
      this.clients.set(socket.id, socket);
      client.id = socket.id;
      this.middlewares.run(socket, (err) => {
        if (err) {
          client._trigger("error", err);
          return;
        }
        this._trigger("connection", socket);
        resolve2(socket);
      });
    });
  }
  emit(name2, data, id) {
    var _a;
    (_a = this.clients.get(id)) == null ? void 0 : _a._trigger(name2, data);
  }
  use(cb) {
    this.middlewares.use(cb);
  }
  clear() {
    this.events.clear();
    this.eventsOnce.clear();
    this.clients.clear();
    this.middlewares.clear();
  }
}
const serverIo$1 = new MockServerIo2();
const ClientIo$1 = MockClientIo;
const MockSocketIo = {
  serverIo: serverIo$1,
  ClientIo: ClientIo$1
};
var lodash_merge = { exports: {} };
lodash_merge.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var objectCtorString = funcToString2.call(Object);
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e3) {
    }
  }();
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size2 = data.size;
    data.set(key, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assocIndexOf2(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq2(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity2), func + "");
  }
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length = buffer2.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer2.constructor(length);
    buffer2.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array2) {
    var index2 = -1, length = source.length;
    array2 || (array2 = Array(length));
    while (++index2 < length) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq2(object[index2], value);
    }
    return false;
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
      while (++index2 < length) {
        array2[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array2);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var merge2 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  function constant2(value) {
    return function() {
      return value;
    };
  }
  function identity2(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = merge2;
})(lodash_merge, lodash_merge.exports);
var lodash_mergeExports = lodash_merge.exports;
const merge$2 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergeExports);
function merge$1(options2, type, _static = {}) {
  const transformToRate = (optionName, propName) => {
    if (options2[optionName]) {
      options2[optionName] = options2[optionName].map((element) => {
        if (!element.rate) {
          return {
            rate: 1,
            [propName]: element
          };
        }
        return element;
      });
    }
  };
  transformToRate("elements", "element");
  transformToRate("elementsDefense", "element");
  transformToRate("elementsEfficiency", "element");
  transformToRate("addStates", "state");
  transformToRate("removeStates", "state");
  transformToRate("statesDefense", "state");
  transformToRate("statesEfficiency", "state");
  return (target) => {
    const id = options2.id || target.name.toLowerCase();
    target.id = id;
    target.prototype.id = id;
    target._type = type;
    for (let key in _static) {
      target[key] = options2[key];
    }
    for (let key in options2) {
      target.prototype[key] = options2[key];
    }
    target.prototype.toJSON = function() {
      return this.id;
    };
  };
}
function Item(options2) {
  return merge$1(options2, "item", {
    price: options2.price
  });
}
function Actor(options2) {
  return merge$1(options2, "actor");
}
var ClassHooks;
(function(ClassHooks2) {
  ClassHooks2["onSet"] = "onSet";
  ClassHooks2["canEquip"] = "canEquip";
})(ClassHooks || (ClassHooks = {}));
function Class(options2) {
  return merge$1(options2, "class");
}
function Skill(options2) {
  if (!options2.coefficient)
    options2.coefficient = {
      "int": 1
    };
  return merge$1(options2, "skill");
}
function State$1(options2) {
  return merge$1(options2, "state");
}
function Weapon(options2) {
  return merge$1(options2, "weapon", {
    price: options2.price
  });
}
function Armor(options2) {
  return merge$1(options2, "armor", {
    price: options2.price
  });
}
var Effect;
(function(Effect2) {
  Effect2["NONE"] = "NONE";
  Effect2["CAN_NOT_SKILL"] = "CAN_NOT_SKILL";
  Effect2["CAN_NOT_ITEM"] = "CAN_NOT_ITEM";
  Effect2["ALWAYS_ATTACK_ENEMIES"] = "ALWAYS_ATTACK_ENEMIES";
  Effect2["CAN_NOT_EVADE"] = "CAN_NOT_EVADE";
  Effect2["CAN_NOT_GET_EXP"] = "CAN_NOT_GET_EXP";
  Effect2["CAN_NOT_GET_GOLD"] = "CAN_NOT_GET_GOLD";
  Effect2["PHARMACOLOGY"] = "PHARMACOLOGY";
  Effect2["CRITICAL_BONUS"] = "CRITICAL_BONUS";
  Effect2["SUPER_GUARD"] = "SUPER_GUARD";
  Effect2["GUARD"] = "GUARD";
  Effect2["PREVENT_CRITICAL"] = "PREVENT_CRITICAL";
  Effect2["HALF_SP_COST"] = "HALF_SP_COST";
  Effect2["DOUBLE_EXP_GAIN"] = "DOUBLE_EXP_GAIN";
  Effect2["AUTO_HP_RECOVER"] = "AUTO_HP_RECOVER";
  Effect2["FAST_ATTACK"] = "FAST_ATTACK";
  Effect2["DUAL_ATTACK"] = "DUAL_ATTACK";
  Effect2["SLIP_DAMAGE"] = "SLIP_DAMAGE";
})(Effect || (Effect = {}));
var Efficiency;
(function(Efficiency2) {
  Efficiency2[Efficiency2["VERY_VULNERABLE"] = 2] = "VERY_VULNERABLE";
  Efficiency2[Efficiency2["VULNERABLE"] = 1.5] = "VULNERABLE";
  Efficiency2[Efficiency2["NORMAL"] = 1] = "NORMAL";
  Efficiency2[Efficiency2["INVULNERABLE"] = 0.5] = "INVULNERABLE";
  Efficiency2[Efficiency2["PERFECT_INVULNERABLE"] = 0] = "PERFECT_INVULNERABLE";
  Efficiency2[Efficiency2["GAIN_HP"] = -0.5] = "GAIN_HP";
})(Efficiency || (Efficiency = {}));
class Log {
  constructor(id, msg) {
    this.id = id;
    this.msg = msg;
  }
}
class ItemLog {
  static notInInventory(itemClass) {
    return new Log("ITEM_NOT_INVENTORY", `The item ${itemClass.name} is not in inventory`);
  }
  static notUseItem(itemClass) {
    return new Log("NOT_USE_ITEM", `The player cannot use the ${itemClass.name} item.`);
  }
  static chanceToUseFailed(itemClass) {
    return new Log("USE_CHANCE_ITEM_FAILED", `Chance to use the ${itemClass.name} item has failed`);
  }
  static invalidToEquiped(itemClass) {
    return new Log("INVALID_ITEM_TO_EQUIP", `The item ${itemClass.name} is not a weapon or armor`);
  }
  static canNotEquip(itemClass) {
    return new Log("CANNOT_EQUIP", `The item ${itemClass.name} cannot be equiped`);
  }
  static isAlreadyEquiped(itemClass) {
    return new Log("ITEM_ALREADY_EQUIPED", `The item ${itemClass.name} is already equiped`);
  }
  static haveNotPrice(itemClass) {
    return new Log("NOT_PRICE", `Define a price > 0 to buy ${itemClass.name}`);
  }
  static notEnoughGold(itemClass, nb) {
    return new Log("NOT_ENOUGH_GOLD", `not enough gold to buy ${nb} ${itemClass.name}`);
  }
  static tooManyToSell(itemClass, nbToSell, nb) {
    return new Log("TOO_MANY_ITEM_TO_SELL", `Too many items to sell: ${nbToSell} ${itemClass.name}, only ${nb} in inventory`);
  }
  static restriction(itemClass) {
    return new Log("RESTRICTION_ITEM", `A state blocks the use of the ${itemClass.name} skill`);
  }
}
class SkillLog {
  static notLearned(skillClass) {
    return new Log("SKILL_NOT_LEARNED", `the skill ${skillClass.name} is not learned`);
  }
  static notEnoughSp(skillClass, skillSp, playerSp) {
    return new Log("NOT_ENOUGH_SP", `not enough SP to use ${skillClass.name} skill. ${skillSp} Skill'SP is is greater than ${playerSp} Player'SP`);
  }
  static chanceToUseFailed(skillClass) {
    return new Log("USE_CHANCE_SKILL_FAILED", `Chance to use the ${skillClass.name} skill has failed`);
  }
  static restriction(skillClass) {
    return new Log("RESTRICTION_SKILL", `A state blocks the use of the ${skillClass.name} skill`);
  }
  static alreadyLearned(skillClass) {
    return new Log("SKILL_ALREADY_LEARNED", `The ${skillClass.name} skill is already learned`);
  }
}
class StateLog {
  static addFailed(stateClass) {
    return new Log("ADD_STATE_FAILED", `Adding the ${stateClass.name} state has failed`);
  }
  static removeFailed(stateClass) {
    return new Log("REMOVE_STATE_FAILED", `Removing the ${stateClass.name} state has failed`);
  }
  static notApplied(stateClass) {
    return new Log("STATE_NOT_APPLIED", `State ${stateClass.name} does not exist`);
  }
}
const {
  random: random$1
} = Utils$2;
const MAXHP = "maxHp";
const MAXSP = "maxSp";
const ATK = "atk";
const PDEF = "pdef";
const SDEF = "sdef";
const STR = "str";
const AGI = "agi";
const INT = "int";
const DEX = "dex";
const MAXHP_CURVE = {
  start: 741,
  end: 7467
};
const MAXSP_CURVE = {
  start: 534,
  end: 5500
};
const STR_CURVE = {
  start: 67,
  end: 635
};
const AGI_CURVE = {
  start: 58,
  end: 582
};
const INT_CURVE = {
  start: 36,
  end: 7318
};
const DEX_CURVE = {
  start: 54,
  end: 564
};
const DAMAGE_CRITICAL = function(damage, a8, b3) {
  if (random$1(0, 100) < 4 * a8[DEX] / b3[AGI]) {
    damage *= 2;
  }
  return damage;
};
const DAMAGE_PHYSIC = function(a8, b3) {
  let damage = Math.round((a8[ATK] - b3[PDEF] / 2) * ((20 + a8[STR]) / 20));
  if (damage < 0)
    damage = 0;
  return damage;
};
const DAMAGE_GUARD = function(damage) {
  return damage / 2;
};
const COEFFICIENT_ELEMENTS = function(a8, b3, bDef) {
  return (a8.rate + 1) * (b3.rate + 1) / (bDef.rate == 0 ? bDef.rate * 4 : 1);
};
const DAMAGE_SKILL = function(a8, b3, skill) {
  let power = skill.power + a8[ATK] * (skill.coefficient[ATK] || 0);
  if (power > 0) {
    power -= b3[PDEF] * (skill.coefficient[PDEF] || 0) / 2;
    power -= b3[SDEF] * (skill.coefficient[SDEF] || 0) / 2;
    power = Math.max(power, 0);
  }
  let rate = 20;
  [STR, DEX, AGI, INT].forEach((val) => rate += a8[val] * (skill.coefficient[val] || 0));
  return Math.round(power * rate / 20);
};
const Presets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AGI,
  AGI_CURVE,
  ATK,
  COEFFICIENT_ELEMENTS,
  DAMAGE_CRITICAL,
  DAMAGE_GUARD,
  DAMAGE_PHYSIC,
  DAMAGE_SKILL,
  DEX,
  DEX_CURVE,
  INT,
  INT_CURVE,
  MAXHP,
  MAXHP_CURVE,
  MAXSP,
  MAXSP_CURVE,
  PDEF,
  SDEF,
  STR,
  STR_CURVE
}, Symbol.toStringTag, { value: "Module" }));
const {
  isString: isString$8
} = Utils$2;
class ParameterManager {
  constructor() {
    this._paramsModifier = {};
    this._hp = 0;
    this._sp = 0;
    this._exp = 0;
    this._level = 0;
    this.initialLevel = 1;
    this.finalLevel = 99;
  }
  /**
   * Changes the health points
   * - Cannot exceed the MaxHP parameter
   * - Cannot have a negative value
   * - If the value is 0, a hook named `onDead()` is called in the RpgPlayer class.
   *
   * ```ts
   * player.hp = 100
   * ```
   * @title Change HP
   * @prop {number} player.hp
   * @default MaxHPValue
   * @memberof ParameterManager
   * */
  set hp(val) {
    if (val > this.param[MAXHP]) {
      val = this.param[MAXHP];
    } else if (val <= 0) {
      this["execMethod"]("onDead");
      val = 0;
    }
    this._hp = val;
  }
  get hp() {
    return this._hp;
  }
  /**
   * Changes the skill points
   * - Cannot exceed the MaxSP parameter
   * - Cannot have a negative value
   *
   * ```ts
   * player.sp = 200
   * ```
   * @title Change SP
   * @prop {number} player.sp
   * @default MaxSPValue
   * @memberof ParameterManager
   * */
  set sp(val) {
    if (val > this.param[MAXSP]) {
      val = this.param[MAXSP];
    }
    this._sp = val;
  }
  get sp() {
    return this._sp;
  }
  /**
   * Changing the player's experience.
   * ```ts
   * player.exp += 100
   * ```
   *
   * Levels are based on the experience curve.
   *
   * ```ts
   * console.log(player.level) // 1
   * console.log(player.expForNextlevel) // 150
   * player.exp += 160
   * console.log(player.level) // 2
   * ```
   *
   * @title Change Experience
   * @prop {number} player.exp
   * @default 0
   * @memberof ParameterManager
   * */
  set exp(val) {
    this._exp = val;
    this.level;
    while (this.expForNextlevel < this._exp) {
      this.level += 1;
    }
  }
  get exp() {
    return this._exp;
  }
  /**
   * Changing the player's level.
   *
   * ```ts
   * player.level += 1
   * ```
   *
   * The level will be between the initial level given by the `initialLevel` and final level given by `finalLevel`
   *
   * ```ts
   * player.finalLevel = 50
   * player.level = 60
   * console.log(player.level) // 50
   * ```
   *
   * @title Change Level
   * @prop {number} player.level
   * @default 1
   * @memberof ParameterManager
   * */
  set level(val) {
    const lastLevel = this._level;
    if (this.finalLevel && val > this.finalLevel) {
      val = this.finalLevel;
    }
    if (this._class) {
      for (let i2 = this._level; i2 <= val; i2++) {
        for (let skill of this._class.skillsToLearn) {
          if (skill.level == i2) {
            this["learnSkill"](skill.skill);
          }
        }
      }
    }
    const hasNewLevel = val - lastLevel;
    if (hasNewLevel > 0) {
      this["execMethod"]("onLevelUp", [hasNewLevel]);
    }
    this._level = val;
  }
  get level() {
    return this._level;
  }
  /**
  * ```ts
  * console.log(player.expForNextlevel) // 150
  * ```
  * @title Experience for next level ?
  * @prop {number} player.expForNextlevel
  * @readonly
  * @memberof ParameterManager
  * */
  get expForNextlevel() {
    return this._expForLevel(this.level + 1);
  }
  /**
   * Read the value of a parameter. Put the name of the parameter.
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * console.log(player.param[MAXHP])
   * ```
   *
   * > Possible to use the `player.getParamValue(name)` method instead
   * @title Get Param Value
   * @prop {object} player.param
   * @readonly
   * @memberof ParameterManager
   * */
  get param() {
    const obj = {};
    this._parameters.forEach((val, name2) => {
      obj[name2] = this.getParamValue(name2);
    });
    return obj;
  }
  get paramsModifier() {
    const params = {};
    const paramsAvg = {};
    const changeParam = (paramsModifier) => {
      for (let key in paramsModifier) {
        const {
          rate,
          value
        } = paramsModifier[key];
        if (!params[key])
          params[key] = {
            rate: 0,
            value: 0
          };
        if (!paramsAvg[key])
          paramsAvg[key] = 0;
        if (value)
          params[key].value += value;
        if (rate !== void 0)
          params[key].rate += rate;
        paramsAvg[key]++;
      }
    };
    const getModifier = (prop) => {
      if (!isString$8(prop)) {
        changeParam(prop);
        return;
      }
      for (let el of this[prop]) {
        if (!el.paramsModifier)
          continue;
        changeParam(el.paramsModifier);
      }
    };
    getModifier(this._paramsModifier);
    getModifier("states");
    getModifier("equipments");
    for (let key in params) {
      params[key].rate /= paramsAvg[key];
    }
    return params;
  }
  /**
   * Changes the values of some parameters
   *
   * > It is important that these parameters have been created beforehand with the `addParameter()` method.
   * > By default, the following settings have been created:
   * - maxhp
   * - maxsp
   * - str
   * - int
   * - dex
   * - agi
   *
   * **Object Key**
   *
   * The key of the object is the name of the parameter
   *
   * > The good practice is to retrieve the name coming from a constant
   *
   * **Object Value**
   *
   * The value of the key is an object containing:
   * ```
   * {
   *   value: number,
   *   rate: number
   * }
   * ```
   *
   * - value: Adds a number to the parameter
   * - rate: Adds a rate to the parameter
   *
   * > Note that you can put both (value and rate)
   *
   * In the case of a state or the equipment of a weapon or armor, the parameters will be changed but if the state disappears or the armor/weapon is de-equipped, then the parameters will return to the initial state.
   *
   * @prop {Object} [paramsModifier]
   * @example
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * player.paramsModifier = {
   *      [MAXHP]: {
   *          value: 100
   *      }
   * }
   * ```
   *
   * 1. Player has 741 MaxHp
   * 2. After changing the parameter, he will have 841 MaxHp
   *
   * @title Set Parameters Modifier
   * @prop {number} paramsModifier
   * @memberof ParameterManager
   * */
  set paramsModifier(val) {
    this._paramsModifier = val;
    this.changeRoomState("param");
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(val) {
    this._parameters = val;
  }
  _expForLevel(level) {
    const {
      basis,
      extra,
      accelerationA,
      accelerationB
    } = this.expCurve;
    return Math.round(basis * Math.pow(level - 1, 0.9 + accelerationA / 250) * level * (level + 1) / (6 + Math.pow(level, 2) / 50 / accelerationB) + (level - 1) * extra);
  }
  getParam(name2) {
    const features = this._parameters.get(name2);
    if (!features) {
      throw `Parameter ${name2} not exists. Please use addParameter() before`;
    }
    return features;
  }
  getParamValue(name2) {
    const features = this.getParam(name2);
    let curveVal = Math.floor((features.end - features.start) * ((this.level - 1) / (this.finalLevel - this.initialLevel))) + features.start;
    const modifier = this.paramsModifier[name2];
    if (modifier) {
      if (modifier.rate)
        curveVal *= modifier.rate;
      if (modifier.value)
        curveVal += modifier.value;
    }
    return curveVal;
  }
  /**
   * Give a new parameter. Give a start value and an end value.
   * The start value will be set to the level set at `player.initialLevel` and the end value will be linked to the level set at `player.finalLevel`.
   *
   * ```ts
   * const SPEED = 'speed'
   *
   * player.addParameter(SPEED, {
   *     start: 10,
   *     end: 100
   * })
   *
   * player.param[SPEED] // 10
   * player.level += 5
   * player.param[SPEED] // 14
   * ```
   *
   * @title Add custom parameters
   * @method player.addParameter(name,curve)
   * @param {name} name
   * @param {object} curve Scheme of the object: { start: number, end: number }
   * @returns {void}
   * @memberof ParameterManager
   * */
  addParameter(name2, {
    start,
    end
  }) {
    this._parameters.set(name2, {
      start,
      end
    });
    const maxHp = this.param[MAXHP];
    const maxSp = this.param[MAXSP];
    if (name2 == MAXHP && this.hp > maxHp) {
      this.hp = maxHp;
    } else if (name2 == MAXSP && this.sp > maxSp) {
      this.sp = maxSp;
    }
    this.changeRoomState("param." + name2);
  }
  /**
   * Gives back in percentage of health points to skill points
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP } = Presets
   *
   * console.log(player.param[MAXHP]) // 800
   * player.hp = 100
   * player.recovery({ hp: 0.5 }) // = 800 * 0.5
   * console.log(player.hp) // 400
   * ```
   *
   * @title Recovery HP and/or SP
   * @method player.recovery(params)
   * @param {object} params Scheme of the object: { hp: number, sp: number }. The values of the numbers must be in 0 and 1
   * @returns {void}
   * @memberof ParameterManager
   * */
  recovery({
    hp,
    sp
  }) {
    if (hp)
      this.hp = this.param[MAXHP] * hp;
    if (sp)
      this.sp = this.param[MAXSP] * sp;
  }
  /**
   * restores all HP and SP
   *
   * ```ts
   * import { Presets } from '@rpgjs/server'
   *
   * const { MAXHP, MAXSP } = Presets
   *
   * console.log(player.param[MAXHP], player.param[MAXSP]) // 800, 230
   * player.hp = 100
   * player.sp = 0
   * player.allRecovery()
   * console.log(player.hp, player.sp) // 800, 230
   * ```
   *
   * @title All Recovery
   * @method player.allRecovery()
   * @returns {void}
   * @memberof ParameterManager
   * */
  allRecovery() {
    this.recovery({
      hp: 1,
      sp: 1
    });
  }
}
const {
  arrayUniq: arrayUniq$1,
  arrayFlat: arrayFlat$1,
  applyMixins: applyMixins$7
} = Utils$2;
class EffectManager {
  // TODO
  applyEffect(item) {
    if (item.hpValue) {
      this.hp += item.hpValue;
    }
    if (item.hpRate) {
      this.hp += this.param[MAXHP] * item.hpRate;
    }
    if (item.spValue) {
      this.sp += item.spValue;
    }
    if (item.spRate) {
      this.sp += this.param[MAXSP] * item.spRate;
    }
  }
  /**
   * ```ts
   * import { Effect } from '@rpgjs/database'
   *
   * const bool = player.hasEffect(Effect.CAN_NOT_SKILL)
   * ```
   *
   * @title Has Effect
   * @method player.hasEffect(effect)
   * @param {Effect} effect
   * @returns {boolean}
   * @memberof EffectManager
   * */
  hasEffect(effect) {
    return this.effects.includes(effect);
  }
  /**
   * Retrieves a array of effects assigned to the player, state effects and effects of weapons and armors equipped with the player's own weapons.
   *
   * ```ts
   * console.log(player.effects)
   * ```
   * @title Get Effects
   * @prop {Array<Effect>} player.effects
   * @memberof EffectManager
   * */
  get effects() {
    const getEffects = (prop) => {
      return arrayFlat$1(this[prop].map((el) => el.effects || []));
    };
    return arrayUniq$1([...this._effects, ...getEffects("states"), ...getEffects("equipments")]);
  }
  /**
   * Assigns effects to the player. If you give a array, it does not change the effects of the player's states and armor/weapons equipped.
   *
   * ```ts
   * import { Effect } from '@rpgjs/database'
   *
   * player.effects = [Effect.CAN_NOT_SKILL]
   * ```
   * @title Set Effects
   * @prop {Array<Effect>} player.effects
   * @memberof EffectManager
   * */
  set effects(val) {
    this._effects = val;
  }
}
applyMixins$7(EffectManager, [ParameterManager]);
class GoldManager {
  constructor() {
    this._gold = 0;
  }
  /**
  * You can change the game money
  *
  * ```ts
  * player.gold += 100
  * ```
  *
  * @title Change Gold
  * @prop {number} player.gold
  * @default 0
  * @memberof GoldManager
  * */
  set gold(val) {
    if (val < 0) {
      val = 0;
    }
    this._gold = val;
  }
  get gold() {
    return this._gold;
  }
}
class ItemFixture {
  getFeature(name2, prop) {
    const array2 = {};
    for (let item of this.equipments) {
      if (item[name2]) {
        for (let feature of item[name2]) {
          const {
            rate
          } = feature;
          const instance = feature[prop];
          const cache = array2[instance.id];
          if (cache && cache.rate >= rate)
            continue;
          array2[instance.id] = feature;
        }
      }
    }
    return Object.values(array2);
  }
}
const {
  isInstanceOf: isInstanceOf$2,
  applyMixins: applyMixins$6,
  isString: isString$7
} = Utils$2;
class StateManager {
  constructor() {
    this.states = [];
  }
  /**
   * Recovers the player's states defense on inventory.  This list is generated from the `statesDefense` property defined on the weapons or armors equipped.
   * If several items have the same element, only the highest rate will be taken into account.
   *
   * ```ts
   * import { Armor, State } from '@rpgjs/server'
   *
   * @State({
   *      name: 'Paralyze'
   * })
   * class Paralyze {}
   *
   * @Armor({
   *      name: 'Shield',
   *      statesDefense: [{ rate: 1, state: Paralyze }]
   * })
   * class Shield {}
   *
   * @Armor({
   *      name: 'FireShield',
   *      statesDefense: [{ rate: 0.5, state: Paralyze }]
   * })
   * class FireShield {}
   *
   * player.addItem(Shield)
   * player.addItem(FireShield)
   * player.equip(Shield)
   * player.equip(FireShield)
   *
   * console.log(player.statesDefense) // [{ rate: 1, state: instance of Paralyze }]
   * ```
   * @title Get States Defense
   * @prop {Array<{ rate: number, state: StateClass}>} player.statesDefense
   * @readonly
   * @memberof StateManager
   * */
  get statesDefense() {
    return this.getFeature("statesDefense", "state");
  }
  /**
   * Set or retrieves all the states where the player is vulnerable or not.
   *
   * ```ts
   * import { Class, State } from '@rpgjs/server'
   *
   * @State({
   *      name: 'Paralyze'
   * })
   * class Paralyze {}
   *
   * @State({
   *      name: 'Sleep'
   * })
   * class Sleep {}
   *
   * @Class({
   *      name: 'Fighter',
   *      statesEfficiency: [{ rate: 1, state: Paralyze }]
   * })
   * class Hero {}
   *
   * player.setClass(Hero)
   *
   * console.log(player.statesEfficiency) // [{ rate: 1, instance of Paralyze }]
   *
   * player.statesEfficiency = [{ rate: 2, state: Sleep }]
   *
   * console.log(player.statesEfficiency) // [{ rate: 1, state: instance of Paralyze }, { rate: 2, state: instance of Sleep }]
   * ```
   * @title Set/Get States Efficiency
   * @prop {Array<{ rate: number, state: StateClass}>} player.statesEfficiency
   * @memberof StateManager
   * */
  get statesEfficiency() {
    return this._statesEfficiency;
  }
  set statesEfficiency(val) {
    this._statesEfficiency = val;
  }
  applyStates(player2, {
    addStates,
    removeStates
  }) {
    if (addStates) {
      for (let {
        state,
        rate
      } of addStates) {
        player2.addState(state, rate);
      }
    }
    if (removeStates) {
      for (let {
        state,
        rate
      } of removeStates) {
        player2.removeState(state, rate);
      }
    }
  }
  /**
   * Get a state to the player. Returns `null` if the state is not present on the player
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * player.getState(Paralyze)
   *  ```
   *
   * @title Get State
   * @method player.getState(stateClass)
   * @param {StateClass | string} stateClass or state id
   * @returns {instance of StateClass | null}
   * @memberof StateManager
   */
  getState(stateClass) {
    if (isString$7(stateClass))
      stateClass = this.databaseById(stateClass);
    return this.states.find((state) => {
      if (isString$7(stateClass)) {
        return state.id == stateClass;
      }
      return isInstanceOf$2(state, stateClass);
    });
  }
  /**
   * Adds a state to the player. Set the chance between 0 and 1 that the state can apply
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * try {
   *      player.addState(Paralyze)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Add State
   * @method player.addState(stateClass,chance=1)
   * @param {StateClass | string} stateClass state class or state id
   * @param {number} [chance] 1 by default
   * @throws {StateLog} addFailed
   * If the chance to add the state has failed (defined with the `chance` param)
   *  ```
   * {
   *      id: ADD_STATE_FAILED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of StateClass}
   * @memberof StateManager
   * @todo
   */
  addState(stateClass, chance = 1) {
    const state = this.getState(stateClass);
    if (isString$7(stateClass)) {
      stateClass = this.databaseById(stateClass);
    }
    if (!state) {
      if (Math.random() > chance) {
        throw StateLog.addFailed(stateClass);
      }
      const instance = new stateClass();
      this.states.push(instance);
      this.applyStates(this, instance);
      return instance;
    }
    return null;
  }
  /**
   * Remove a state to the player. Set the chance between 0 and 1 that the state can be removed
   * ```ts
   * import Paralyze from 'your-database/states/paralyze'
   *
   * try {
   *      player.removeState(Paralyze)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Remove State
   * @method player.removeState(stateClass,chance=1)
   * @param {StateClass|string} stateClass class state or state id
   * @param {number} [chance] 1 by default
   * @throws {StateLog} removeFailed
   * If the chance to remove the state has failed (defined with the `chance` param)
   *  ```
   * {
   *      id: REMOVE_STATE_FAILED,
   *      msg: '...'
   * }
   * ```
   * @throws {StateLog} notApplied
   * If the status does not exist
   *  ```
   * {
   *      id: STATE_NOT_APPLIED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of StateClass}
   * @memberof StateManager
   */
  removeState(stateClass, chance = 1) {
    const index2 = this.states.findIndex((state) => {
      if (isString$7(stateClass)) {
        return state.id == stateClass;
      }
      return isInstanceOf$2(state, stateClass);
    });
    if (index2 != -1) {
      if (Math.random() > chance) {
        throw StateLog.removeFailed(stateClass);
      }
      this.states.splice(index2, 1);
    } else {
      throw StateLog.notApplied(stateClass);
    }
  }
  findStateEfficiency(stateClass) {
    return this.statesEfficiency.find((state) => isInstanceOf$2(state.state, stateClass));
  }
}
applyMixins$6(StateManager, [ItemFixture]);
const {
  isString: isString$6,
  isInstanceOf: isInstanceOf$1,
  applyMixins: applyMixins$5
} = Utils$2;
class ItemManager {
  constructor() {
    this.equipments = [];
  }
  /**
  * Retrieves the information of an object: the number and the instance
  * @title Get Item
  * @method player.getItem(itemClass)
  * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
  * @returns {{ nb: number, item: instance of ItemClass }}
  * @memberof ItemManager
  * @example
  *
  * ```ts
  * import Potion from 'your-database/potion'
  *
  * player.addItem(Potion, 5)
  * const inventory = player.getItem(Potion)
  * console.log(inventory) // { nb: 5, item: <instance of Potion> }
  *  ```
  */
  getItem(itemClass) {
    const index2 = this._getItemIndex(itemClass);
    return this.items[index2];
  }
  /**
   * Check if the player has the item in his inventory.
   * @title Has Item
   * @method player.hasItem(itemClass)
   * @param {ItemClass | string} itemClass Identifier of the object if the parameter is a string
   * @returns {boolean}
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * player.hasItem(Potion) // false
   *  ```
   */
  hasItem(itemClass) {
    return !!this.getItem(itemClass);
  }
  _getItemIndex(itemClass) {
    return this.items.findIndex((it2) => {
      if (isString$6(itemClass)) {
        return it2.item.id == itemClass;
      }
      return isInstanceOf$1(it2.item, itemClass);
    });
  }
  /**
   * Add an item in the player's inventory. You can give more than one by specifying `nb`
   *
   * `onAdd()` method is called on the ItemClass
   *
   * @title Add Item
   * @method player.addItem(item,nb=1)
   * @param {ItemClass} itemClass
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   * player.addItem(Potion, 5)
   *  ```
   */
  addItem(itemClass, nb = 1) {
    if (isString$6(itemClass))
      itemClass = this.databaseById(itemClass);
    let itemIndex = this._getItemIndex(itemClass);
    if (itemIndex != -1) {
      this.items[itemIndex].nb += nb;
    } else {
      const instance = new itemClass();
      this.items.push({
        item: instance,
        nb
      });
      itemIndex = this.items.length - 1;
    }
    const {
      item
    } = this.items[itemIndex];
    this["execMethod"]("onAdd", [this], item);
    return this.items[itemIndex];
  }
  /**
   * Deletes an item. Decreases the value `nb`. If the number falls to 0, then the item is removed from the inventory. The method then returns `undefined`
   *
   * `onRemove()` method is called on the ItemClass
   *
   * @title Remove Item
   * @method player.removeItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass } | undefined}
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *    player.removeItem(Potion, 5)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  removeItem(itemClass, nb = 1) {
    const itemIndex = this._getItemIndex(itemClass);
    if (itemIndex == -1) {
      throw ItemLog.notInInventory(itemClass);
    }
    const currentNb = this.items[itemIndex].nb;
    const {
      item
    } = this.items[itemIndex];
    if (currentNb - nb <= 0) {
      this.items.splice(itemIndex, 1);
    } else {
      this.items[itemIndex].nb -= nb;
    }
    this["execMethod"]("onRemove", [this], item);
    return this.items[itemIndex];
  }
  /**
   * Purchases an item and reduces the amount of gold
   *
   * `onAdd()` method is called on the ItemClass
   *
   * @title Buy Item
   * @method player.buyItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nb] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} haveNotPrice
   * If you have not set a price on the item
   *  ```
   * {
   *      id: NOT_PRICE,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notEnoughGold
   * If the player does not have enough money
   *  ```
   * {
   *      id: NOT_ENOUGH_GOLD,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *    player.buyItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  buyItem(itemClass, nb = 1) {
    if (isString$6(itemClass))
      itemClass = this.databaseById(itemClass);
    const ItemClass = itemClass;
    if (!ItemClass.price) {
      throw ItemLog.haveNotPrice(itemClass);
    }
    const totalPrice = nb * ItemClass.price;
    if (this.gold < totalPrice) {
      throw ItemLog.notEnoughGold(itemClass, nb);
    }
    this.gold -= totalPrice;
    return this.addItem(ItemClass, nb);
  }
  /**
   * Sell an item and the player wins the amount of the item divided by 2
   *
   * `onRemove()` method is called on the ItemClass
   *
   * @title Sell Item
   * @method player.sellItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [nbToSell] Default 1
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} haveNotPrice
   * If you have not set a price on the item
   *   ```
   * {
   *      id: NOT_PRICE,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} tooManyToSell
   * If the number of items for sale exceeds the number of actual items in the inventory
   *  ```
   * {
   *      id: TOO_MANY_ITEM_TO_SELL,
   *      msg: '...'
   * }
   * ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *     player.addItem(Potion)
   *     player.sellItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  sellItem(itemClass, nbToSell = 1) {
    if (isString$6(itemClass))
      itemClass = this.databaseById(itemClass);
    const ItemClass = itemClass;
    const inventory = this.getItem(ItemClass);
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    const {
      item,
      nb
    } = inventory;
    if (nb - nbToSell < 0) {
      throw ItemLog.tooManyToSell(itemClass, nbToSell, nb);
    }
    if (!ItemClass.price) {
      throw ItemLog.haveNotPrice(itemClass);
    }
    this.gold += ItemClass.price / 2 * nbToSell;
    this.removeItem(ItemClass, nbToSell);
    return inventory;
  }
  getParamItem(name2) {
    let nb = 0;
    for (let item of this.equipments) {
      nb += item[name2] || 0;
    }
    const modifier = this.paramsModifier[name2];
    if (modifier) {
      if (modifier.value)
        nb += modifier.value;
      if (modifier.rate)
        nb *= modifier.rate;
    }
    return nb;
  }
  /**
   * recover the attack sum of items equipped on the player.
   *
   * @title Get the player's attack
   * @prop {number} player.atk
   * @memberof ItemManager
   */
  get atk() {
    return this.getParamItem(ATK);
  }
  /**
  * recover the physic defense sum of items equipped on the player.
  *
  * @title Get the player's pdef
  * @prop {number} player.pdef
  * @memberof ItemManager
  */
  get pdef() {
    return this.getParamItem(PDEF);
  }
  /**
  * recover the skill defense sum of items equipped on the player.
  *
  * @title Get the player's sdef
  * @prop {number} player.sdef
  * @memberof ItemManager
  */
  get sdef() {
    return this.getParamItem(SDEF);
  }
  /**
   *  Use an object. Applies effects and states. Removes the object from the inventory then
   *
   * `onUse()` method is called on the ItemClass (If the use has worked)
   * `onRemove()` method is called on the ItemClass
   *
   * @title Use an Item
   * @method player.useItem(item,nb=1)
   * @param {ItemClass | string} itemClass string is item id
   * @returns {{ nb: number, item: instance of ItemClass }}
   * @throws {ItemLog} restriction
   * If the player has the `Effect.CAN_NOT_ITEM` effect
   *   ```
   * {
   *      id: RESTRICTION_ITEM,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notInInventory
   * If the object is not in the inventory, an exception is raised
   *  ```
   * {
   *      id: ITEM_NOT_INVENTORY,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} notUseItem
   * If the `consumable` property is on false
   *  ```
   * {
   *      id: NOT_USE_ITEM,
   *      msg: '...'
   * }
   * ```
   * @throws {ItemLog} chanceToUseFailed
   * Chance to use the item has failed. Chances of use is defined with `ItemClass.hitRate`
   *  ```
   * {
   *      id: USE_CHANCE_ITEM_FAILED,
   *      msg: '...'
   * }
   * ```
   * > the item is still deleted from the inventory
   *
   * `onUseFailed()` method is called on the ItemClass
   *
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Potion from 'your-database/potion'
   *
   * try {
   *     player.addItem(Potion)
   *     player.useItem(Potion)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  useItem(itemClass) {
    const inventory = this.getItem(itemClass);
    if (this.hasEffect(Effect.CAN_NOT_ITEM)) {
      throw ItemLog.restriction(itemClass);
    }
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    const {
      item
    } = inventory;
    if (item.consumable === false) {
      throw ItemLog.notUseItem(itemClass);
    }
    const hitRate = item.hitRate ?? 1;
    if (Math.random() > hitRate) {
      this.removeItem(itemClass);
      this["execMethod"]("onUseFailed", [this], item);
      throw ItemLog.chanceToUseFailed(itemClass);
    }
    this.applyEffect(item);
    this.applyStates(this, item);
    this["execMethod"]("onUse", [this], item);
    this.removeItem(itemClass);
    return inventory;
  }
  /**
   * Equips a weapon or armor on a player. Think first to add the item in the inventory with the `addItem()` method before equipping the item.
   *
   * `onEquip()` method is called on the ItemClass
   *
   * @title Equip Weapon or Armor
   * @method player.equip(itemClass,equip=true)
   * @param {ItemClass | string} itemClass string is item id
   * @param {number} [equip] Equip the object if true or un-equipped if false
   * @returns {void}
   * @throws {ItemLog} notInInventory
   * If the item is not in the inventory
   *  ```
      {
          id: ITEM_NOT_INVENTORY,
          msg: '...'
      }
      ```
   * @throws {ItemLog} invalidToEquiped
      If the item is not by a weapon or armor
      ```
      {
          id: INVALID_ITEM_TO_EQUIP,
          msg: '...'
      }
      ```
  * @throws {ItemLog} isAlreadyEquiped
      If the item Is already equipped
      ```
      {
          id: ITEM_ALREADY_EQUIPED,
          msg: '...'
      }
      ```
   * @memberof ItemManager
   * @example
   *
   * ```ts
   * import Sword from 'your-database/sword'
   *
   * try {
   *      player.addItem(Sword)
   *      player.equip(Sword)
   * }
   * catch (err) {
   *    console.log(err)
   * }
   * ```
   */
  equip(itemClass, equip = true) {
    const inventory = this.getItem(itemClass);
    if (!inventory) {
      throw ItemLog.notInInventory(itemClass);
    }
    if (itemClass._type == "item") {
      throw ItemLog.invalidToEquiped(itemClass);
    }
    if (this._class && this._class[ClassHooks.canEquip]) {
      const canEquip = this["execMethodSync"](ClassHooks.canEquip, [inventory.item, this], this._class);
      if (!canEquip) {
        throw ItemLog.canNotEquip(itemClass);
      }
    }
    const item = inventory.item;
    if (item.equipped && equip) {
      throw ItemLog.isAlreadyEquiped(itemClass);
    }
    item.equipped = equip;
    if (!equip) {
      const index2 = this.equipments.findIndex((it2) => it2.id == item.id);
      this.equipments.splice(index2, 1);
    } else {
      this.equipments.push(item);
    }
    this["execMethod"]("onEquip", [this, equip], item);
  }
}
applyMixins$5(ItemManager, [GoldManager, StateManager, EffectManager]);
const {
  isArray: isArray$4,
  isString: isString$5,
  isInstanceOf,
  applyMixins: applyMixins$4
} = Utils$2;
class SkillManager {
  _getSkillIndex(skillClass) {
    return this.skills.findIndex((skill) => {
      if (isString$5(skill)) {
        return skill.id == skillClass;
      }
      if (isString$5(skillClass)) {
        return skillClass == (skill.id || skill);
      }
      return isInstanceOf(skill, skillClass);
    });
  }
  /**
   * Retrieves a learned skill. Returns null, if not found
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * player.getSkill(Fire)
   *  ```
   *
   * @title Get Skill
   * @method player.getSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @returns {instance of SkillClass | null}
   * @memberof SkillManager
   */
  getSkill(skillClass) {
    const index2 = this._getSkillIndex(skillClass);
    return this.skills[index2] ?? null;
  }
  /**
   * Learn a skill. Attributes the coefficient 1 to the parameter INT (intelligence) if cd is not present on the class.
   *
   * `onLearn()` method is called on the SkillClass
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * player.learnSkill(Fire)
   *  ```
   *
   * @title Learn Skill
   * @method player.learnSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @throws {SkillLog} alreadyLearned
   *  If the player already knows the skill
   *  ```
      {
          id: SKILL_ALREADY_LEARNED,
          msg: '...'
      }
      ```
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   */
  learnSkill(skillClass) {
    if (this.getSkill(skillClass)) {
      throw SkillLog.alreadyLearned(skillClass);
    }
    if (isString$5(skillClass))
      skillClass = this.databaseById(skillClass);
    const instance = new skillClass();
    this.skills.push(instance);
    this["execMethod"]("onLearn", [this], instance);
    return instance;
  }
  /**
   * Forget a skill
   *
   * `onForget()` method is called on the SkillClass
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.forgetSkill(Fire)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Forget Skill
   * @method player.learnSkill(skillClass)
   * @param {SkillClass | string} skillClass or data id
   * @throws {SkillLog} notLearned
   * If trying to forget a skill not learned
   *  ```
   * {
   *      id: SKILL_NOT_LEARNED,
   *      msg: '...'
   * }
   * ```
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   */
  forgetSkill(skillClass) {
    if (isString$5(skillClass))
      skillClass = this.databaseById(skillClass);
    const index2 = this._getSkillIndex(skillClass);
    if (index2 == -1) {
      throw SkillLog.notLearned(skillClass);
    }
    const instance = this.skills[index2];
    this.skills.splice(index2, 1);
    this["execMethod"]("onForget", [this], instance);
    return instance;
  }
  /**
   * Using a skill
   *
   * `onUse()` method is called on the SkillClass
   *
   * If other players are indicated then damage will be done to these other players. The method `applyDamage()` will be executed
   *
   * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.useSkill(Fire)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * or
   *
   *
   * * ```ts
   * import Fire from 'your-database/skills/fire'
   *
   * try {
   *      player.useSkill(Fire, otherPlayer)
   * }
   * catch (err) {
   *      console.log(err)
   * }
   *  ```
   *
   * @title Use Skill
   * @method player.useSkill(skillClass,otherPlayer)
   * @param {SkillClass | string} skillClass or data id
   * @param {Array<RpgPlayer> | RpgPlayer} [otherPlayer]
   * @throws {SkillLog} restriction
   * If the player has the `Effect.CAN_NOT_SKILL` effect
   *  ```
   * {
   *      id: RESTRICTION_SKILL,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} notLearned
   * If the player tries to use an unlearned skill
   *  ```
   * {
   *      id: SKILL_NOT_LEARNED,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} notEnoughSp
   * If the player does not have enough SP to use the skill
   *  ```
   * {
   *      id: NOT_ENOUGH_SP,
   *      msg: '...'
   * }
   * ```
   * @throws {SkillLog} chanceToUseFailed
   * If the chance to use the skill has failed (defined with the `hitRate` property)
   *  ```
   * {
   *      id: USE_CHANCE_SKILL_FAILED,
   *      msg: '...'
   * }
   * ```
   *
   * `onUseFailed()` method is called on the SkillClass
   *
   * @returns {instance of SkillClass}
   * @memberof SkillManager
   * @todo
   */
  useSkill(skillClass, otherPlayer) {
    const skill = this.getSkill(skillClass);
    if (this.hasEffect(Effect.CAN_NOT_SKILL)) {
      throw SkillLog.restriction(skillClass);
    }
    if (!skill) {
      throw SkillLog.notLearned(skillClass);
    }
    if (skill.spCost > this.sp) {
      throw SkillLog.notEnoughSp(skillClass, skill.spCost, this.sp);
    }
    this.sp -= skill.spCost / (this.hasEffect(Effect.HALF_SP_COST) ? 2 : 1);
    const hitRate = skill.hitRate ?? 1;
    if (Math.random() > hitRate) {
      this["execMethod"]("onUseFailed", [this, otherPlayer], skill);
      throw SkillLog.chanceToUseFailed(skillClass);
    }
    if (otherPlayer) {
      let players = otherPlayer;
      if (!isArray$4(players)) {
        players = [otherPlayer];
      }
      for (let player2 of players) {
        this.applyStates(player2, skill);
        player2.applyDamage(this, skill);
      }
    }
    this["execMethod"]("onUse", [this, otherPlayer], skill);
    return skill;
  }
}
applyMixins$4(SkillManager, [ParameterManager, StateManager, EffectManager]);
const {
  applyMixins: applyMixins$3,
  isString: isString$4
} = Utils$2;
class ClassManager {
  /**
   * Assign a class to the player
   *
   * ```ts
   * import { Fighter } from 'my-database/classes/fighter'
   *
   * player.setClass(Fighter)
   * ```
   *
   * @title Set Class
   * @method player.setClass(ClassClass)
   * @param {ClassClass | string} class class or id
   * @returns {instance of ClassClass}
   * @memberof ClassManager
   * */
  setClass(_class) {
    if (isString$4(_class))
      _class = this.databaseById(_class);
    this._class = new _class();
    this["execMethod"]("onSet", [this], this._class);
    return this._class;
  }
  /**
   * Allows to give a set of already defined properties to the player (default equipment, or a list of skills to learn according to the level)
   *
   * ```ts
   * import { Hero } from 'my-database/classes/hero'
   *
   * player.setActor(Hero)
   * ```
   *
   * @title Set Actor
   * @method player.setActor(ActorClass)
   * @param {ActorClass | string} actorClass actor class or id
   * @returns {instance of ActorClass}
   * @memberof ClassManager
   * */
  setActor(actorClass) {
    if (isString$4(actorClass))
      actorClass = this.databaseById(actorClass);
    const actor = new actorClass();
    ["name", "initialLevel", "finalLevel", "expCurve"].forEach((key) => {
      if (actor[key])
        this[key] = actor[key];
    });
    for (let param in actor.parameters) {
      this.addParameter(param, actor.parameters[param]);
    }
    for (let item of actor.startingEquipment) {
      this.addItem(item);
      this.equip(item, true);
    }
    if (actor.class)
      this.setClass(actor.class);
    this["execMethod"]("onSet", [this], actor);
    return actor;
  }
}
applyMixins$3(ClassManager, [ParameterManager, ItemManager]);
const {
  arrayUniq,
  applyMixins: applyMixins$2
} = Utils$2;
class ElementManager extends ItemFixture {
  /**
  * Recovers the player's elements defense on inventory.  This list is generated from the `elementsDefense` property defined on the weapons or armors equipped.
  * If several items have the same element, only the highest rate will be taken into account.
  *
  * ```ts
  * import { Armor } from '@rpgjs/server'
  *
  * enum Elements {
  *   Fire = 'fire'
  * }
  *
  * @Armor({
  *      name: 'Shield',
  *      elementsDefense: [{ rate: 1, element: Elements.Fire }]
  * })
  * class Shield {}
  *
  * @Armor({
  *      name: 'FireShield',
  *      elementsDefense: [{ rate: 0.5, element: Elements.Fire }]
  * })
  * class FireShield {}
  *
  * player.addItem(Shield)
  * player.addItem(FireShield)
  * player.equip(Shield)
  * player.equip(FireShield)
  *
  * console.log(player.elementsDefense) // [{ rate: 1, element: 'fire' }]
  * ```
  * @title Get Elements Defense
  * @prop {Array<{ rate: number, element: Element}>} player.elementsDefense
  * @readonly
  * @memberof ElementManager
  * */
  get elementsDefense() {
    return this.getFeature("elementsDefense", "element");
  }
  /**
  * Set or retrieves all the elements where the player is vulnerable or not.
  *
  * ```ts
  * import { Class } from '@rpgjs/server'
  *
  * enum Elements {
  *   Fire = 'fire',
  *   Ice = 'ice'
  * }
  *
  * @Class({
  *      name: 'Fighter',
  *      elementsEfficiency: [{ rate: 1, element: Elements.Fire }]
  * })
  * class Hero {}
  *
  * player.setClass(Hero)
  *
  * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }]
  *
  * player.elementsEfficiency = [{ rate: 2, element: Elements.Ice }]
  *
  * console.log(player.elementsEfficiency) // [{ rate: 1, element: 'fire' }, { rate: 2, element: 'ice' }]
  * ```
  * @title Set/Get Elements Efficiency
  * @prop {Array<{ rate: number, element: Element}>} player.elementsEfficiency
  * @memberof ElementManager
  * */
  get elementsEfficiency() {
    if (this._class) {
      return [...this._elementsEfficiency, ...this._class.elementsEfficiency];
    }
    return this._elementsEfficiency;
  }
  set elementsEfficiency(val) {
    this._elementsEfficiency = val;
  }
  /**
   * Retrieves a array of elements assigned to the player and the elements of the weapons / armor equipped
   *
   * ```ts
   * console.log(player.elements)
   * ```
   * @title Get Elements
   * @prop {Array<Element>} player.elements
   * @readonly
   * @memberof ElementManager
   * */
  get elements() {
    let elements = [];
    for (let item of this.equipments) {
      if (item.elements) {
        elements = [...elements, ...item.elements];
      }
    }
    return arrayUniq(elements);
  }
  coefficientElements(otherPlayer) {
    const atkPlayerElements = otherPlayer.elements;
    const playerElements = this.elementsEfficiency;
    let coefficient = 1;
    for (let atkElement of atkPlayerElements) {
      const elementPlayer = playerElements.find((el) => el.element == atkElement.element);
      const elementPlayerDef = this.elementsDefense.find((el) => el.element == atkElement.element);
      if (!elementPlayer)
        continue;
      const fn = this.getFormulas("coefficientElements");
      if (!fn) {
        return coefficient;
      }
      coefficient += fn(atkElement, elementPlayer, elementPlayerDef || {
        rate: 0
      });
    }
    return coefficient;
  }
}
applyMixins$2(ElementManager, [ItemFixture]);
let Gui$1 = class Gui extends EventEmitter$1 {
  constructor(id, player2) {
    super();
    this.id = id;
    this.player = player2;
    this._close = () => {
    };
    this._blockPlayerInput = false;
  }
  open(data, {
    waitingAction = false,
    blockPlayerInput = false
  } = {}) {
    return new Promise((resolve2) => {
      this.player.moving = false;
      this.player.emit("gui.open", {
        guiId: this.id,
        data
      });
      this._blockPlayerInput = blockPlayerInput;
      if (blockPlayerInput) {
        this.player.canMove = false;
      }
      if (!waitingAction) {
        resolve2(null);
      } else {
        this._close = resolve2;
      }
    });
  }
  close(data) {
    this.player.emit("gui.exit", this.id);
    if (this._blockPlayerInput) {
      this.player.canMove = true;
    }
    this._close(data);
  }
};
const {
  arrayFlat,
  random,
  isFunction: isFunction$3,
  capitalize: capitalize$2
} = Utils$2;
function wait(sec) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, sec * 1e3);
  });
}
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["Lowest"] = 600] = "Lowest";
  Frequency2[Frequency2["Lower"] = 400] = "Lower";
  Frequency2[Frequency2["Low"] = 200] = "Low";
  Frequency2[Frequency2["High"] = 100] = "High";
  Frequency2[Frequency2["Higher"] = 50] = "Higher";
  Frequency2[Frequency2["Highest"] = 25] = "Highest";
  Frequency2[Frequency2["None"] = 0] = "None";
})(Frequency || (Frequency = {}));
var Speed;
(function(Speed2) {
  Speed2[Speed2["Slowest"] = 0.2] = "Slowest";
  Speed2[Speed2["Slower"] = 0.5] = "Slower";
  Speed2[Speed2["Slow"] = 1] = "Slow";
  Speed2[Speed2["Normal"] = 3] = "Normal";
  Speed2[Speed2["Fast"] = 5] = "Fast";
  Speed2[Speed2["Faster"] = 7] = "Faster";
  Speed2[Speed2["Fastest"] = 10] = "Fastest";
})(Speed || (Speed = {}));
class MoveList {
  repeatMove(direction, repeat) {
    return new Array(repeat).fill(direction);
  }
  repeatTileMove(direction, repeat, propMap) {
    return (player2, map2) => {
      const repeatTile = Math.floor(map2[propMap] / player2.speed) * repeat;
      return this[direction](repeatTile);
    };
  }
  right(repeat = 1) {
    return this.repeatMove(Direction.Right, repeat);
  }
  left(repeat = 1) {
    return this.repeatMove(Direction.Left, repeat);
  }
  up(repeat = 1) {
    return this.repeatMove(Direction.Up, repeat);
  }
  down(repeat = 1) {
    return this.repeatMove(Direction.Down, repeat);
  }
  wait(sec) {
    return wait(sec);
  }
  random(repeat = 1) {
    return new Array(repeat).fill(null).map(() => [Direction.Right, Direction.Left, Direction.Up, Direction.Down][random(0, 3)]);
  }
  tileRight(repeat = 1) {
    return this.repeatTileMove("right", repeat, "tileWidth");
  }
  tileLeft(repeat = 1) {
    return this.repeatTileMove("left", repeat, "tileWidth");
  }
  tileUp(repeat = 1) {
    return this.repeatTileMove("up", repeat, "tileHeight");
  }
  tileDown(repeat = 1) {
    return this.repeatTileMove("down", repeat, "tileHeight");
  }
  tileRandom(repeat = 1) {
    return (player2, map2) => {
      let directions2 = [];
      for (let i2 = 0; i2 < repeat; i2++) {
        const randFn = [this.tileRight(), this.tileLeft(), this.tileUp(), this.tileDown()][random(0, 3)];
        directions2 = [...directions2, ...randFn(player2, map2)];
      }
      return directions2;
    };
  }
  _awayFromPlayerDirection(player2, otherPlayer) {
    const directionOtherPlayer = otherPlayer.getDirection();
    let newDirection = 0;
    switch (directionOtherPlayer) {
      case Direction.Left:
      case Direction.Right:
        if (otherPlayer.position.x > player2.position.x) {
          newDirection = Direction.Left;
        } else {
          newDirection = Direction.Right;
        }
        break;
      case Direction.Up:
      case Direction.Down:
        if (otherPlayer.position.y > player2.position.y) {
          newDirection = Direction.Up;
        } else {
          newDirection = Direction.Down;
        }
        break;
    }
    return newDirection;
  }
  _towardPlayerDirection(player2, otherPlayer) {
    const directionOtherPlayer = otherPlayer.getDirection();
    let newDirection = 0;
    switch (directionOtherPlayer) {
      case Direction.Left:
      case Direction.Right:
        if (otherPlayer.position.x > player2.position.x) {
          newDirection = Direction.Right;
        } else {
          newDirection = Direction.Left;
        }
        break;
      case Direction.Up:
      case Direction.Down:
        if (otherPlayer.position.y > player2.position.y) {
          newDirection = Direction.Down;
        } else {
          newDirection = Direction.Up;
        }
        break;
    }
    return newDirection;
  }
  _awayFromPlayer({
    isTile,
    typeMov
  }, otherPlayer, repeat = 1) {
    const method = (dir) => {
      const direction = LiteralDirection[dir];
      return this[isTile ? "tile" + capitalize$2(direction) : direction](repeat);
    };
    return (player2, map2) => {
      let newDirection = 0;
      switch (typeMov) {
        case "away":
          newDirection = this._awayFromPlayerDirection(player2, otherPlayer);
          break;
        case "toward":
          newDirection = this._towardPlayerDirection(player2, otherPlayer);
          break;
      }
      let direction = method(newDirection);
      if (isFunction$3(direction)) {
        direction = direction(player2, map2);
      }
      return direction;
    };
  }
  towardPlayer(player2, repeat = 1) {
    return this._awayFromPlayer({
      isTile: false,
      typeMov: "toward"
    }, player2, repeat);
  }
  tileTowardPlayer(player2, repeat = 1) {
    return this._awayFromPlayer({
      isTile: true,
      typeMov: "toward"
    }, player2, repeat);
  }
  awayFromPlayer(player2, repeat = 1) {
    return this._awayFromPlayer({
      isTile: false,
      typeMov: "away"
    }, player2, repeat);
  }
  tileAwayFromPlayer(player2, repeat = 1) {
    return this._awayFromPlayer({
      isTile: true,
      typeMov: "away"
    }, player2, repeat);
  }
  turnLeft() {
    return "turn-" + Direction.Left;
  }
  turnRight() {
    return "turn-" + Direction.Right;
  }
  turnUp() {
    return "turn-" + Direction.Up;
  }
  turnDown() {
    return "turn-" + Direction.Down;
  }
  turnRandom() {
    return [this.turnRight(), this.turnLeft(), this.turnUp(), this.turnDown()][random(0, 3)];
  }
  turnAwayFromPlayer(otherPlayer) {
    return (player2) => {
      const direction = this._awayFromPlayerDirection(player2, otherPlayer);
      return "turn-" + direction;
    };
  }
  turnTowardPlayer(otherPlayer) {
    return (player2) => {
      const direction = this._towardPlayerDirection(player2, otherPlayer);
      return "turn-" + direction;
    };
  }
}
const Move = new MoveList();
class MoveManager {
  /**
   * Gives an itinerary.
   *
   * You can create your own motion function:
   *
   * ```ts
   * import { Direction } from '@rpgjs/server'
   *
   * const customMove = () => {
   *      return [Direction.Left, Direction.Up]
   * }
   *
   * player.moveRoutes([ customMove() ])
   * ```
   *
   * Your function can also return a function:
   *
   *  ```ts
   * import { Direction, RpgPlayer } from '@rpgjs/server'
   *
   * // This function can be found in another file. By returning a function, you have access to the player who is making a move.
   * const customMove = (otherPlayer: RpgPlayer) => {
   *      return (player: RpgPlayer, map) => {
   *          return otherPlayer.position.x > player.position.x ? Direction.Left : Direction.Right
   *      }
   * }
   *
   * player.moveRoutes([ customMove(otherPlayer) ])
   * ```
   *
   * the function contains two parameters:
   *
   * - `player`: the player concerned by the movement
   * - `map`: The information of the current map
   *
   * @title Give an itinerary
   * @method player.moveRoutes(routes)
   * @param {Array<Move>} routes
   * @returns {Promise}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * await player.moveRoutes([ Move.tileLeft(), Move.tileDown(2) ])
   * // The path is over when the promise is resolved
   * ```
   */
  moveRoutes(routes) {
    let count = 0;
    let frequence = 0;
    this.breakRoutes();
    return new Promise(async (resolve2) => {
      this._finishRoute = resolve2;
      routes = routes.map((route) => {
        if (isFunction$3(route)) {
          const map2 = this.getCurrentMap();
          if (!map2) {
            return void 0;
          }
          return route.apply(route, [this, map2]);
        }
        return route;
      });
      routes = arrayFlat(routes);
      const move = () => {
        if (!this) {
          return of(null);
        }
        if (!this.getCurrentMap()) {
          return of(null);
        }
        if (count >= this["nbPixelInTile"]) {
          if (frequence < this.frequency) {
            frequence++;
            return of(null);
          }
        }
        frequence = 0;
        count++;
        const [route] = routes;
        if (route === void 0) {
          this.breakRoutes();
          return of(null);
        }
        let ob$ = new Observable$1();
        switch (route) {
          case Direction.Left:
          case Direction.Down:
          case Direction.Right:
          case Direction.Up:
            ob$ = from(this.moveByDirection(route, 1));
            break;
          case "turn-" + Direction.Left:
            ob$ = of(this.changeDirection(Direction.Left));
            break;
          case "turn-" + Direction.Right:
            ob$ = of(this.changeDirection(Direction.Right));
            break;
          case "turn-" + Direction.Up:
            ob$ = of(this.changeDirection(Direction.Up));
            break;
          case "turn-" + Direction.Down:
            ob$ = of(this.changeDirection(Direction.Down));
            break;
        }
        return ob$.pipe(tap(() => {
          routes.shift();
        }));
      };
      this.movingSubscription = this.server.tick.pipe(takeUntil(this._destroy$.pipe(tap(() => {
        this.breakRoutes(true);
      }))), switchMap(move)).subscribe();
    });
  }
  /**
   * Giving a path that repeats itself in a loop to a character
   *
   * You can stop the movement at any time with `breakRoutes()` and replay it with `replayRoutes()`.
   *
   * @title Infinite Move Routes
   * @method player.infiniteMoveRoute(routes)
   * @param {Array<Move>} routes
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * ```
   */
  infiniteMoveRoute(routes) {
    this._infiniteRoutes = routes;
    const move = (isBreaking) => {
      if (isBreaking)
        return;
      this.moveRoutes(routes).then(move);
    };
    move(false);
  }
  /**
   * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
   *
   * @title Stop an infinite movement
   * @method player.breakRoutes(force=false)
   * @param {boolean} [force] Forces the stop of the infinite movement
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * player.breakRoutes(true)
   * ```
   */
  breakRoutes(force = false) {
    var _a;
    if (this._finishRoute) {
      (_a = this.movingSubscription) == null ? void 0 : _a.unsubscribe();
      this._finishRoute(force);
    }
  }
  /**
   * Works only for infinite movements. You must first use the method `infiniteMoveRoute()`
   * If the road was stopped with `breakRoutes()`, you can restart it with this method
   *
   * @title Replay an infinite movement
   * @method player.replayRoutes()
   * @returns {void}
   * @memberof MoveManager
   * @example
   *
   * ```ts
   * import { Move } from '@rpgjs/server'
   *
   * player.infiniteMoveRoute([ Move.tileRandom() ])
   * player.breakRoutes(true)
   * player.replayRoutes()
   * ```
   */
  replayRoutes() {
    if (this._infiniteRoutes)
      this.infiniteMoveRoute(this._infiniteRoutes);
  }
  moveTo(position, options2) {
    return this["_moveTo"](this.server.tick, position, options2);
  }
  // TODO
  setMoveMode(mode) {
    if (mode.checkCollision)
      this.checkCollision = mode.checkCollision;
    if (mode.clientMode)
      this.clientModeMove = mode.clientMode;
    if (mode.behavior)
      this.behavior = mode.behavior;
    this.emit(SocketEvents.CallMethod, {
      objectId: this.id,
      name: SocketMethods.ModeMove,
      params: [mode]
    });
  }
}
var DialogPosition;
(function(DialogPosition2) {
  DialogPosition2["Top"] = "top";
  DialogPosition2["Bottom"] = "bottom";
  DialogPosition2["Middle"] = "middle";
})(DialogPosition || (DialogPosition = {}));
class DialogGui extends Gui$1 {
  constructor(player2) {
    super(PrebuiltGui.Dialog, player2);
  }
  openDialog(message, options2) {
    if (!options2.choices)
      options2.choices = [];
    if (options2.autoClose == void 0)
      options2.autoClose = false;
    if (!options2.position)
      options2.position = DialogPosition.Bottom;
    if (options2.fullWidth == void 0)
      options2.fullWidth = true;
    if (options2.typewriterEffect == void 0)
      options2.typewriterEffect = true;
    const event = options2.talkWith;
    let memoryDir;
    if (event) {
      memoryDir = event.direction;
      event.breakRoutes(true);
      event.moveRoutes([Move.turnTowardPlayer(this.player)]);
    }
    const data = {
      autoClose: options2.autoClose,
      position: options2.position,
      fullWidth: options2.fullWidth,
      typewriterEffect: options2.typewriterEffect,
      // remove value property. It is not useful to know this on the client side.
      choices: options2.choices.map((choice) => ({
        text: choice.text
      }))
    };
    return super.open({
      message,
      ...data
    }, {
      waitingAction: true,
      blockPlayerInput: true
    }).then((val) => {
      if (event) {
        event.replayRoutes();
        event.direction = memoryDir;
      }
      return val;
    });
  }
}
class MenuGui extends Gui$1 {
  constructor(player2) {
    super(PrebuiltGui.MainMenu, player2);
  }
  open() {
    this.on("useItem", (id) => {
      try {
        this.player.useItem(id);
        this.player.syncChanges();
      } catch (err) {
        this.player.showNotification(err.msg);
      }
    });
    return super.open("", {
      waitingAction: true,
      blockPlayerInput: true
    });
  }
}
class ShopGui extends Gui$1 {
  constructor(player2) {
    super(PrebuiltGui.Shop, player2);
  }
  open(items) {
    items = items.map((item) => {
      const it2 = new item();
      return {
        price: it2.price,
        name: it2.name,
        description: it2.description,
        id: it2.id,
        type: item.type
      };
    });
    this.on("buyItem", ({
      id,
      nb
    }) => {
      try {
        this.player.buyItem(id, nb);
      } catch (err) {
        console.log(err);
      }
    });
    this.on("sellItem", ({
      id,
      nb
    }) => {
      try {
        this.player.sellItem(id, nb);
      } catch (err) {
        console.log(err);
      }
    });
    return super.open({
      items
    }, {
      waitingAction: true,
      blockPlayerInput: true
    });
  }
}
class NotificationGui extends Gui$1 {
  constructor(player2) {
    super(PrebuiltGui.Notification, player2);
  }
}
class GuiManager {
  /**
   * Show a text. This is a graphical interface already built. Opens the GUI named `rpg-dialog`
   *
   * ```ts
   * player.showText('Hello World')
   * ```
   *
   * The method returns a promise. It is resolved when the dialog box is closed.
   *
   * ```ts
   * await player.showText('Hello World')
   * // dialog box is closed, then ...
   * ```
   *
   * **Option: position**
   *
   * You can define how the dialog box is displayed:
   * - top
   * - middle
   * - bottom
   *
   * (bottom by default)
   *
   * ```ts
   * player.showText('Hello World', {
   *      position: 'top'
   * })
   * ```
   *
   * **Option: fullWidth**
   *
   * `boolean` (true by default)
   *
   * Indicate that the dialog box will take the full width of the screen.
   *
   * ```ts
   * player.showText('Hello World', {
   *      fullWidth: true
   * })
   * ```
   *
   * **Option: autoClose**
   *
   * `boolean` (false by default)
   *
   * If false, the user will have to press Enter to close the dialog box.
   *
   *  ```ts
   * player.showText('Hello World', {
   *      autoClose: true
   * })
   * ```
   *
   * **Option: typewriterEffect**
   *
   * `boolean` (true by default)
   *
   * Performs a typewriter effect
   *
   *  ```ts
   * player.showText('Hello World', {
   *      typewriterEffect: false
   * })
   * ```
   *
   * **Option: talkWith**
   *
   * `RpgPlayer` (nothing by default)
   *
   * If you specify the event or another player, the other player will stop his or her movement and look in the player's direction.
   *
   *  ```ts
   * // Code in an event
   * player.showText('Hello World', {
   *      talkWith: this
   * })
   * ```
   *
   * @title Show Text
   * @method player.showText(text,options)
   * @param {string} text
   * @param {object} [options] the different options, see usage below
   * @returns {Promise}
   * @memberof GuiManager
   */
  showText(msg, options2 = {}) {
    const gui = new DialogGui(this);
    this._gui[gui.id] = gui;
    return gui.openDialog(msg, options2);
  }
  /**
   * Shows a dialog box with a choice. Opens the GUI named `rpg-dialog`
   *
   * ```ts
   * const choice = await player.showChoices('What color do you prefer?', [
   *      { text: 'Black', value: 'black' },
   *      { text: 'Rather the blue', value: 'blue' },
   *      { text: 'I don\'t have a preference!', value: 'none' }
   * ])
   *
   * // If the player selects the first
   * console.log(choice) // { text: 'Black', value: 'black' }
   * ```
   *
   * @title Show Choices
   * @method player.showChoices(text,choices)
   * @param {string} text
   * @param {Array<{ text: string, value: any }>} choices
   * @param {object} [options] Same options as the openDialog method
   * @returns {Promise<Choice | null>}
   * @memberof GuiManager
   */
  showChoices(msg, choices, options2) {
    return this.showText(msg, {
      choices,
      ...options2
    }).then((indexSelected) => {
      if (!choices[indexSelected])
        return null;
      return choices[indexSelected];
    });
  }
  /**
   * Displays a notification . Opens the GUI named `rpg-notification`
   *
   * @title Displays a notification
   * @method player.showNotification()
   * @param {string} message - The message to display in the notification
   * @param {object} options - An object containing options for the notification
   * @param {number} options.time - The time to display the notification for (in ms). Default: 2000ms
   * @param {string} options.icon - The icon to display in the notification. Put the identifier of the spritesheet (defined on the client side)
   * @param {string} options.sound - The sound to play when the notification is shown. Set the sound ID (defined on the client side)
   * @returns {void}
   * @memberof GuiManager
   */
  showNotification(message, options2 = {}) {
    const gui = new NotificationGui(this);
    this._gui[gui.id] = gui;
    const data = {
      message,
      ...options2
    };
    return gui.open(data);
  }
  /**
   * Calls main menu. Opens the GUI named `rpg-main-menu`
   *
   * @title Call Main Menu
   * @method player.callMainMenu()
   * @returns {void}
   * @memberof GuiManager
   */
  callMainMenu() {
    const gui = new MenuGui(this);
    this._gui[gui.id] = gui;
    return gui.open();
  }
  /**
   * Calls shop menu. Opens the GUI named `rpg-shop`
   *
   * @title Call Shop Menu
   * @method player.callShop()
   * @returns {void}
   * @memberof GuiManager
   */
  callShop(items) {
    const gui = new ShopGui(this);
    this._gui[gui.id] = gui;
    return gui.open(items);
  }
  /**
   * Call a custom Gui
    * ```ts
   * // Calls a client-side component, created with VueJS, named "inn".
   * const gui = player.gui('inn')
   *
   *  // You can wait for actions on the menu. It only works if the menu is open.
   * gui.on('accept', () => {
   *      player.allRecovery()
   * })
   *
   * // The GUI is opened by passing recoverable data on the client side.
   * gui.open({ hello: 'world' })
   * ```
   *
   * When opening the GUI, one can give options
   *
   * ```ts
   * await gui.open({ hello: 'world' }, {
   *      waitingAction: true,
   *      blockPlayerInput: true
   * })
   * // After the GUI is closed
   * ```
   *
   * - `blockPlayerInput`: while the GUI is open, the player can not move on the map
   * - `waitingAction`: We explicitly wait until the GUI is closed for the promise to be resolved.
   *
   * @title Call custom GUI
   * @method player.gui(guiId)
   * @param {string} guiId
   * @returns {Gui}
   * @memberof GuiManager
   */
  gui(guiId) {
    const gui = new Gui$1(guiId, this);
    this._gui[guiId] = gui;
    return gui;
  }
  /**
   * Closes the GUI and removes it from memory
   *
   * @title Close custom GUI
   * @method player.removeGui(guiId,data)
   * @param {string} guiId
   * @param {object} [data] Passing data if you close the GUI
   * @returns {Gui}
   * @memberof GuiManager
   */
  removeGui(guiId, data) {
    if (this._gui[guiId]) {
      this._gui[guiId].close(data);
      delete this._gui[guiId];
    }
  }
  _attachedGui(players, display) {
    if (!isArray$d(players)) {
      players = [players];
    }
    this.emit("gui.tooltip", {
      players: players.map((player2) => player2.id),
      display
    });
  }
  /**
   * Display the GUI attached to the players
   *
   * If you don't specify the players as parameters, it will display the GUI of the instance
   * But you can specify which GUIs to display by specifying the players as the first parameter
   *
   * @title View to GUI attached
   * @method player.showAttachedGui(players?)
   * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to display
   * @since 3.0.0-beta.5
   * @example
   * ```ts
   * player.showAttachedGui()
   * ```
   * ```ts
   * player.showAttachedGui(aPlayer)
   * ```
   * ```ts
   * player.showAttachedGui([player1, player2])
   * ```
   * @memberof GuiManager
   * */
  showAttachedGui(players) {
    const _players = players || this;
    this._attachedGui(_players, true);
  }
  /**
   * Hide the GUI attached to the players
   *
   * @title Hide to GUI attached
   * @method player.hideAttachedGui(players?)
   * @param {RpgPlayer[] | RpgPlayer} [players] The GUIs attached to the players to hide
   * @since 3.0.0-beta.5
   * @example
   * ```ts
   * player.hideAttachedGui()
   * ```
   * ```ts
   * player.hideAttachedGui(aPlayer)
   * ```
   * ```ts
   * player.hideAttachedGui([player1, player2])
   * ```
   * @memberof GuiManager
   * */
  hideAttachedGui(players) {
    const _players = players || this;
    this._attachedGui(_players, false);
  }
}
class VariableManager {
  /**
   * Assign a variable to the player
   *
   * ```ts
   * player.setVariable('OPEN_CHEST', true)
   * ```
   *
   * @title Set variable
   * @method player.setVariable(key,val)
   * @param {string} key
   * @param {any} val
   * @returns {void}
   * @memberof VariableManager
   * */
  setVariable(key, val) {
    this.variables.set(key, val);
  }
  /**
   * Get a variable
   *
   * ```ts
   * const val = player.getVariable('OPEN_CHEST')
   * ```
   *
   * @title Get variable
   * @method player.setVariable(key,val)
   * @param {string} key
   * @returns {any}
   * @memberof VariableManager
   * */
  getVariable(key) {
    return this.variables.get(key);
  }
  /**
   * Remove a variable
   *
   * ```ts
   * player.removeVariable('OPEN_CHEST')
   * ```
   *
   * @title Remove variable
   * @method player.removeVariable(key)
   * @param {string} key
   * @returns {boolean} true if a variable existed and has been removed, or false if the variable does not exist.
   * @memberof VariableManager
   * */
  removeVariable(key) {
    return this.variables.delete(key);
  }
}
const {
  applyMixins: applyMixins$1
} = Utils$2;
class BattleManager {
  /**
   * Apply damage. Player will lose HP. the `attackerPlayer` parameter is the other player, the one who attacks.
   *
   * If you don't set the skill parameter, it will be a physical attack.
   * The attack formula is already defined but you can customize it in the server options
   *
   * ```ts
   * player.applyDamage(attackerPlayer) // returns { damage: number }
   * ```
   *
   * @title Apply Damage
   * @method player.applyDamage(attackerPlayer,skill)
   * @param {RpgPlayer} attackerPlayer The attacking player
   * @param {any} [skill]
   * @returns {object}
   * @memberof BattleManager
   * */
  applyDamage(attackerPlayer, skill) {
    const getParam = (player2) => {
      const params = {};
      this.parameters.forEach((val, key) => {
        params[key] = player2.param[key];
      });
      return {
        [ATK]: player2.atk,
        [PDEF]: player2.pdef,
        [SDEF]: player2.sdef,
        ...params
      };
    };
    let damage = 0, fn;
    let critical = false;
    let guard = false;
    let superGuard = false;
    let elementVulnerable = false;
    const paramA = getParam(attackerPlayer);
    const paramB = getParam(this);
    if (skill) {
      fn = this.getFormulas("damageSkill");
      if (!fn) {
        throw new Error("Skill Formulas not exists");
      }
      damage = fn(paramA, paramB, skill);
    } else {
      fn = this.getFormulas("damagePhysic");
      if (!fn) {
        throw new Error("Physic Formulas not exists");
      }
      damage = fn(paramA, paramB);
      const coef = this.coefficientElements(attackerPlayer);
      if (coef >= 2) {
        elementVulnerable = true;
      }
      damage *= coef;
      fn = this.getFormulas("damageCritical");
      if (fn) {
        let newDamage = fn(damage, paramA, paramB);
        if (damage != newDamage) {
          critical = true;
        }
        damage = newDamage;
      }
    }
    if (this.hasEffect(Effect.GUARD)) {
      fn = this.getFormulas("damageGuard");
      if (fn) {
        let newDamage = fn(damage, paramA, paramB);
        if (damage != newDamage) {
          guard = true;
        }
        damage = newDamage;
      }
    }
    if (this.hasEffect(Effect.SUPER_GUARD)) {
      damage /= 4;
      superGuard = true;
    }
    this.hp -= damage;
    return {
      damage,
      critical,
      elementVulnerable,
      guard,
      superGuard
    };
  }
  getFormulas(name2) {
    return this.server.damageFormulas[name2];
  }
}
applyMixins$1(BattleManager, [ParameterManager, ElementManager, EffectManager]);
const defaultStyle = (style) => ({
  borderColor: "#000000",
  borderWidth: 2,
  bgColor: "#000000",
  borderRadius: 5,
  ...style
});
const bar = (current, max, style, text) => {
  return {
    id: "bar",
    value: {
      current,
      max,
      text: text === null ? "" : text || "{$current}/{$max}",
      style
    }
  };
};
const Components = {
  /**
   * Displays a bar
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *    bgColor: '#ab0606'
   * })
   * ```
   *
   * For text, you can use the following variables:
   * - {$current} current value
   * - {$max} maximum value
   * - {$percent} percentage
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *   bgColor: '#ab0606'
   * }, 'HP: {$current}/{$max}')
   * ```
   *
   * and you can also use the variables of player:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.bar('hp', 'param.maxHp', {
   *  bgColor: '#ab0606'
   * }, 'HP: {$current}/{$max} - {name}') // HP: 100/100 - John
   * ```
   *
   * @title Bar Component
   * @param {string} current Parameter that corresponds to the current value
   * @param {string} max Parameter that corresponds to the maximum value
   * @param {object} [style] style
   * @param {string} [style.bgColor] background color. Hexadecimal format.
   * @param {string} [style.fillColor] fill color. Hexadecimal format.
   * @param {string} [style.borderColor] border color. Hexadecimal format.
   * @param {number} [style.borderWidth] border width
   * @param {number} [style.height] height
   * @param {number} [style.width] width
   * @param {number} [style.borderRadius] border radius
   * @param {number} [style.opacity] opacity
   * @param {string | null} [text] text above bar. if null, no text will be displayed. You can use the variables
   * @returns {BarComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  bar,
  /**
   * Displays a life bar
   *
   * @title HP Bar Component
   * @param {object} [style] style. See bar style (Components.bar())
   * @param {string | null} [text] test above bar (Components.bar())
   * @returns {BarComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  hpBar(style, text) {
    return bar("hp", "param.maxHp", {
      ...defaultStyle({
        fillColor: "#ab0606"
      }),
      ...style || {}
    }, text);
  },
  /**
  * Displays a SP bar
  *
  * @title SP Bar Component
  * @param {object} [style] style. See bar style (Components.bar())
  * @param {string | null} [text] test above bar (Components.bar())
  * @returns {BarComponentObject}
  * @memberof Components
  * @since 3.3.0
  */
  spBar(style, text) {
    return bar("sp", "param.maxSp", {
      ...defaultStyle({
        fillColor: "#0fa38c"
      }),
      ...style || {}
    }, text);
  },
  /**
  * Put on the text. You can read the content of a variable with {} format (see example below)
  *
  * Example:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('Hello World')
  * ```
  *
  * Example with variable:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('{name}')
  * ```
  *
  * Other example with position:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('X: {position.x} Y: {position.y}')
  * ```
  *
  * With style:
  *
  * ```ts
  * import { Components } from '@rpgjs/server'
  * Components.text('Hello World', {
  *      fill: '#ffffff',
  *      fontSize: 20,
  *      fontFamily: 'Arial',
  *      stroke: '#000000',
  *      fontStyle: 'italic',
  *      fontWeight: 'bold'
  * })
  * ```
  *
  * @title Text Component
  * @param {string} value source
  * @param {object} [style] style
  * @param {string} [style.fill] color. Hexadecimal format.
  * @param {number} [style.fontSize] font size
  * @param {string} [style.fontFamily] font family
  * @param {string} [style.stroke] stroke color. Hexadecimal format.
  * @param {'normal' | 'italic' | 'oblique'} [style.fontStyle] font style
  * @param {'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'} [style.fontWeight] font weight
  * @param {number} [style.opacity] opacity. Between 0 and 1
  * @param {boolean} [style.wordWrap] word wrap
  * @param {'left' | 'center' | 'right' | 'justify'} [style.align] align
  * @returns {TextComponentObject}
  * @memberof Components
  * @since 3.3.0
  */
  text(value, style) {
    return {
      id: "text",
      value: {
        text: value,
        style: {
          fill: "#ffffff",
          fontSize: 15,
          ...style || {}
        }
      }
    };
  },
  /**
   * Add a shape
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.shape({
   *      fill: '#ffffff',
   *      type: 'circle',
   *      radius: 10
   * })
   * ```
   *
   * You can use parameters:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.shape({
   *      fill: '#ffffff',
   *      type: 'circle',
   *      radius: 'hp'
   * })
   * ```
   *
   * Here, the radius will be the same as the hp value
   *
   * @title Shape Component
   * @param {object} value
   * @param {string} value.fill color. Hexadecimal format.
   * @param {number | string} [value.opacity] opacity. Between 0 and 1
   * @param {string} value.type type of shape. Can be 'circle' or 'rectangle', 'ellipse' or 'polygon', 'line' or 'rounded-rectangle'
   * @param {number | string} [value.radius] if type is circle, radius of the circle
   * @param {number | string} [value.width] if type is rectangle or ellipse, width of the rectangle
   * @param {number | string} [value.height] if type is rectangle or ellipse, height of the rectangle
   * @param {number | string} [value.x1] if type is line, x1 position of the line
   * @param {number | string} [value.y1] if type is line, y1 position of the line
   * @param {number | string} [value.x2] if type is line, x2 position of the line
   * @param {number | string} [value.y2] if type is line, y2 position of the line
   * @param {number[]} [value.points] if type is polygon, points of the polygon
   * @param {object} [value.line] border style
   * @param {string} [value.line.color] border color. Hexadecimal format.
   * @param {number} [value.line.width] border width
   * @param {number} [value.line.alpha] border opacity. Between 0 and 1
   * @returns {ShapeComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  shape(value) {
    return {
      id: "shape",
      value
    };
  },
  /**
   * Put the link to an image or the identifier of an image (if the spritesheet exists)
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.image('mygraphic.png')
   * ```
   *
   * @title Image Component
   * @param {string} value source
   * @returns {ImageComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  image(value) {
    return {
      id: "image",
      value
    };
  },
  /**
   * Indicates the tile ID
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   * Components.tile(3)
   * ```
   *
   * @title Tile Component
   * @param {number} value tile ID
   * @returns {TileComponentObject}
   * @memberof Components
   * @since 3.3.0
   */
  tile(value) {
    return {
      id: "tile",
      value
    };
  },
  debug() {
    return {
      id: "debug",
      value: ""
    };
  }
};
class ComponentManager {
  /**
   * Give the spritesheet identifier
   *
   * Since version 3.0.0-rc, you can define several graphic elements. If you put a number, it represents the tile ID in the tileset
   *
   * Example 1:
   * ```ts
   * player.setGraphic(['body', 'shield'])
   * ```
   *
   * Example 2:
   * ```ts
   * player.setGraphic(3) // Use tile #3
   * ```
   *
   * > You must, on the client side, create the spritesheet in question. Guide: [Create Sprite](/guide/create-sprite.html)
   *
   * @title Set Graphic
   * @method player.setGraphic(graphic)
   * @param {string | number | (string | number)[]} graphic
   * @returns {void}
   * @memberof ComponentManager
   */
  setGraphic(graphic) {
    const components = isArray$d(graphic) ? graphic : [graphic];
    const col = [...components.map((value) => ({
      id: isString$b(value) ? "graphic" : "tile",
      value
    }))];
    this.removeComponentById("center", "graphic");
    this.mergeComponent("center", col);
  }
  /**
   * Delete components
   *
   * @title Remove Components
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @memberof ComponentManager
   * @since 3.3.0
   */
  removeComponents(position) {
    this.layout[position].lines = [];
  }
  /**
   * Delete components by id.
   *
   * @title Remove Component By Id
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @param {string} id Id of the component
   * @since 3.3.0
   */
  removeComponentById(position, id) {
    var _a;
    let lines = ((_a = this.layout[position]) == null ? void 0 : _a.lines) || [];
    lines = lines.map((line) => {
      line.col = line.col.filter((c3) => c3.id !== id);
      return line;
    });
    lines = lines.filter((line) => line.col.length > 0);
    this.layout[position].lines = lines;
  }
  /**
   * Merges components with existing components
   *
   * For use layout and options, see [setComponentsTop](/api/player.html#setcomponentstop)
   *
   * @title Merge Components
   * @param {string} position Position of the components. Can be: `top`, `center`, `bottom`, `left`, `right`
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  mergeComponent(position, layout, options2 = {}) {
    var _a;
    if (!(layout instanceof Array)) {
      layout = [layout];
    }
    this.layout[position] = {
      lines: [...((_a = this.layout[position]) == null ? void 0 : _a.lines) || [], ...layout.map((col) => {
        if (!isArray$d(col)) {
          col = [col];
        }
        return {
          col
        };
      })],
      ...options2
    };
  }
  setComponents(position, layout, options2 = {}) {
    this.layout[position].lines = [];
    this.mergeComponent(position, layout, options2);
  }
  /**
   * Add components to the center of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * > Be careful, because if you assign, it deletes the graphics and if the lines are superimposed (unlike the other locations)
   *
   * @title Set Components Center
   * @method player.setComponentsCenter(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsCenter(layout, options2 = {}) {
    this.setComponents("center", layout, options2);
  }
  /**
   * Add components to the top of the graphic. e.g. text, life bar etc. The block will be centred
   * The first array corresponds to the rows, and the nested table to the array in the row
   *
   * Example:
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   *
   * player.setComponentsTop([
   *      [Components.text('Hello World')],
   *      [Components.hpBar()]
   * ]) // 2 lines with 1 component each
   * ```
   *
   *  or
   *
   * ```ts
   * import { Components } from '@rpgjs/server'
   *
   * player.setComponentsTop([
   *      [Components.text('Hello World'), Components.hpBar()]
   * ]) // 1 line with 2 components
   * ```
   *
   * You can be faster if you only have lines
   *
   * ```ts
   * player.setComponentsTop([
   *      Components.text('Hello World'),
   *      Components.hpBar()
   * ]) // 2 lines with 1 component each
   * ```
   *
   * or one component:
   *
   * ```ts
   * player.setComponentsTop(Components.text('Hello World')) // 1 line with 1 component
   * ```
   *
   * You can add options to manage the style
   *
   * ```ts
   * player.setComponentsTop([
   *      Components.text('Hello World'),
   *      Components.hpBar()
   * ], {
   *      width: 100,
   *      height: 20,
   *      marginTop: 10,
   * })
   * ```
   *
   * @title Set Components Top
   * @method player.setComponentsTop(layout,options)
   * @param {ComponentObject[][] | ComponentObject[] | ComponentObject} layout Components
   * @param {Object} [options = {}] Options
   * @param {number} [options.width] Width of the block
   * @param {number} [options.height = 20] Height of the block
   * @param {number} [options.marginTop] Margin top
   * @param {number} [options.marginBottom] Margin bottom
   * @param {number} [options.marginLeft] Margin left
   * @param {number} [options.marginRight] Margin right
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsTop(layout, options2 = {}) {
    this.setComponents("top", layout, options2);
  }
  /**
   * Add components to the bottom of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Bottom
   * @method player.setComponentsBottom(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsBottom(layout, options2 = {}) {
    this.setComponents("bottom", layout, options2);
  }
  /**
   * Add components to the left of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Left
   * @method player.setComponentsLeft(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsLeft(layout, options2 = {}) {
    this.setComponents("left", layout, options2);
  }
  /**
   * Add components to the right of the graphic.
   *
   * View [setComponentsTop](/api/player.html#setcomponentstop) for more information
   *
   * @title Set Components Right
   * @method player.setComponentsRight(layout,options)
   * @param {Object} layout
   * @param {Object} options
   * @memberof ComponentManager
   * @since 3.3.0
   */
  setComponentsRight(layout, options2 = {}) {
    this.setComponents("right", layout, options2);
  }
}
var EventMode;
(function(EventMode2) {
  EventMode2["Shared"] = "shared";
  EventMode2["Scenario"] = "scenario";
})(EventMode || (EventMode = {}));
class EventManager {
  /**
  * Get Event in current map
  * @title Get Event
  * @since 3.0.0-beta.7
  * @method map.getEvent(eventId)
  * @param {string} eventId Event Id
  * @returns {RpgEvent | undefined}
  * @memberof Map
  */
  getEvent(eventId) {
    return this.events[eventId];
  }
  getEventByName(eventName) {
    const events2 = Object.keys(this.events);
    const key = events2.find((key2) => this.events[key2].name == eventName);
    if (!key)
      return;
    return this.events[key];
  }
  /**
  * Removes an event from the map. Returns false if the event is not found
  *
  * Deletion of an event forced to be performed at the end of several aynschronous notions
  *
  * @title Remove Event
  * @since 3.0.0-beta.4
  * @method map.removeEvent(eventId)
  * @param {string} eventId Event Name
  * @returns {boolean}
  * @memberof Map
  */
  removeEvent(eventId) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.events[eventId])
      return false;
    const mode = this.events[eventId].mode;
    let currentState;
    if (mode == EventMode.Scenario) {
      currentState = ((_d = (_c = (_b = (_a = this.getCurrentMap()) == null ? void 0 : _a.$currentState().users) == null ? void 0 : _b[this.id]) == null ? void 0 : _c.events) == null ? void 0 : _d[eventId]) ?? {};
    } else {
      currentState = ((_e = this.$currentState().events) == null ? void 0 : _e[eventId]) ?? {};
    }
    this.removeObject(this.events[eventId], mode);
    delete this.events[eventId];
    if (mode == EventMode.Scenario) {
      (_f = this.getCurrentMap()) == null ? void 0 : _f.$setCurrentState(`users.${this.id}.events.${eventId}`, {
        ...currentState,
        deleted: true
      });
    } else {
      this.$setCurrentState(`events.${eventId}`, {
        ...currentState,
        deleted: true
      });
    }
    return true;
  }
  // @internal
  removeObject(object, mode = EventMode.Shared) {
    const map2 = this.getCurrentMap();
    if (!map2)
      return;
    map2.getShapes().forEach((shape) => shape.out(object));
    const events2 = Object.values(map2.game.world.getObjectsOfGroup(map2.id, object));
    for (let event of events2) {
      object.getShapes().forEach((shape) => shape.out(event));
      event.getShapes().forEach((shape) => shape.out(object));
    }
    object._destroy$.next();
    object._destroy$.complete();
    if (object.type != PlayerType.Player)
      object._destroy$["_closed"] = true;
    map2.grid.clearObjectInCells(object.id);
    for (let playerId in map2.players) {
      if (object.id == playerId)
        continue;
      const otherPlayer = map2.players[playerId];
      if (otherPlayer.followingId == object.id) {
        otherPlayer.cameraFollow(otherPlayer);
      }
    }
    if (map2.nbPlayers === 1 && object.type === PlayerType.Player) {
      map2.remove(true);
    }
  }
}
let instanceContext$1 = null;
function inject$2(service, args = []) {
  return instanceContext$1.inject(service, args);
}
function setInject$1(context2) {
  instanceContext$1 = context2;
}
const {
  isPromise: isPromise$1,
  applyMixins,
  isString: isString$3
} = Utils$2;
const commonSchemaFeature = {
  name: {
    $permanent: false
  },
  description: {
    $permanent: false
  },
  id: String
};
const itemSchemas = {
  price: {
    $permanent: false
  },
  consumable: {
    $permanent: false
  },
  ...commonSchemaFeature
};
const componentSchema = {
  id: String,
  value: String
};
const layoutSchema = {
  width: Number,
  height: Number,
  marginBottom: Number,
  marginTop: Number,
  marginLeft: Number,
  marginRight: Number,
  lines: [{
    col: [componentSchema]
  }]
};
const playerSchemas = {
  position: {
    x: Number,
    y: Number,
    z: Number
  },
  direction: Number,
  teleported: {
    $permanent: false
  },
  deleted: {
    $permanent: false
  },
  moving: {
    $permanent: false
  },
  param: Object,
  hp: Number,
  sp: Number,
  gold: Number,
  level: {
    $effects: ["$this.expForNextlevel", "$this.param"]
  },
  expForNextlevel: {
    $permanent: false
  },
  exp: Number,
  name: String,
  items: [{
    nb: Number,
    item: itemSchemas
  }],
  _class: commonSchemaFeature,
  equipments: [itemSchemas],
  skills: [{
    spCost: {
      $permanent: false
    },
    ...commonSchemaFeature
  }],
  states: [commonSchemaFeature],
  effects: [String],
  layout: {
    top: layoutSchema,
    bottom: layoutSchema,
    left: layoutSchema,
    right: layoutSchema,
    center: layoutSchema
  },
  action: Number,
  map: String,
  speed: Number,
  frequency: Number,
  canMove: Boolean,
  through: Boolean,
  throughOtherPlayer: Boolean,
  width: Number,
  height: Number,
  wHitbox: Number,
  hHitbox: Number,
  // only for server
  _statesEfficiency: [{
    rate: {
      $syncWithClient: false
    },
    state: {
      $syncWithClient: false
    }
  }],
  tmpPositions: {
    $syncWithClient: false
  },
  initialLevel: {
    $syncWithClient: false
  },
  finalLevel: {
    $syncWithClient: false
  }
};
const layoutObject$1 = {
  lines: []
};
class RpgPlayer extends RpgCommonPlayer {
  // redefine type (as RpgPlayer)
  get otherPlayersCollision() {
    return super.otherPlayersCollision;
  }
  get world() {
    var _a;
    return (_a = this.server) == null ? void 0 : _a.world;
  }
  constructor(playerId) {
    super(inject$2(RpgCommonGame), playerId);
    this.playerId = playerId;
    this.type = "player";
    this.layout = {
      top: layoutObject$1,
      bottom: layoutObject$1,
      left: layoutObject$1,
      right: layoutObject$1,
      center: layoutObject$1
    };
    this.events = {};
    this._rooms = [];
    this.session = null;
    this.prevMap = "";
    this.touchSide = false;
    this.tmpPositions = null;
    this.otherPossessedPlayer = null;
    this.followingId = null;
    this._dataLoading = false;
    this.gameEngine = inject$2(RpgCommonGame);
    this.teleported = 0;
    this.deleted = false;
    this.initialize();
  }
  /** @internal */
  initialize() {
    this.server = inject$2(RpgServerEngine$1);
    this.expCurve = {
      basis: 30,
      extra: 20,
      accelerationA: 30,
      accelerationB: 30
    };
    this.parameters = /* @__PURE__ */ new Map();
    this.variables = /* @__PURE__ */ new Map();
    this.states = [];
    this.equipments = [];
    this._effects = [];
    this.items = [];
    this.skills = [];
    this.gold = 0;
    this.exp = 0;
    this.speed = Speed.Normal;
    this.frequency = Frequency.None;
    this.canMove = true;
    this.through = false;
    this.throughOtherPlayer = true;
    this.initialLevel = 1;
    this.finalLevel = 99;
    this.level = this.initialLevel;
    this._gui = {};
    this._elementsEfficiency = [];
    this._statesEfficiency = [];
    this.moving = false;
    this.addParameter(MAXHP, MAXHP_CURVE);
    this.addParameter(MAXSP, MAXSP_CURVE);
    this.addParameter(STR, STR_CURVE);
    this.addParameter(INT, INT_CURVE);
    this.addParameter(DEX, DEX_CURVE);
    this.addParameter(AGI, AGI_CURVE);
    this.allRecovery();
  }
  _init() {
    this._socket.on("gui.interaction", ({
      guiId,
      name: name2,
      data
    }) => {
      if (this._gui[guiId]) {
        this._gui[guiId].emit(name2, data);
        this.syncChanges();
      }
    });
    this._socket.on("gui.exit", ({
      guiId,
      data
    }) => {
      this.removeGui(guiId, data);
    });
  }
  get schema() {
    return {
      ...RpgPlayer.schemas,
      ...this.server["playerProps"]
    };
  }
  /**
   * ```ts
   * player.name = 'Link'
   * ```
   * @title Read/Give a name
   * @prop {string} player.name
   * @memberof Player
   * */
  get name() {
    return this._name;
  }
  set name(val) {
    this._name = val;
  }
  /**
   * Change your map. Indicate the positions to put the player at a place on the map
   *
   * > The map must be added to RpgServer beforehand. Guide: [Create Map](/guide/create-map.html)
   *
   * You don't have to give positions but you can put a starting position in the TMX file. Guide: [Start Position](/guide/player-start.html)
   *
   * @title Change Map
   * @method player.changeMap(mapId,positions)
   * @param {string} mapId
   * @param { {x: number, y: number, z?: number} | string } [positions]
   * @returns {Promise<RpgMap | null>} null if map not exists
   * @memberof Player
   */
  changeMap(mapId, positions) {
    return this.server.sceneMap.changeMap(mapId, this, positions);
  }
  async autoChangeMap(nextPosition) {
    const map2 = this.getCurrentMap();
    const worldMaps = map2 == null ? void 0 : map2.getInWorldMaps();
    let ret = false;
    if (worldMaps && map2) {
      const direction = this.getDirection();
      const marginLeftRight = map2.tileWidth / 2;
      const marginTopDown = map2.tileHeight / 2;
      const changeMap = async (adjacent, to) => {
        if (this.touchSide) {
          return false;
        }
        this.touchSide = true;
        const [nextMap] = worldMaps.getAdjacentMaps(map2, adjacent);
        if (!nextMap)
          return false;
        const id = nextMap.id;
        const nextMapInfo = worldMaps.getMapInfo(id);
        return !!await this.changeMap(id, to(nextMapInfo));
      };
      if (nextPosition.x < marginLeftRight && direction == Direction.Left) {
        ret = await changeMap({
          x: map2.worldX - 1,
          y: this.worldPositionY + 1
        }, (nextMapInfo) => ({
          x: nextMapInfo.width - this.wHitbox - marginLeftRight,
          y: map2.worldY - nextMapInfo.y + nextPosition.y
        }));
      } else if (nextPosition.x > map2.widthPx - this.wHitbox - marginLeftRight && direction == Direction.Right) {
        ret = await changeMap({
          x: map2.worldX + map2.widthPx + 1,
          y: this.worldPositionY + 1
        }, (nextMapInfo) => ({
          x: marginLeftRight,
          y: map2.worldY - nextMapInfo.y + nextPosition.y
        }));
      } else if (nextPosition.y < marginTopDown && direction == Direction.Up) {
        ret = await changeMap({
          x: this.worldPositionX + 1,
          y: map2.worldY - 1
        }, (nextMapInfo) => ({
          x: map2.worldX - nextMapInfo.x + nextPosition.x,
          y: nextMapInfo.height - this.hHitbox - marginTopDown
        }));
      } else if (nextPosition.y > map2.heightPx - this.hHitbox - marginTopDown && direction == Direction.Down) {
        ret = await changeMap({
          x: this.worldPositionX + 1,
          y: map2.worldY + map2.heightPx + 1
        }, (nextMapInfo) => ({
          x: map2.worldX - nextMapInfo.x + nextPosition.x,
          y: marginTopDown
        }));
      } else {
        this.touchSide = false;
      }
    }
    return ret;
  }
  /**
   * Dynamically create an event in Scenario mode on the current map
   *
   * ```ts
   * @EventData({
   *  name: 'EV-1'
   * })
   * class MyEvent extends RpgEvent {
   *  onAction() {
   *      console.log('ok')
   *  }
   * }
   *
   * player.createDynamicEvent({
   *      x: 100,
   *      y: 100,
   *      event: MyEvent
   * })
   * ```
   *
   * You can also put an array of objects to create several events at once
   *
   * @title Create Dynamic Event
   * @since 3.0.0-beta.4
   * @method player.createDynamicEvent(eventObj | eventObj[])
   * @param { { x: number, y: number, z?: number, event: eventClass } } [eventsList]
   * @returns { { [eventId: string]: RpgEvent } }
   * @memberof Player
   */
  createDynamicEvent(eventsList, forceMode = true) {
    if (!eventsList)
      return {};
    const mapInstance = this.getCurrentMap();
    if (!mapInstance) {
      throw "The player is not assigned to any map";
    }
    if (!isArray$d(eventsList)) {
      eventsList = [eventsList];
    }
    let eventsListMode = eventsList;
    if (forceMode) {
      eventsListMode = eventsList.map((event) => {
        event.event.mode = EventMode.Scenario;
        return event;
      });
    }
    const events2 = mapInstance.createEvents(eventsListMode, EventMode.Scenario);
    let ret = {};
    for (let key in events2) {
      this.events[key] = events2[key];
      this.events[key].playerRelated = this;
      this.events[key].execMethod("onInit", [this]);
      ret = {
        ...ret,
        [key]: this.events[key]
      };
    }
    return ret;
  }
  /**
   * Allows to change the positions of the player on the current map.
   * You can put the X and Y positions or the name of the created shape on Tiled Map Editor.
   * If you have several shapes with the same name, one position will be chosen randomly.
   *
   * ```ts
   * player.teleport({ x: 100, y: 500 })
   * ```
   *
   * or
   *
   * ```ts
   * player.teleport('my-shape-name')
   * ```
   *
   * If no parameter:
   *
   * ```ts
   * player.teleport() // { x: 0, y: 0, z: 0 }
   * ```
   *
   * @title Teleport on the map
   * @method player.teleport(positions)
   * @param { {x: number, y: number, z?: number} | string } [positions]
   * @returns {Promise<{ {x: number, y: number, z: number} }>}
   * @memberof Player
   */
  async teleport(positions) {
    var _a;
    if (isString$3(positions))
      positions = (_a = this.getCurrentMap()) == null ? void 0 : _a.getPositionByShape((shape) => shape.name == positions || shape.getType() == positions);
    if (!positions)
      positions = {
        x: 0,
        y: 0,
        z: 0
      };
    if (!positions.z)
      positions.z = 0;
    this.teleported++;
    this.position = positions;
    this._lastFramePositions = void 0;
    await this.isCollided(this.position);
    return positions;
  }
  /**
   * Load the saved data with the method save()
   * If the player was on a map, it repositions the player on the map.
   *
   * ```ts
   * const json = player.save()
   * player.load(json)
   * ```
   *
   * @title Load progress
   * @method player.load(json)
   * @param {string} json The JSON sent by the method save()
   * @returns {Promise<boolean | RpgMap | null>}
   * @memberof Player
   */
  async load(json) {
    this._dataLoading = true;
    if (isString$3(json))
      json = JSON.parse(json);
    const getData = (id) => new (this.databaseById(id))();
    for (let key in json) {
      const val = json[key];
      if (isObject$4(val) && val.hasOwnProperty("0")) {
        json[key] = Object.values(val);
      }
    }
    const items = {};
    if (json.items) {
      for (let it2 of json.items) {
        items[it2.item.id] = getData(it2.item.id);
      }
      json.items = json.items.map((it2) => ({
        nb: it2.nb,
        item: items[it2.item.id]
      }));
      if (Array.isArray(json.equipments)) {
        json.equipments = json.equipments.map((it2) => {
          items[it2.id].equipped = true;
          return items[it2.id];
        });
      }
    }
    if (json.states)
      json.states = json.states.map((state) => getData(state.id));
    if (json.skills)
      json.skills = json.skills.map((skill) => getData(skill.id));
    if (json.variables)
      json.variables = new Map(json.variables);
    merge$2(this, json);
    this.position = json.position;
    if (json.map) {
      this.map = "";
      const map2 = await this.changeMap(json.map, json.tmpPositions || json.position);
      this._dataLoading = false;
      return map2;
    }
    this._dataLoading = false;
    return null;
  }
  /**
   * Returns a JSON with all the data to keep in memory. Then use the `load()` method to load the data
   *
   * You can also use the JSON.stringify
   *
   * ```ts
   * const json = player.save() // or JSON.stringify(player)
   * player.load(json)
   * ```
   *
   * @title Save progress
   * @method player.save()
   * @returns {string}
   * @memberof Player
   */
  save() {
    return JSON.stringify(this);
  }
  // TODO
  toObject() {
    return {
      direction: this.direction,
      id: this.id,
      canMove: this.canMove,
      position: {
        x: this.position.x,
        y: this.position.y,
        z: this.position.z
      },
      hitbox: {
        width: this.wHitbox,
        height: this.hHitbox
      },
      map: this.map,
      pendingMove: this.pendingMove,
      speed: this.speed
    };
  }
  toJSON() {
    const {
      permanentObject
    } = Room.compileSchema(this.schema);
    const snapshot = Room.extractObjectOfRoom(this, permanentObject);
    snapshot.variables = [...this.variables];
    return snapshot;
  }
  /**
   * Run the change detection cycle. Normally, as soon as a hook is called in a class, the cycle is started. But you can start it manually
   * The method calls the `onChanges` method on events and synchronizes all map data with the client.
    * @title Run Sync Changes
   * @method player.syncChanges()
   * @returns {void}
   * @memberof Player
   */
  syncChanges() {
    this._eventChanges();
  }
  databaseById(id) {
    const data = this.server.database[id];
    if (!data)
      throw new Error(`The ID=${id} data is not found in the database. Add the data in the property "database" of @RpgServer decorator.`);
    return data;
  }
  /**
   * Retrieves data from the current map
   *
   * returns null if the player is not assigned to a map
   *
   * @title Get Current Map
   * @method player.getCurrentMap()
   * @returns {RpgMap | null}
   * @memberof Player
   */
  getCurrentMap() {
    return this._getMap(this.map);
  }
  loadScene(name2, data) {
    this.emit(SocketEvents.LoadScene, {
      name: name2,
      data
    });
  }
  emitSceneMap() {
    const mapInstance = this.getCurrentMap();
    if (!mapInstance) {
      throw "[Emit] The player is not assigned to any map";
    }
    let {
      data: serializeMap
    } = Object.assign({}, mapInstance);
    delete serializeMap.shapes;
    delete serializeMap.events;
    delete serializeMap._events;
    for (let layer of serializeMap.layers) {
      delete layer.map;
    }
    this.loadScene("map", {
      id: mapInstance.id,
      sounds: mapInstance.sounds,
      ...serializeMap
    });
  }
  gameReload() {
    this.emit(SocketEvents.GameReload);
  }
  changeServer(url2, port) {
    this.emit(SocketEvents.ChangeServer, {
      url: url2,
      port
    });
  }
  _getMap(id) {
    return RpgCommonMap.buffer.get(id);
  }
  /**
   * Calls the showAnimation() method on the client side to display an animation on the player
   * You must remember to create the spritesheet beforehand
   *
   * For this type of spritesheet:
   *
   * ```ts
   * @Spritesheet({
   *  id: 'fire',
   *  image: require('')
   *  textures: {
   *      default: {
   *          animations: [
   *
   *          ]
   *      }
   *   }
   * })
   * export class FireAnimation {}
   * ```
   *
   * Here is the call of the method:
   *
   * ```ts
   * player.showAnimation('fire', 'default')
   * ```
   *
   * If you don't want to put an animation on top of the event but replace the event graphic with another one, set true as last parameter.
   * This is useful, if for example, you want to make an animated character (sword stroke when pressing a key)
   * When the animation is finished, the original graphic is displayed again
   *
   *
   * ```ts
   * player.showAnimation('sword_stroke', 'default', true)
   * ```
   *
   * Since version 3.0.0-rc, you can define several graphic elements. This allows you to animate them all at once
   *
   * ```ts
   * player.showAnimation(['body', 'sword_stroke'], 'default', true)
   * ```
   *
   * ::: tip
   * For this to work, the animations must have been previously defined in `setGraphic`.
   * :::
   *
   * @title Show Animation
   * @method player.showAnimation(graphic,animationName,replaceGraphic=false)
   * @param {string | string[]} graphic spritesheet identifier
   * @param {string} animationName Name of the animation in the spritesheet
   * @param {boolean} [replaceGraphic] Replace the event graphic with the animation. After the end of the animation, the original graphic is reapplied
   * @returns {void}
   * @memberof Player
   */
  showAnimation(graphic, animationName, replaceGraphic = false) {
    this.emitToMap("callMethod", {
      name: SocketMethods.ShowAnimation,
      params: [graphic, animationName, replaceGraphic]
    });
  }
  /**
   * TODO:
   * 1. It is necessary, on the client side, to make the character move even if controlled by someone else (problem: same playerId so, one will not move because of the client side prediction. Solution: create a new Id ? like session Id ?
   * 2. You would need several sockets per character. If the character changes map or changes server, all players controlling the character must be able to see it
   * 3. If the player regains control, what happens, do we return to the previous map?
   * 4. If it's an event, you must be able to get the event by id in GameEngine
   */
  takePossessionOf(otherPlayer) {
    this.otherPossessedPlayer = otherPlayer;
    this._socket.emit("playerJoined", {
      playerId: otherPlayer.id,
      session: this.session
    });
    this.cameraFollow(otherPlayer);
  }
  /**
   * Sends the client which event or player the camera should follow. You can set options to perform a motion animation
   *
   * @title Camera Follow
   * @method player.cameraFollow(otherPlayer,options)
   * @param {RpgPlayer | RpgEvent} otherPlayer
   * @param {options} options
   * @param {object | boolean} [options.smoothMove] - animate. Set a boolean to use default parameters
   * @param {number} [options.smoothMove.time=1000] - time to animate
   * @param {string} [options.smoothMove.ease=linear] - easing to use. Go to https://easings.net to get function name
   * @returns {void}
   * @since 3.1.0
   * @memberof Player
   */
  cameraFollow(otherPlayer, options2 = {}) {
    if (otherPlayer.id == this.id) {
      this.followingId = null;
    } else {
      this.followingId = otherPlayer.id;
    }
    this.emit(SocketEvents.CallMethod, {
      objectId: this.playerId,
      name: SocketMethods.CameraFollow,
      params: [otherPlayer.id, options2]
    });
  }
  /**
   * Emit data to clients with socket
   *
   * @title Emit to client
   * @method player.emit(key,value)
   * @param {string} key
   * @param {any} value
   * @returns {void}
   * @memberof Player
   */
  emit(key, value) {
    if (this._socket)
      this._socket.emit(key, value);
  }
  /**
   * Listen to the data (socket) sent by the client
   *
   * @title Listen to data from the client
   * @method player.on(key,cb)
   * @param {string} key
   * @param {function} cb
   * @returns {void}
   * @memberof Player
   */
  on(key, cb) {
    if (this._socket)
      this._socket.on(key, cb);
  }
  /**
   * Adds a one-time listener function for the event named eventName
   *
   * @title Listen one-time to data from the client
   * @method player.once(key,cb)
   * @since 3.0.0-beta.5
   * @param {string} key
   * @param {function} cb
   * @returns {void}
   * @memberof Player
   */
  once(key, cb) {
    if (this._socket)
      this._socket.once(key, cb);
  }
  /**
   * Removes all listeners of the specified eventName.
   *
   * @title Removes all listeners of the client
   * @method player.off(key)
   * @since 3.0.0-beta.5
   * @param {string} key
   * @returns {void}
   * @memberof Player
   */
  off(key) {
    if (this._socket)
      this._socket.removeAllListeners(key);
  }
  disconnect() {
    if (this._socket)
      this._socket.disconnect();
  }
  emitToMap(key, value) {
    const map2 = this.getCurrentMap();
    if (map2) {
      map2.$setCurrentState(`users.${this.id}.${key}`, value);
    }
  }
  execMethodSync(methodName, methodData = [], target) {
    let ret;
    if (target && target[methodName]) {
      ret = target[methodName](...methodData);
    }
    return ret;
  }
  async execMethod(methodName, methodData = [], target) {
    const ignoreIfDataLoading = ["onLevelUp", "onDead"];
    if (ignoreIfDataLoading.includes(methodName) && this._dataLoading) {
      return;
    }
    let ret;
    if (target && target[methodName]) {
      ret = target[methodName](...methodData);
      if (isPromise$1(ret))
        await ret;
    } else {
      ret = await RpgPlugin.emit(`Server.${methodName}`, [this, ...methodData], true);
    }
    this.syncChanges();
    return ret;
  }
  _triggerHook(name2, val) {
    if (this[name2])
      this[name2](val);
    this.emit("Player." + name2, val);
  }
  // @internal
  /**
   * Allows you to manually update a status in the rooms that will then be sent to the customer.
   * @param path
   * @example
   * ```ts
   * player.changeRoomState('hp')
   * ```
   */
  changeRoomState(path2) {
    var _a;
    (_a = this.world) == null ? void 0 : _a.forEachUserRooms(this.id, (room2) => {
      room2.$setCurrentState(`users.${this.id}.${path2}`);
    });
  }
  _eventChanges() {
    if (!this._getMap(this.map))
      return;
    const {
      events: events2
    } = this._getMap(this.map);
    const arrayEvents = [...Object.values(this.events), ...Object.values(events2)];
    for (let event of arrayEvents) {
      if (event.onChanges)
        event.onChanges(this);
    }
  }
  /**
   * Allows to play a sound, heard only by the player or by the players of the map
   *
   * Here is a sound, client side:
   *
   * ```ts
   * import { Sound } from '@rpgjs/client'
   * @Sound({
   *      id: 'town-music',
   *      sound: require('./sound/town.ogg')
   * })
   * export class TownMusic {}
   * ```
   *
   * Here is the call of the method, server side:
   *
   * ```ts
   * player.playSound('town-music')
   * ```
   *
   * If you want everyone to listen to the sound on the map:
   *
   * ```ts
   * player.playSound('town-music', true)
   * ```
   *
   * @title Play Sound
   * @method player.playSound(soundId,allMap=false)
   * @param {string} soundId Sound identifier, defined on the client side
   * @param {boolean} [forEveryone=false] Indicate if the sound is heard by the players on the map
   * @since 3.0.0-alpha.9
   * @returns {void}
   * @memberof Player
   */
  playSound(soundId, forEveryone = false) {
    const obj = {
      objectId: this.playerId,
      name: SocketMethods.PlaySound,
      params: [soundId]
    };
    if (!forEveryone) {
      this.emit(SocketEvents.CallMethod, obj);
      return;
    }
    this.emitToMap(SocketEvents.CallMethod, obj);
  }
}
RpgPlayer.schemas = {
  ...playerSchemas,
  events: [playerSchemas]
};
applyMixins(RpgPlayer, [EventManager, ItemManager, GoldManager, StateManager, SkillManager, ParameterManager, EffectManager, ClassManager, ElementManager, GuiManager, VariableManager, MoveManager, BattleManager, ComponentManager]);
class RpgEvent extends RpgPlayer {
  constructor(playerId) {
    super(playerId);
    this.type = "event";
    this.properties = {};
    this.playerRelated = null;
  }
  async execMethod(methodName, methodData = []) {
    if (!this[methodName]) {
      return;
    }
    const ret = this[methodName](...methodData);
    return ret;
  }
  changeRoomState(path2) {
    const room2 = this.getCurrentMap();
    if (room2) {
      room2.$setCurrentState(`events.${this.id}.${path2}`);
    }
  }
  /**
  * Deletes the event from the map (in shared or scenario mode)
  *
  * @title Remove
  * @since 4.0.0
  * @method event.remove()
  * @returns {boolean} true if the event has been removed. If false, the event is not on the map
  * @memberof RpgEvent
  */
  remove() {
    let bool = false;
    if (this.playerRelated)
      bool = this.playerRelated.removeEvent(this.id);
    const map2 = this.getCurrentMap();
    if (map2) {
      bool = map2.removeEvent(this.id);
    }
    return bool;
  }
  emitToMap(key, value) {
    const map2 = this.getCurrentMap();
    if (map2) {
      const eventPath = `events.${this.id}.${key}`;
      if (this.playerRelated) {
        map2.$setCurrentState(`users.${this.playerRelated.id}.${eventPath}`, value);
      } else {
        map2.$setCurrentState(eventPath, value);
      }
    }
  }
}
function MapData(options2) {
  return (target) => {
    target.file = options2.file;
    target.id = options2.id;
    target.type = "map";
    target.prototype.name = options2.name;
    target.prototype.file = options2.file;
    target.prototype.id = options2.id;
    target.prototype.sounds = options2.sounds;
    target.prototype.lowMemory = options2.lowMemory;
    target.prototype.$schema = {};
    if (options2.syncSchema) {
      target.prototype.$schema = options2.syncSchema;
    }
    if (!target.prototype.$schema.shapes) {
      target.prototype.$schema.shapes = [{
        type: String,
        name: String,
        x: Number,
        y: Number,
        width: Number,
        height: Number,
        properties: {
          collision: Boolean
        },
        polygon: [{
          x: Number,
          y: Number
        }],
        rotation: Number,
        components: [componentSchema]
      }];
    }
    if (!target.prototype.$schema.users) {
      target.prototype.$schema.users = [RpgPlayer.schemas];
    }
    if (!target.prototype.$schema.events) {
      target.prototype.$schema.events = [RpgPlayer.schemas];
    }
    target.prototype._events = options2.events;
  };
}
function EventData(options2) {
  return (target) => {
    target.mode = options2.mode || EventMode.Shared;
    target.width = options2.width;
    target.height = options2.height;
    target.hitbox = options2.hitbox;
    target._name = options2.name;
    target.prototype._name = options2.name;
    target.prototype.mode = target.mode;
  };
}
class AutoEvent extends RpgEvent {
  onInit() {
    const {
      graphic,
      direction,
      speed,
      frequency,
      move
    } = this.properties;
    if (graphic) {
      this.setGraphic(graphic);
    }
    if (direction) {
      this.changeDirection(direction);
    }
    if (speed) {
      this.speed = speed;
    }
    if (frequency) {
      this.frequency = frequency;
    }
    if (move == "random") {
      this.infiniteMoveRoute([Move.tileRandom()]);
    }
  }
  async onAction(player2) {
    const {
      text
    } = this.properties;
    if (text) {
      await player2.showText(text, {
        talkWith: this
      });
    }
  }
}
AutoEvent.hitbox = {};
class RpgMap extends RpgCommonMap {
  constructor(_server) {
    super();
    this._server = _server;
    this.events = {};
  }
  // alias of users property in simple-room package
  /**
   * @title Players list
   * @prop { { [playerId: string]: RpgPlayer } } [players]
   * @readonly
   * @memberof Map
   */
  get players() {
    return this["users"];
  }
  /**
   * @title Number of players
   * @prop {number} [nbPlayers]
   * @readonly
   * @memberof Map
   */
  get nbPlayers() {
    return Object.keys(this.players).length;
  }
  $additionalEmitProperties(player2) {
    const lastFramePositions = player2["_lastFramePositions"];
    let pos;
    let lastFrame;
    if (lastFramePositions) {
      pos = lastFramePositions.position;
      lastFrame = lastFramePositions.frame;
    }
    const data = {
      frame: lastFrame,
      pos
    };
    return data;
  }
  async load() {
    var _a;
    if (RpgCommonMap.buffer.has(this.id)) {
      return;
    }
    const data = await this.parseTmx(this.file);
    super.load(data);
    this.getAllObjects().forEach(this.createShape.bind(this));
    this.loadProperties(data.properties);
    (_a = this._server.workers) == null ? void 0 : _a.call("loadMap", {
      id: this.id,
      data
    });
    RpgCommonMap.buffer.set(this.id, this);
    this.loadCommonEvents(this._server.inputOptions.events);
    this.createDynamicEvent(this._events);
    if (this.onLoad)
      this.onLoad();
  }
  /**
   * Update the map with new data. Data can be a string (TMX content) or an object (parsed TMX content)
   * New Map data will be sent to all players on the map
   *
   * @title Update map
   * @method map.update(data)
   * @since 4.0.0
   * @returns {Promise<void>}
   * @param {object | string} data
   * @memberof Map
   */
  async update(data) {
    let objectData;
    if (typeof data == "string") {
      objectData = await this.parseTmx(data, this.file);
    } else {
      objectData = data;
    }
    super.load(objectData);
    RpgCommonMap.buffer.set(this.id, this);
    this.clearShapes();
    this.getAllObjects().forEach(this.createShape.bind(this));
    for (let playerId in this.players) {
      const player2 = this.players[playerId];
      player2.emitSceneMap();
    }
  }
  /**
   * Update tileset with new data. Data can be a string (TSX content) or an object (TiledTileset)
   * Cache will be removed for this tileset
   * New tileset data will be sent to all players on the map
   * Warning: tileset is not updated for all maps, only for the current map
   *
   * @title Update tileset
   * @method map.updateTileset(data)
   * @since 4.0.0
   * @returns {<void>}
   * @param {TiledTileset | string} data
   * @memberof Map
   */
  updateTileset(data) {
    let objectData;
    if (typeof data == "string") {
      const parser = new TiledParser(data, this.file);
      objectData = parser.parseTileset();
    } else {
      objectData = data;
    }
    this.removeCacheTileset(objectData.name);
    this.update({
      ...this.data,
      tilesets: this.data.tilesets.map((tileset) => {
        if (tileset.name == objectData.name) {
          objectData.firstgid = tileset.firstgid;
          return objectData;
        }
        return tileset;
      })
    });
  }
  /**
   * Remove the map from the server. If there are still players on the map, an error will be thrown
   * Not delete the map file, only in memory
   *
   * @title Remove map
   * @method map.remove()
   * @since 4.0.0
   * @returns {void}
   * @throws {Error} If there are still players on the map
   * @memberof Map
   * */
  remove(ignorePlayers = false) {
    const players = Object.values(this.players);
    if (players.length > 0 && !ignorePlayers) {
      throw new Error(`Cannot remove map ${this.id} because there are still players on it`);
    }
    for (let eventId in this.events) {
      this.removeEvent(eventId);
    }
    RpgCommonMap.buffer.delete(this.id);
    World$1.removeRoom(this.id);
  }
  async parseTmx(file, relativePath = "") {
    const hasAssetsPath = !!this._server.envs.VITE_BUILT;
    const parser = new TiledParserFile(file, {
      basePath: "",
      staticDir: hasAssetsPath ? path$1.join(this._server.inputOptions.basePath, this._server.assetsPath) : "",
      relativePath
    });
    const data = await parser.parseFilePromise({
      getOnlyBasename: hasAssetsPath
    });
    return data;
  }
  loadProperties(properties) {
    for (let key in properties) {
      this[key] = properties[key];
    }
  }
  get game() {
    return this._server.gameEngine;
  }
  // Hook: called by simple-room package
  onLeave(player2) {
    this.removeObject(player2);
  }
  /**
   * Loads common events onto the game map.
   *
   * @private
   * @param {RpgClassEvent<RpgEvent>[]} commonEvents - An array of common events to load.
   * @param {RpgPlayer} [player] - The player instance on which to create the dynamic events. If not provided, the function will use the current instance.
   * @returns {void}
   */
  // @internal
  loadCommonEvents(commonEvents, player2) {
    let events2 = [];
    this.getShapes().forEach((shape) => {
      const findEvent = commonEvents.find((event) => event._name == shape.name);
      if (!findEvent)
        return;
      const {
        x: x2,
        y: y2
      } = shape.hitbox;
      events2.push({
        x: x2,
        y: y2,
        event: findEvent
      });
    });
    if (player2) {
      player2.createDynamicEvent(events2, false);
    } else {
      this.createDynamicEvent(events2);
    }
  }
  // TODO
  autoLoadEvent() {
    this.getShapes().forEach((shape) => {
      const {
        properties
      } = shape;
      const {
        x: x2,
        y: y2,
        pos,
        w: w2,
        h: h2
      } = shape.hitbox;
      if (shape.isEvent() && !this.events[shape.name]) {
        const mode = properties.mode || EventMode.Shared;
        AutoEvent.prototype["_name"] = shape.name;
        AutoEvent.mode = mode;
        AutoEvent.hitbox = {
          width: 32,
          height: 16
        };
        const event = this.createEvent({
          x: x2,
          y: y2,
          event: AutoEvent
        }, mode, shape);
        if (event)
          this.events[shape.name] = event;
      }
    });
  }
  /**
   * Edit a tile on the map. All players on the map will see the modified tile
   *
   *
   * @title Change Tile in map
   * @since 3.0.0-beta.4
   * @method map.setTile(x,y,layer,tileInfo)
   * @param {number} x Position X
   * @param {number} y Position Y
   * @param {string | ((layer: any) => boolean)} layer Name of the layer where you want to put a tile. OYou can also put a function that will act as a filter. The first parameter is the layer and you return a boolean to indicate if you modify the tile of this layer or not
   * @param {object} tileInfo Object with the following properties:
   *  - {number} gid: The tile number in tileset (from 1)
   *  - {object} properties Property of the tile. You own object. To set a collision, set the `collision:true` property
   * @example
   * ```ts
   * map.setTile(15, 18, 'mylayer', { gid: 2 })
   * ```
   * @returns {void}
   * @memberof Map
   */
  setTile(x2, y2, layerFilter, tileInfo) {
    const tiles = super.setTile(x2, y2, layerFilter, tileInfo);
    const players = Object.values(this["users"]);
    for (let player2 of players) {
      player2.emit("changeTile", tiles);
    }
    return tiles;
  }
  getEventShape(eventName) {
    return this.getShapes().find((shape) => shape.name == eventName);
  }
  /**
   * Dynamically create an event in Shared mode
   *
   * ```ts
   * @EventData({
   *  name: 'EV-1'
   * })
   * class MyEvent extends RpgEvent {
   *  onAction() {
   *      console.log('ok')
   *  }
   * }
   *
   * map.createDynamicEvent({
   *      x: 100,
   *      y: 100,
   *      event: MyEvent
   * })
   * ```
   *
   * You can also put an array of objects to create several events at once
   *
   * @title Create Dynamic Event
   * @since 3.0.0-beta.4
   * @method map.createDynamicEvent(eventObj|eventObj[])
   * @param { { x: number, y: number, z?: number, event: eventClass } } eventsList
   * @returns { { [eventId: string]: RpgEvent } }
   * @memberof Map
   */
  createDynamicEvent(eventsList) {
    if (!eventsList)
      return {};
    if (!isArray$d(eventsList)) {
      eventsList = [eventsList];
    }
    const events2 = this.createEvents(eventsList, EventMode.Shared);
    let ret = {};
    for (let key in events2) {
      this.events[key] = events2[key];
      this.events[key].updateInVirtualGrid();
      this.events[key].execMethod("onInit");
      ret = {
        ...ret,
        [key]: this.events[key]
      };
    }
    return ret;
  }
  createEvent(obj, mode, shape) {
    let event, position;
    if (obj.x === void 0) {
      event = obj;
    } else {
      event = obj.event;
      position = {
        x: obj.x,
        y: obj.y,
        z: obj.z ?? 0
      };
    }
    if ("$decorator" in event) {
      const options2 = event.$decorator;
      EventData(options2)(event);
    }
    if (event.mode != mode) {
      return null;
    }
    const ev = this.game.addEvent(event);
    const _shape = shape || this.getEventShape(ev.name);
    ev.map = this.id;
    ev.width = event.width || this.tileWidth;
    ev.height = event.height || this.tileHeight;
    if (_shape && _shape.properties)
      ev.properties = _shape.properties;
    if (event.hitbox)
      ev.setHitbox(event.hitbox.width, event.hitbox.height);
    ev.teleport(position || ev.name);
    return ev;
  }
  createEvents(eventsList, mode) {
    const events2 = {};
    if (!eventsList)
      return events2;
    for (let obj of eventsList) {
      const ev = this.createEvent(obj, mode);
      if (ev) {
        events2[ev.id] = ev;
      }
    }
    return events2;
  }
  /**
   * Allows to create a temporary hitbox on the map that can have a movement
  For example, you can use it to explode a bomb and find all the affected players, or during a sword strike, you can create a moving hitbox and find the affected players again
   * @title Create a temporary and moving hitbox
   * @since 3.2.0
   * @method map.createMovingHitbox(hitboxes,options)
   * @param {Array<{ width: number, height: number, x: number, y: number }>} hitboxes Create several hitboxes that will give an effect of movement
   * @param {object} [options]
   * @param {speed} [options.speed=1] speed of movement (in frames)
   * @returns {Observable<AbstractObject>} You find the methods of position and movement of an event
   * @memberof Map
   * @example
   *
   * ```ts
   * // Two hitboxes that will be done very quickly
   * map.createMovingHitbox(
   *   [
   *      { x: 0, y: 0, width: 100, height: 100 },
   *      { x: 20, y: 0, width: 100, height: 100 }
   *   ]
   * ).subscribe({
   *      next(hitbox) {
   *          console.log(hitbox.otherPlayersCollision)
   *      },
   *      complete() {
   *          console.log('finish')
   *      }
   * })
   * ```
   */
  createMovingHitbox(hitboxes, options2 = {}) {
    return this._createMovingHitbox(this.game, this._server.tick, this.id, hitboxes, options2);
  }
  setSync(schema) {
    return this.$setSchema(schema);
  }
  // Reflects itself. Just for compatibility with the EventManager class
  getCurrentMap() {
    return this;
  }
}
applyMixins$8(RpgMap, [EventManager]);
class RpgWorldMaps extends RpgCommonWorldMaps {
  load(world, sceneMap2) {
    for (let worldMap of world.maps) {
      const {
        fileName
      } = worldMap;
      let id, map2;
      if (worldMap.id) {
        id = worldMap.id;
      } else if (isString$b(fileName)) {
        id = extractId$1(fileName);
      }
      const create = () => sceneMap2.createDynamicMap({
        id,
        file: world.basePath ? `${world.basePath}/${fileName}` : fileName
      });
      if (!id) {
        map2 = create();
      } else {
        map2 = sceneMap2.getMapBydId(id) ?? create();
      }
      this.addMap(worldMap, map2);
    }
    return this;
  }
}
var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let SceneMap$1 = class SceneMap {
  constructor(sceneMapObject) {
    this.maps = [];
    this.mapsById = {};
    this.worldMaps = /* @__PURE__ */ new Map();
    this.server = inject$2(RpgServerEngine$1);
    const {
      maps,
      worldMaps,
      events: events2
    } = sceneMapObject;
    this.maps = maps;
    this.mapsById = {};
    RpgCommonMap.buffer.clear();
    if (this.maps) {
      for (let map2 of this.maps) {
        this.createDynamicMap(map2);
      }
    }
    if (worldMaps) {
      for (let worldMap of worldMaps) {
        this.createDynamicWorldMaps(worldMap);
      }
    }
  }
  /**
   * Returns an array of RpgClassMap objects that represent maps with static properties.
   *
   * @title Get maps
   * @method sceneMap.getMaps()
   * @returns {RpgClassMap<RpgMap>[]} Array of RpgClassMap objects.
   * @since 4.0.0
   * @example
   * ```typescript
   * const maps = scene.getMaps();
   * console.log(maps);
   * // Output: [
   * // { file: 'maps/level1.tmx', id: 'level1', type: 'map' },
   * // { file: 'maps/level2.tmx', id: 'level1', type: 'map' },
   * // { file: 'maps/level3.tmx', id: 'level1', type: 'map' }
   * // ]
   * ```
   * @memberof SceneMap
   */
  getMaps() {
    return Object.values(this.mapsById);
  }
  getMapBydId(id) {
    let mapClass = this.mapsById[id];
    if (!mapClass) {
      return null;
    }
    if (!isClass(mapClass))
      mapClass = createConstructor(mapClass);
    return mapClass;
  }
  async loadMap(id) {
    const mapClass = this.getMapBydId(id);
    if (!mapClass) {
      console.log(`Map ${id} not exists`);
      return;
    }
    let mapInstance;
    if (mapClass["buffer"].has(id)) {
      return mapClass["buffer"].get(id);
    }
    if (RpgCommonMap.buffer.has(id)) {
      mapInstance = RpgCommonMap.buffer.get(id);
    } else {
      const room2 = new mapClass(this.server);
      room2.$schema.users = [{
        ...RpgPlayer.schemas,
        ...this.server["playerProps"]
      }];
      mapInstance = World$1.addRoom(id, room2);
      await mapInstance.load();
    }
    return mapInstance;
  }
  /**
  * Loads the content of a `.world` file from Tiled Map Editor into the map scene
  *
  * > Note, that if the map already exists (i.e. you have already defined an RpgMap), the world will retrieve the already existing map. Otherwise it will create a new map
  *
  * @title Create worlds dynamically
  * @method sceneMap.createDynamicWorldMaps(world)
  * @param {object} world
  * object is
  * ```ts
  * {
  *  id?: string
  *  maps: {
  *      id?: string
  *      properties?: object
  *      fileName: string;
         height: number;
         width: number;
         x: number;
         y: number;
  *  }[],
     onlyShowAdjacentMaps: boolean, // only for Tiled Map Editor
     type: 'world' // only for Tiled Map Editor
  * }
  * ```
  *
  * @since 3.0.0-beta.8
  * @memberof SceneMap
  */
  createDynamicWorldMaps(world) {
    world.id = world.id || generateUID();
    const worldMap = new RpgWorldMaps(world.id).load(world, this);
    this.worldMaps.set(world.id, worldMap);
    return worldMap;
  }
  /**
   * Recover a world
   *
   * @title Recover a world
   * @method sceneMap.getWorldMaps(id)
   * @param {string} id world id
   * @return { RpgWorldMaps | undefined }
   * @since 3.0.0-beta.8
   * @memberof SceneMap
   */
  getWorldMaps(id) {
    return this.worldMaps.get(id);
  }
  /**
  * Delete a world
  *
  * @title Delete a world
  * @method sceneMap.deleteWorldMaps(id)
  * @param {string} id world id
  * @since 3.0.0-beta.8
  * @memberof SceneMap
  */
  deleteWorldMaps(id) {
    this.worldMaps.delete(id);
  }
  /**
   * Create a dynamic map
   *
   * Since version 3.0.0-beta.8, you can just pass the path to the file. The identifier will then be the name of the file
   *
   * @method sceneMap.createDynamicMap(mapData)
   * @title Create a dynamic map
   * @param {object | RpgMap | string} mapData The same property as [@MapData decorator](https://docs.rpgjs.dev/classes/map.html#mapdata-decorator)
   * @returns {RpgMap}
   * @since 3.0.0-beta.4
   * @memberof SceneMap
   * @example
   * ```ts
   * sceneMap.createDynamicMap({
   *      id: 'myid',
   *      file: require('./tmx/mymap.tmx')
   * })
   * ```
   *
   * And later, on the player:
   *
   * ```ts
   * player.changeMap('myid')
   * ```
   *
   * ---
   *
   * since beta.8
   *
   * ```ts
   * sceneMap.createDynamicMap(require('./tmx/mymap.tmx')) // id is "mymap"
   * ```
   */
  createDynamicMap(mapData) {
    if (isString$b(mapData)) {
      const id = extractId$1(mapData);
      if (!id) {
        throw new Error("Unable to extract the file identifier. Check that the file has only the following characters: [a-zA-Z0-9-_$!]+");
      }
      mapData = {
        id: id[1],
        file: mapData
      };
    }
    if (isTiledFormat(mapData)) {
      const tiledData = mapData;
      mapData = {
        file: {
          ...tiledData
        }
      };
    }
    if (!mapData.id)
      mapData.id = generateUID();
    if (!isClass(mapData)) {
      let DynamicMap = class DynamicMap extends RpgMap {
      };
      DynamicMap = __decorate$2([MapData(mapData)], DynamicMap);
      mapData = DynamicMap;
    }
    const map2 = mapData;
    this.mapsById[map2.id] = map2;
    return map2;
  }
  async changeMap(mapId, player2, positions) {
    const boolArray = await RpgPlugin.emit(HookServer.PlayerCanChangeMap, [player2, this.getMapBydId(mapId)], true);
    if (boolArray.some((el) => el === false)) {
      return null;
    }
    if (player2.map === mapId) {
      await player2.teleport(positions || "start");
      return null;
    }
    player2.emit("preLoadScene", {
      id: mapId
    });
    player2.prevMap = player2.map;
    if (player2.prevMap) {
      await player2.execMethod("onLeaveMap", [player2.getCurrentMap()]);
      World$1.leaveRoom(player2.prevMap, player2.id);
    }
    player2.map = mapId;
    player2.events = {};
    player2.tmpPositions = positions;
    const scalabilityArray = await RpgPlugin.emit(HookServer.ScalabilityChangeServer, player2);
    if (scalabilityArray.some((el) => el === true)) {
      return true;
    }
    player2.tmpPositions = null;
    const mapInstance = await this.loadMap(mapId);
    if (!mapInstance)
      return null;
    if (!player2.height)
      player2.height = mapInstance.tileHeight;
    if (!player2.width)
      player2.width = mapInstance.tileWidth;
    if (!player2.hitbox.h)
      player2.hitbox.h = mapInstance.tileHeight;
    if (!player2.hitbox.w)
      player2.hitbox.w = mapInstance.tileWidth;
    player2.emitSceneMap();
    if (!World$1.getRoom(mapId)) {
      return null;
    }
    player2.teleport(positions || "start");
    World$1.joinRoom(mapId, player2.id);
    player2 = World$1.getUser(player2.id);
    if (player2) {
      mapInstance.loadCommonEvents(this.server.inputOptions.events, player2);
      player2.createDynamicEvent(mapInstance._events, false);
      await player2.execMethod("onJoinMap", [mapInstance]);
    }
    return mapInstance;
  }
};
SceneMap$1.id = "map";
const {
  isString: isString$2
} = Utils$2;
class QueryClass {
  /**
   * Listen to the changes on all the rooms
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   * import { map } from 'rxjs/operators' // install rxjs
   *
   * RpgWorld.changes
   *  .pipe(
   *      map(rooms => rooms['mymap'])
   *  )
   *  .subscribe((room) => {
   *      const users: any = Object.values(room.users)
   *      console.log(users)
   *  })
   * ```
   *
   * @title Subscribe to the world
   * @prop {Observable} RpgWorld.changes
   * @memberof RpgWorld
   * */
  get changes() {
    return World$1.changes.asObservable();
  }
  /**
   * Retrieve a player according to his ID
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const player = RpgWorld.getPlayer(player) // player is RpgPlayer (player.id) or string (id)
   * ```
   *
   * @title Get Player
   * @method RpgWorld.getPlayer(player)
   * @param {RpgPlayer | string} player identifier
   * @returns {RpgPlayer}
   * @memberof RpgWorld
   */
  getPlayer(player2) {
    const id = isString$2(player2) ? player2 : "" + player2.id;
    const _player = World$1.getUser(id);
    return _player;
  }
  /**
   * Recover all the players of the game
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const players = RpgWorld.getPlayers()
   * ```
   *
   * @title Get all Players
   * @method RpgWorld.getPlayers()
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getPlayers() {
    const users = World$1.getUsers();
    const array2 = Object.values(users);
    return array2.map((user) => this.getPlayer(user));
  }
  /**
   * Recover all map objects: players and events. If you specify the `player` parameter, it also retrieves the events in scenario mode of the player in question
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const objects = RpgWorld.getObjectsOfMap('mapname')
   * console.log(objects)
   * ```
   *
   * Also retrieve events in Scenario mode:
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const objects = RpgWorld.getObjectsOfMap('mapname', 'playerid')
   * ```
   *
   * @title Get all objects of map
   * @method RpgWorld.getObjectsOfMap(map,playerId?)
   * @param {string} map Map Name
   * @param {RpgPlayer | string} playerId player identifier
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getObjectsOfMap(map2, playerId) {
    return Object.values(this._getObjectsOfMap(map2, playerId));
  }
  _getObjectsOfMap(map2, playerId) {
    const room2 = World$1.getRoom(map2);
    let player2 = null;
    if (playerId) {
      player2 = this.getPlayer(playerId);
    }
    return {
      ...room2.users,
      ...room2.events,
      ...player2 ? player2.events : {}
    };
  }
  /**
   * Find all the shapes of the map
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const shapes = RpgWorld.getShapesOfMap('mapname')
   * console.log(shapes)
   * ```
   *
   * @title Get all shapes of map
   * @method RpgWorld.getShapesOfMap(map)
   * @param {string} map Map Name
   * @returns {Array<RpgShape>}
   * @memberof RpgWorld
   */
  getShapesOfMap(map2) {
    return Object.values(this._getShapesOfMap(map2));
  }
  _getShapesOfMap(map2) {
    const room2 = World$1.getRoom(map2);
    return room2.shapes;
  }
  // TODO
  getRooms() {
    return World$1.getRooms();
  }
  getRoom(name2) {
    return World$1.getRoom(name2);
  }
  /**
   * Recover all the players of a map
   *
   * ```ts
   * import { RpgWorld } from '@rpgjs/server'
   *
   * const players = RpgWorld.getPlayersOfMap('mapname')
   * ```
   *
   * @title Get all Players a map
   * @method RpgWorld.getPlayersOfMap(map)
   * @param {string} map Map Name
   * @returns {Array<RpgPlayer>}
   * @memberof RpgWorld
   */
  getPlayersOfMap(map2) {
    const room2 = World$1.getRoom(map2);
    return Object.values(room2.users);
  }
}
const Query = new QueryClass();
var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
let RpgServerEngine$1 = class RpgServerEngine {
  constructor() {
    this.database = {};
    this.globalConfig = {};
    this.damageFormulas = {};
    this.serverId = {}.SERVER_ID || generateUID();
    this.scenes = /* @__PURE__ */ new Map();
    this.totalConnected = 0;
    this.scheduler = new Scheduler();
    this.gameEngine = inject$2(RpgCommonGame);
    this.world = World$1;
    this.envs = {};
    this.inputOptions = {};
  }
  /**
   * Combat formulas
   *
   * @prop {Socket Io Server} [io]
   * @memberof RpgServerEngine
   */
  initialize(io, inputOptions) {
    this.io = io;
    this.inputOptions = inputOptions;
    this.envs = inputOptions.envs || {};
    if (this.inputOptions.workers) {
      console.log("workers enabled");
      this.workers = this.gameEngine.createWorkers(this.inputOptions.workers).load();
    }
  }
  async _init() {
    this.damageFormulas = this.inputOptions.damageFormulas || {};
    this.damageFormulas = {
      damageSkill: DAMAGE_SKILL,
      damagePhysic: DAMAGE_PHYSIC,
      damageCritical: DAMAGE_CRITICAL,
      coefficientElements: COEFFICIENT_ELEMENTS,
      ...this.damageFormulas
    };
    this.globalConfig = this.inputOptions.globalConfig;
    if (!this.inputOptions.maps)
      this.inputOptions.maps = [];
    if (!this.inputOptions.events)
      this.inputOptions.events = [];
    if (!this.inputOptions.worldMaps)
      this.inputOptions.worldMaps = [];
    this.playerProps = this.inputOptions.playerProps;
    this.inputOptions.maps = [...arrayFlat$2(await RpgPlugin.emit(HookServer.AddMap, this.inputOptions.maps)) || [], ...this.inputOptions.maps];
    this.inputOptions.events = [...arrayFlat$2(await RpgPlugin.emit(HookServer.AddEvent, this.inputOptions.events)) || [], ...this.inputOptions.events];
    this.inputOptions.worldMaps = [...arrayFlat$2(await RpgPlugin.emit(HookServer.AddWorldMaps, this.inputOptions.worldMaps)) || [], ...this.inputOptions.worldMaps];
    this.globalConfig.inputs = {
      ...DefaultInput,
      ...this.globalConfig.inputs || {}
    };
    if (!this.inputOptions.database)
      this.inputOptions.database = {};
    const datas = await RpgPlugin.emit(HookServer.AddDatabase, this.inputOptions.database) || [];
    for (let element of datas) {
      if (Array.isArray(element)) {
        for (let data of element) {
          this.addInDatabase(data.id, data);
        }
      } else {
        for (let id in element) {
          this.addInDatabase(element[id].id ?? id, element[id]);
        }
      }
    }
    this.loadScenes();
  }
  /**
   * Adds data to the server's database (in RAM) for later use
   *
   *
   * @method server.addInDatabase(id,data)
   * @title Add in database
   * @param {number} id resource id
   * @param {class | object} dataClass A class representing the data. You can just add a object if you specify the type
   * @enum {string} [type] The type of data
   *
   * item
   * weapon
   * armor
   * skill
   * class
   * state
   * actor
   * @since 3.0.0-beta.4
   * @example
   * ```ts
   * @Item({
   *      name: 'Potion',
   *      description: 'Gives 100 HP',
   * })
   * class MyItem() {}
   *
   * server.addInDatabase('dynamic_item', MyItem)
   * ```
   *
   * or with an object
   *
   * ```ts
   * server.addInDatabase('dynamic_item', {
   *      name: 'Potion',
   *      description: 'Gives 100 HP',
   * }, 'item')
   * ```
   *
   * @returns {void}
   * @memberof RpgServerEngine
   */
  addInDatabase(id, dataClass, type) {
    if (isClass(dataClass)) {
      this.database[id] = dataClass;
      return;
    }
    if (!type) {
      throw new Error(`You must specify a type for the database ${id}`);
    }
    switch (type) {
      case "item":
        let ItemClass = class ItemClass {
        };
        ItemClass = __decorate$1([Item(dataClass)], ItemClass);
        this.database[id] = ItemClass;
        break;
      case "weapon":
        let WeaponClass = class WeaponClass {
        };
        WeaponClass = __decorate$1([Weapon(dataClass)], WeaponClass);
        this.database[id] = WeaponClass;
        break;
      case "armor":
        let ArmorClass = class ArmorClass {
        };
        ArmorClass = __decorate$1([Armor(dataClass)], ArmorClass);
        this.database[id] = ArmorClass;
        break;
      case "skill":
        let SkillClass = class SkillClass {
        };
        SkillClass = __decorate$1([Skill(dataClass)], SkillClass);
        this.database[id] = SkillClass;
        break;
      case "class":
        let ClassClass = class ClassClass {
        };
        ClassClass = __decorate$1([Class(dataClass)], ClassClass);
        this.database[id] = ClassClass;
        break;
      case "state":
        let StateClass = class StateClass {
        };
        StateClass = __decorate$1([State$1(dataClass)], StateClass);
        this.database[id] = StateClass;
        break;
      case "actor":
        let ActorClass = class ActorClass {
        };
        ActorClass = __decorate$1([Actor(dataClass)], ActorClass);
        this.database[id] = ActorClass;
        break;
    }
  }
  /**
  * Start the RPG server
  *
  * @method server.start()
  * @title Start Server
  * @returns {void}
  * @memberof RpgServerEngine
  */
  async start(inputOptions, scheduler = true) {
    if (inputOptions)
      this.inputOptions = inputOptions;
    await this._init();
    this.tick.subscribe(({
      timestamp,
      deltaTime
    }) => {
      this.step(timestamp, deltaTime);
    });
    if (scheduler)
      this.scheduler.start({
        fps: (inputOptions == null ? void 0 : inputOptions.fps) || 60
      });
    this.gameEngine.start({
      getObject(id) {
        return Query.getPlayer(id);
      },
      getObjectsOfGroup(groupId, player2) {
        return Query._getObjectsOfMap(groupId, player2);
      },
      getShapesOfGroup(map2) {
        return Query._getShapesOfMap(map2);
      }
    });
    this.transport(this.io);
    await RpgPlugin.emit(HookServer.Start, this);
  }
  transport(io) {
    const timeoutDisconnect = this.globalConfig.timeoutDisconnect ?? 0;
    const auth = this.globalConfig.disableAuth ? () => generateUID() : async (socket) => {
      const val = await RpgPlugin.emit(HookServer.Auth, [this, socket], true);
      if (val.length == 0) {
        return generateUID();
      }
      return val[val.length - 1];
    };
    const transport = new Transport(io, {
      timeoutDisconnect,
      auth
    });
    this.world.timeoutDisconnect = timeoutDisconnect;
    transport.onConnected(this.onPlayerConnected.bind(this));
    transport.onDisconnected(this.onPlayerDisconnected.bind(this));
    return transport;
  }
  get tick() {
    return this.scheduler.tick;
  }
  /**
   * Sends all packages to clients. The sending is done automatically but you can decide to send yourself by calling this method (for example, for unit tests)
   *
   * @method server.send()
   * @title Send All Packets
   * @returns {void}
   * @memberof RpgServerEngine
   */
  send() {
    return this.world.send();
  }
  async updatePlayersMove(deltaTimeInt) {
    const players = this.world.getUsers();
    const obj = [];
    let p2 = [];
    for (let playerId in players) {
      const playerInstance = players[playerId]["proxy"];
      if (!playerInstance)
        continue;
      const player2 = playerInstance.otherPossessedPlayer ?? playerInstance;
      if (player2.pendingMove.length > 0) {
        const lastFrame = player2.pendingMove[player2.pendingMove.length - 1];
        if (this.inputOptions.workers)
          obj.push(player2.toObject());
        else {
          p2.push(this.gameEngine.processInput(player2.playerId, this.globalConfig.inputs).then((val) => {
            player2.pendingMove = [];
            player2.moving = false;
            player2._lastFramePositions = {
              frame: lastFrame.frame,
              position: {
                ...player2.position
              }
            };
            return player2;
          }));
        }
      }
    }
    if (this.inputOptions.workers) {
      this.workers.call("movePlayers", obj).then((players2) => {
        for (let playerId in players2) {
          const player2 = this.world.getUser(playerId);
          const data = players2[playerId];
          if (player2) {
            player2.position = data.position;
            player2.direction = data.direction;
          }
          RpgPlugin.emit("Server.onInput", [player2, {
            input: data.direction,
            moving: true
          }], true);
        }
      });
    }
    return Promise.all(p2);
  }
  nextTick(timestamp) {
    this.scheduler.nextTick(timestamp);
  }
  step(t2, dt) {
    this.updatePlayersMove(1);
    if (this.scheduler.frame % 4 === 0) {
      this.send();
    }
    RpgPlugin.emit(HookServer.Step, this);
  }
  loadScenes() {
    this.scenes.set(SceneMap$1.id, new SceneMap$1({
      maps: this.inputOptions.maps,
      events: this.inputOptions.events,
      worldMaps: this.inputOptions.worldMaps
    }));
  }
  getScene(name2) {
    return this.scenes.get(name2);
  }
  /**
   * Return the scene that manages the maps of the game
   * @prop {SceneMap} [sceneMap]
   * @since 3.0.0-beta.4
   * @memberof RpgServerEngine
   */
  get sceneMap() {
    return this.getScene(SceneMap$1.id);
  }
  get module() {
    return RpgPlugin;
  }
  get assetsPath() {
    var _a;
    return ((_a = this.envs) == null ? void 0 : _a["VITE_ASSETS_PATH"]) || "assets";
  }
  sendToPlayer(currentPlayer, eventName, data) {
    currentPlayer._socket.emit(eventName, data);
  }
  getPlayerBySession(session) {
    const users = this.world.getUsers();
    for (let userId in users) {
      const user = users[userId];
      if (user.session === session) {
        return user;
      }
    }
    return null;
  }
  onPlayerConnected(socket, playerId) {
    const existingUser = this.world.getUser(playerId, false);
    this.world.connectUser(socket, playerId);
    let player2;
    if (!existingUser) {
      const {
        token
      } = socket.handshake.auth;
      player2 = new RpgPlayer(playerId);
      player2.session = token;
      this.world.setUser(player2, socket);
      player2._init();
      if (!token) {
        const newToken = generateUID() + "-" + generateUID() + "-" + generateUID();
        player2.session = newToken;
      }
      if (!token) {
        player2.execMethod("onConnected");
      } else {
        RpgPlugin.emit(HookServer.ScalabilityPlayerConnected, player2);
      }
    } else {
      player2 = existingUser;
      if (player2.map) {
        player2.emit("preLoadScene", {
          reconnect: true,
          id: player2.map
        });
        player2.emitSceneMap();
        this.world.joinRoom(player2.map, playerId);
      }
    }
    socket.emit("playerJoined", {
      playerId,
      session: player2.session
    });
    socket.on("move", (data) => {
      if (!(data == null ? void 0 : data.input))
        return;
      if (!Array.isArray(data.input))
        return;
      const controlPlayer = player2.otherPossessedPlayer ?? player2;
      if (!controlPlayer.canMove) {
        return;
      }
      for (let input of data.input) {
        controlPlayer.pendingMove.push({
          input,
          frame: data.frame
        });
      }
    });
  }
  onPlayerDisconnected(playerId) {
    const player2 = World$1.getUser(playerId);
    player2.execMethod("onDisconnected");
    this.world.disconnectUser(playerId);
  }
  stop() {
    this.scheduler.stop();
  }
};
class RpgMatchMaker {
  constructor(options2) {
    this.options = options2;
    this.endpoint = options2.endpoint;
    this.headers = options2.headers;
    this.callback = options2.callback;
  }
  async getServer(player2) {
    const currentServerId = inject$2(RpgServerEngine$1).serverId;
    const payload = {
      playerId: player2.id,
      mapName: player2.map
    };
    let res = {};
    if (this.callback) {
      res = this.callback(payload);
      if (isPromise$3(res)) {
        res = await res;
      }
    }
    if (this.endpoint) {
      try {
        res = await axios$1.post(this.endpoint, payload, {
          headers: this.headers
        }).then((res2) => res2.data);
      } catch (err) {
        console.log("There is a problem with the MatchMaker webservice.");
        throw err;
      }
    }
    if (currentServerId == res.serverId) {
      return null;
    }
    return res;
  }
}
async function entryPointServer(modules, options2) {
  const context2 = new InjectContext();
  setInject$1(context2);
  inject$2(RpgCommonGame, [GameSide.Server]);
  if (!options2.globalConfig)
    options2.globalConfig = {};
  const relations = {
    onConnected: HookServer.PlayerConnected,
    onInput: HookServer.PlayerInput,
    onJoinMap: HookServer.PlayerJoinMap,
    onLeaveMap: HookServer.PlayerLeaveMap,
    onLevelUp: HookServer.PlayerLevelUp,
    onDead: HookServer.PlayerDead,
    onDisconnected: HookServer.PlayerDisconnected,
    onInShape: HookServer.PlayerInShape,
    onOutShape: HookServer.PlayerOutShape,
    onMove: HookServer.PlayerMove,
    canChangeMap: HookServer.PlayerCanChangeMap
  };
  const relationsEngine = {
    onStart: HookServer.Start,
    onStep: HookServer.Step,
    auth: HookServer.Auth
  };
  const {
    playerProps
  } = await loadModules(modules, {
    side: "server",
    relations: {
      player: relations,
      engine: relationsEngine,
      scalability: {
        onConnected: HookServer.ScalabilityPlayerConnected,
        doChangeServer: HookServer.ScalabilityChangeServer
      }
    }
  }, (mod) => {
    const {
      scalability
    } = mod;
    if (scalability) {
      const {
        hooks,
        stateStore,
        matchMaker
      } = scalability;
      const matchMakerInstance = new RpgMatchMaker(matchMaker);
      RpgPlugin.on(HookServer.Start, () => {
        return stateStore.connect();
      });
      mod.scalability._hooks = {};
      for (let hookName in hooks) {
        let originalHook = mod.scalability.hooks[hookName];
        mod.scalability._hooks[hookName] = function(player2) {
          return originalHook(stateStore, matchMakerInstance, player2);
        };
      }
    }
    return mod;
  });
  const serverEngine = inject$2(RpgServerEngine$1, [options2.io, {
    debug: {},
    updateRate: 10,
    stepRate: 60,
    timeoutInterval: 0,
    countConnections: false,
    playerProps,
    ...options2
  }]);
  return serverEngine;
}
class Monitor extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this.monitors = /* @__PURE__ */ new Map();
    this.totalConnected = 0;
  }
  get status() {
    return {
      loop: this.loopMs,
      totalConnected: this.totalConnected
    };
  }
  getStatusOf(id) {
    return this.monitors.get(id);
  }
  update(server2) {
    const {
      scheduler,
      options: options2
    } = server2;
    if (this.lastTime) {
      const hrtime2 = browser$1$1.hrtime(this.lastTime);
      this.loopMs = hrtime2[1] / 1e6;
    }
    const period = scheduler.options.period;
    if (this.loopMs > period + 20) {
      const {
        stepRate
      } = options2;
      console.warn("%s - Warning Low FPS. %s players connected. Game Loop: %s FPS", /* @__PURE__ */ new Date(), this.totalConnected, Math.round(stepRate / (this.loopMs / period)));
    }
    this.lastTime = browser$1$1.hrtime();
  }
  addMonitor(socket) {
    this.totalConnected++;
  }
  removeMonitor(id) {
    this.monitors.delete(id);
    this.totalConnected--;
  }
}
new Monitor();
const keyCodeTable = {
  3: "break",
  8: "backspace",
  9: "tab",
  12: "clear",
  13: "enter",
  16: "shift",
  17: "ctrl",
  18: "alt",
  19: "pause/break",
  20: "caps lock",
  27: "escape",
  28: "conversion",
  29: "non-conversion",
  32: "space",
  33: "page up",
  34: "page down",
  35: "end",
  36: "home",
  37: Direction.Left,
  38: Direction.Up,
  39: Direction.Right,
  40: Direction.Down,
  41: "select",
  42: "print",
  43: "execute",
  44: "Print Screen",
  45: "insert",
  46: "delete",
  48: "n0",
  49: "n1",
  50: "n2",
  51: "n3",
  52: "n4",
  53: "n5",
  54: "n6",
  55: "n7",
  56: "n8",
  57: "n9",
  58: ":",
  59: "semicolon (firefox), equals",
  60: "<",
  61: "equals (firefox)",
  63: "ß",
  64: "@",
  65: "a",
  66: "b",
  67: "c",
  68: "d",
  69: "e",
  70: "f",
  71: "g",
  72: "h",
  73: "i",
  74: "j",
  75: "k",
  76: "l",
  77: "m",
  78: "n",
  79: "o",
  80: "p",
  81: "q",
  82: "r",
  83: "s",
  84: "t",
  85: "u",
  86: "v",
  87: "w",
  88: "x",
  89: "y",
  90: "z",
  91: "Windows Key / Left ⌘ / Chromebook Search key",
  92: "right window key",
  93: "Windows Menu / Right ⌘",
  96: "numpad 0",
  97: "numpad 1",
  98: "numpad 2",
  99: "numpad 3",
  100: "numpad 4",
  101: "numpad 5",
  102: "numpad 6",
  103: "numpad 7",
  104: "numpad 8",
  105: "numpad 9",
  106: "multiply",
  107: "add",
  108: "numpad period (firefox)",
  109: "subtract",
  110: "decimal point",
  111: "divide",
  112: "f1",
  113: "f2",
  114: "f3",
  115: "f4",
  116: "f5",
  117: "f6",
  118: "f7",
  119: "f8",
  120: "f9",
  121: "f10",
  122: "f11",
  123: "f12",
  124: "f13",
  125: "f14",
  126: "f15",
  127: "f16",
  128: "f17",
  129: "f18",
  130: "f19",
  131: "f20",
  132: "f21",
  133: "f22",
  134: "f23",
  135: "f24",
  144: "num lock",
  145: "scroll lock",
  160: "^",
  161: "!",
  163: "#",
  164: "$",
  165: "ù",
  166: "page backward",
  167: "page forward",
  169: "closing paren (AZERTY)",
  170: "*",
  171: "~ + * key",
  173: "minus (firefox), mute/unmute",
  174: "decrease volume level",
  175: "increase volume level",
  176: "next",
  177: "previous",
  178: "stop",
  179: "play/pause",
  180: "e-mail",
  181: "mute/unmute (firefox)",
  182: "decrease volume level (firefox)",
  183: "increase volume level (firefox)",
  186: "semi-colon / ñ",
  187: "equal sign",
  188: "comma",
  189: "dash",
  190: "period",
  191: "forward slash / ç",
  192: "grave accent / ñ / æ",
  193: "?, / or °",
  194: "numpad period (chrome)",
  219: "open bracket",
  220: "back slash",
  221: "close bracket / å",
  222: "single quote / ø",
  223: "`",
  224: "left or right ⌘ key (firefox)",
  225: "altgr",
  226: "< /git >",
  230: "GNOME Compose Key",
  231: "ç",
  233: "XF86Forward",
  234: "XF86Back",
  240: "alphanumeric",
  242: "hiragana/katakana",
  243: "half-width/full-width",
  244: "kanji",
  255: "toggle touchpad"
};
const directionCode = {
  [Direction.Up]: 1,
  [Direction.Right]: 2,
  [Direction.Down]: 3,
  [Direction.Left]: 4
};
const {
  isArray: isArray$3
} = Utils$2;
const inverse = (obj) => {
  const newObj = {};
  for (let key in obj) {
    const val = obj[key];
    newObj[val] = key;
  }
  return newObj;
};
const inverseKeyCodeTable = inverse(keyCodeTable);
class KeyboardControls {
  constructor(context2) {
    this.context = context2;
    this.clientEngine = this.context.inject(RpgClientEngine$4);
    this.keyState = {};
    this.boundKeys = {};
    this.stop = false;
    this.lastKeyPressed = null;
    this._controlsOptions = {};
    const {
      globalConfig
    } = this.clientEngine;
    this.setupListeners();
    this.setInputs({
      ...DefaultInput,
      ...globalConfig.inputs || {}
    });
  }
  /** @internal */
  preStep() {
    if (this.stop)
      return;
    const boundKeys = Object.keys(this.boundKeys);
    const applyInput = (keyName) => {
      const keyState = this.keyState[keyName];
      if (!keyState)
        return;
      const {
        isDown,
        count
      } = keyState;
      if (isDown) {
        const {
          repeat,
          method
        } = this.boundKeys[keyName].options;
        if (repeat || count == 0) {
          let parameters = this.boundKeys[keyName].parameters;
          if (typeof parameters === "function") {
            parameters = parameters();
          }
          if (method) {
            method(this.boundKeys[keyName]);
          } else {
            this.clientEngine.sendInput(this.boundKeys[keyName].actionName);
          }
          this.keyState[keyName].count++;
        }
      }
    };
    for (let keyName of boundKeys) {
      applyInput(keyName);
    }
  }
  // TODO, merge direction
  directionToAngle() {
    var _a;
    let directionVal = 0;
    let nbFound = 0;
    for (let keyName of Object.keys(this.boundKeys)) {
      if ((_a = this.keyState[keyName]) == null ? void 0 : _a.isDown) {
        if (directionCode[keyName]) {
          this.keyState[keyName] = null;
          directionVal += directionCode[keyName];
          nbFound++;
        }
      }
    }
    if (!nbFound)
      return;
    const index2 = directionVal / nbFound;
    if (this.keyState[index2] !== null) {
      this.keyState[index2] = {
        count: 0,
        isDown: true
      };
    }
    this.keyState[index2].isDown = true;
  }
  setupListeners() {
    document.addEventListener("keydown", (e3) => {
      this.onKeyChange(e3, true);
    });
    document.addEventListener("keyup", (e3) => {
      this.onKeyChange(e3, false);
    });
  }
  bindKey(keys2, actionName, options2, parameters) {
    if (!isArray$3(keys2))
      keys2 = [keys2];
    const keyOptions = Object.assign({
      repeat: false
    }, options2);
    keys2.forEach((keyName) => {
      this.boundKeys[keyName] = {
        actionName,
        options: keyOptions,
        parameters
      };
    });
  }
  applyKeyDown(name2) {
    const code = inverseKeyCodeTable[name2];
    const e3 = new Event("keydown");
    e3.keyCode = code;
    this.onKeyChange(e3, true);
  }
  applyKeyUp(name2) {
    const code = inverseKeyCodeTable[name2];
    const e3 = new Event("keyup");
    e3.keyCode = code;
    this.onKeyChange(e3, false);
  }
  applyKeyPress(name2) {
    return new Promise((resolve2) => {
      this.applyKeyDown(name2);
      setTimeout(() => {
        this.applyKeyUp(name2);
        resolve2();
      }, 200);
    });
  }
  onKeyChange(e3, isDown) {
    e3 = e3 || window.event;
    const keyName = keyCodeTable[e3.keyCode];
    if (keyName && this.boundKeys[keyName]) {
      if (this.keyState[keyName] == null) {
        this.keyState[keyName] = {
          count: 0,
          isDown: true
        };
      }
      this.keyState[keyName].isDown = isDown;
      if (!isDown) {
        this.keyState[keyName].count = 0;
      }
      this.lastKeyPressed = isDown ? e3.keyCode : null;
    }
    if (isDown)
      this.clientEngine.keyChange.next(keyName);
  }
  /**
   * From the name of the entry, we retrieve the control information
   *
   * ```ts
   * import { Input, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.getControl(Input.Enter)
    * if (control) {
   *    console.log(control.actionName) // action
   * }
   * ```
   * @title Get Control
   * @method getControl(inputName)
   * @param {string} inputName
   * @returns { { actionName: string, options: any } | undefined }
   * @memberof KeyboardControls
   */
  getControl(inputName) {
    return this.boundKeys[inputName];
  }
  /**
   * Returns all controls
   *
   * @method getControls()
   * @since 4.2.0
   * @returns { { [key: string]: BoundKey } }
   * @memberof KeyboardControls
   */
  getControls() {
    return this.boundKeys;
  }
  /**
   * Triggers an input according to the name of the control
   *
   * ```ts
   * import { Control, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.applyControl(Control.Action)
   * ```
   *
   * You can put a second parameter or indicate on whether the key is pressed or released
   *
   * ```ts
   * import { Control, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.applyControl(Control.Up, true) // keydown
   * controls.applyControl(Control.Up, false) // keyup
   * ```
   * @title Apply Control
   * @method applyControl(controlName,isDown)
   * @param {string} controlName
   * @param {boolean} [isDown]
   * @returns {Promise<void>}
   * @memberof KeyboardControls
   */
  async applyControl(controlName, isDown) {
    const control = this._controlsOptions[controlName];
    if (control) {
      const input = isArray$3(control.bind) ? control.bind[0] : control.bind;
      if (isDown === void 0) {
        await this.applyKeyPress(input);
      } else if (isDown) {
        this.applyKeyDown(input);
      } else {
        this.applyKeyUp(input);
      }
    }
  }
  /**
   * Stop listening to the inputs. Pressing a key won't do anything
   *
   * @title Stop Inputs
   * @method stopInputs()
   * @returns {void}
   * @memberof KeyboardControls
   */
  stopInputs() {
    this.stop = true;
  }
  /**
   * Listen to the inputs again
   *
   * @title Listen Inputs
   * @method listenInputs()
   * @returns {void}
   * @memberof KeyboardControls
   */
  listenInputs() {
    this.stop = false;
    this.keyState = {};
  }
  /**
   * Assign custom inputs to the scene
   *
   * The object is the following:
   *
   * * the key of the object is the name of the control. Either it is existing controls (Up, Dow, Left, Right, Action, Back) or customized controls
   * * The value is an object representing control information:
   *      * repeat {boolean} The key can be held down to repeat the action. (false by default)
   *      * bind {string | string[]} To which key is linked the control
   *      * method {Function} Function to be triggered. If you do not set this property, the name of the control is sent directly to the server.
   *      * delay {object|number} (since v3.2.0) Indicates how long (in milliseconds) the player can press the key again to perform the action
   *          * delay.duration
   *          * delay.otherControls {string | string[]} Indicates the other controls that will also have the delay at the same time
   *
   * ```ts
   * import { Control, Input, inject, KeyboardControls } from '@rpgjs/client'
   *
   * const controls = inject(KeyboardControls)
   * controls.setInputs({
          [Control.Up]: {
              repeat: true,
              bind: Input.Up
          },
          [Control.Down]: {
              repeat: true,
              bind: Input.Down
          },
          [Control.Right]: {
              repeat: true,
              bind: Input.Right
          },
          [Control.Left]: {
              repeat: true,
              bind: Input.Left
          },
          [Control.Action]: {
              bind: [Input.Space, Input.Enter]
          },
          [Control.Back]: {
              bind: Input.Escape
          },
           // The myscustom1 control is sent to the server when the A key is pressed.
          mycustom1: {
              bind: Input.A
          },
           // the myAction method is executed when the B key is pressed
          mycustom2: {
              bind: Input.B,
              method({ actionName }) {
                  console.log('cool', actionName)
              }
          },
           // The player can redo the action after 400ms
          mycustom3: {
              bind: Input.C,
              delay: 400 // ms
          },
           // The player can redo the action (mycustom4) and the directions after 400ms
          mycustom4: {
              bind: Input.C,
              delay: {
                  duration: 400,
                  otherControls: [Control.Up, Control.Down, Control.Left, Control.Right]
              }
          }
      })
   *
   * ```
   * @enum {string} Control
   *
   * Control.Up | up
   * Control.Down | down
   * Control.Left | left
   * Control.Right | right
   * Control.Action | action
   * Control.Back | back
   *
   * @enum {string} Mouse Event
   *
   * click | Click
   * dblclick | Double Click
   * mousedown | Mouse Down
   * mouseup | Mouse Up
   * mouseover | Mouse Over
   * mousemove | Mouse Move
   * mouseout | Mouse Out
   * contextmenu | Context Menu
   *
   *
   * @enum {string} Input
   *
   * break | Pause
  * backspace | Backspace / Delete
  * tab | Tab
  * clear | Clear
  * enter | Enter
  * shift | Shift
  * ctrl | Control
  * alt | Alt
  * pause/break | Pause / Break
  * caps lock | Caps Lock
  * escape | Escape
  * conversion | Conversion
  * non-conversion | Non-conversion
  * space | Space
  * page up | Page Up
  * page down | Page Down
  * end | End
  * home | Home
  * left | Left Arrow
  * up | Up Arrow
  * right | Right Arrow
  * down | Down Arrow
  * select | Select
  * print | Print
  * execute | Execute
  * Print Screen | Print Screen
  * insert | Insert
  * delete | Delete
  * n0 | 0
  * n1 | 1
  * n2 | 2
  * n3 | 3
  * n4 | 4
  * n5 | 5
  * n6 | 6
  * n7 | 7
  * n8 | 8
  * n9 | 9
  * : | Colon
  * semicolon (firefox), equals | Semicolon (Firefox), Equals
  * < | Less Than
  * equals (firefox) | Equals (Firefox)
  * ß | Eszett
  * @ | At
  * a | A
  * b | B
  * c | C
  * d | D
  * e | E
  * f | F
  * g | G
  * h | H
  * i | I
  * j | J
  * k | K
  * l | L
  * m | M
  * n | N
  * o | O
  * p | P
  * q | Q
  * r | R
  * s | S
  * t | T
  * u | U
  * v | V
  * w | W
  * x | X
  * y | Y
  * z | Z
  * Windows Key / Left ⌘ / Chromebook Search key | Windows Key / Left Command ⌘ / Chromebook Search Key
  * right window key | Right Windows Key
  * Windows Menu / Right ⌘ | Windows Menu / Right Command ⌘
  * numpad 0 | Numpad 0
  * numpad 1 | Numpad 1
  * numpad 2 | Numpad 2
  * numpad 3 | Numpad 3
  * numpad 4 | Numpad 4
  * numpad 5 | Numpad 5
  * numpad 6 | Numpad 6
  * numpad 7 | Numpad 7
  * numpad 8 | Numpad 8
  * numpad 9 | Numpad 9
  * multiply | Multiply
  * add | Add
  * numpad period (firefox) | Numpad Period (Firefox)
  * subtract | Subtract
  * decimal point | Decimal Point
  * divide | Divide
  * f1 | F1
  * f2 | F2
  * f3 | F3
  * f4 | F4
  * f5 | F5
  * f6 | F6
  * f7 | F7
  * f8 | F8
  * f9 | F9
  * f10 | F10
  * f11 | F11
  * f12 | F12
  * f13 | F13
  * f14 | F14
  * f15 | F15
  * f16 | F16
  * f17 | F17
  * f18 | F18
  * f19 | F19
  * f20 | F20
  * f21 | F21
  * f22 | F22
  * f23 | F23
  * f24 | F24
  * num lock | Num Lock
  * scroll lock | Scroll Lock
  * ^ | Caret
  * ! | Exclamation Point
  * # | Hash
  * $ | Dollar Sign
  * ù | Grave Accent U
  * page backward | Page Backward
  * page forward | Page Forward
  * closing paren (AZERTY) | Closing Parenthesis (AZERTY)
  * * | Asterisk
  * ~ + * key | Tilde + Asterisk Key
  * minus (firefox), mute/unmute | Minus (Firefox), Mute/Unmute
  * decrease volume level | Decrease Volume Level
  * increase volume level | Increase Volume Level
  * next | Next
  * previous | Previous
  * stop | Stop
  * play/pause | Play/Pause
  * e-mail | Email
  * mute/unmute (firefox) | Mute/Unmute (Firefox)
  * decrease volume level (firefox) | Decrease Volume Level (Firefox)
  * increase volume level (firefox) | Increase Volume Level (Firefox)
  * semi-colon / ñ | Semicolon / ñ
  * equal sign | Equal Sign
  * comma | Comma
  * dash | Dash
  * period | Period
  * forward slash / ç | Forward Slash / ç
  * grave accent / ñ / æ | Grave Accent / ñ / æ
  * ?, / or ° | ?, / or °
  * numpad period (chrome) | Numpad Period (Chrome)
  * open bracket | Open Bracket
  * back slash | Backslash
  * close bracket / å | Close Bracket / å
  * single quote / ø | Single Quote / ø
  * \` | Backtick
  * left or right ⌘ key (firefox) | Left or Right Command Key (Firefox)
  * altgr | AltGr
  * < /git > | < /git >
  * GNOME Compose Key | GNOME Compose Key
  * ç | ç
  * XF86Forward | XF86Forward
  * XF86Back | XF86Back
  * alphanumeric | Alphanumeric
  * hiragana/katakana | Hiragana/Katakana
  * half-width/full-width | Half-Width/Full-Width
  * kanji | Kanji
  * toggle touchpad | Toggle Touchpad
   *
   * @title Set Inputs
   * @method setInputs(inputs)
   * @param {object} inputs
   * @memberof KeyboardControls
   */
  setInputs(inputs) {
    if (!inputs)
      return;
    this.boundKeys = {};
    let inputsTransformed = {};
    for (let control in inputs) {
      const bind2 = inputs[control].bind;
      const transformBind = Array.isArray(bind2) ? bind2.map((b3) => this.transformDirectionInNumber(b3)) : this.transformDirectionInNumber(bind2);
      inputsTransformed[this.transformDirectionInNumber(control)] = {
        ...inputs[control],
        bind: transformBind
      };
    }
    for (let control in inputsTransformed) {
      const option = inputsTransformed[control];
      const {
        method,
        bind: bind2
      } = option;
      if (method) {
        option.method = method;
      }
      let inputsKey = bind2;
      if (!isArray$3(inputsKey)) {
        inputsKey = [bind2];
      }
      for (let input of inputsKey) {
        this.bindKey(input, control, option);
      }
    }
    this._controlsOptions = inputsTransformed;
  }
  get options() {
    return this._controlsOptions;
  }
  transformDirectionInNumber(direction) {
    switch (direction) {
      case "up":
        return 1;
      case "down":
        return 3;
      case "left":
        return 4;
      case "right":
        return 2;
    }
    return direction;
  }
}
var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});
const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url2, options2) => fetch(url2, options2),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};
const settings = {
  ADAPTER: BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
const isMobileCall = isMobile$1.default ?? isMobile$1;
const isMobile = isMobileCall(globalThis.navigator);
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context2, once3) {
    this.fn = fn;
    this.context = context2;
    this.once = once3 || false;
  }
  function addListener3(emitter, event, fn, context2, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter3() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter3.prototype.eventNames = function eventNames2() {
    var names = [], events2, name2;
    if (this._eventsCount === 0)
      return names;
    for (name2 in events2 = this._events) {
      if (has2.call(events2, name2))
        names.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter3.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter3.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter3.prototype.emit = function emit3(event, a12, a23, a32, a42, a52) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a12), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a12, a23), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a12, a23, a32), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a12, a23, a32, a42), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a12, a23, a32, a42, a52), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j2;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a12);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a12, a23);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a12, a23, a32);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter3.prototype.on = function on2(event, fn, context2) {
    return addListener3(this, event, fn, context2, false);
  };
  EventEmitter3.prototype.once = function once3(event, fn, context2) {
    return addListener3(this, event, fn, context2, true);
  };
  EventEmitter3.prototype.removeListener = function removeListener3(event, fn, context2, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context2 || listeners2.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length = listeners2.length; i2 < length; i2++) {
        if (listeners2[i2].fn !== fn || once3 && !listeners2[i2].once || context2 && listeners2[i2].context !== context2) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners3(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
  EventEmitter3.prefixed = prefix;
  EventEmitter3.EventEmitter = EventEmitter3;
  {
    module.exports = EventEmitter3;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter2 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x2 = data[i2];
      y2 = data[i2 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i2, last2;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
  }
  if (last2 && equals2(last2, last2.next)) {
    removeNode(last2);
    last2 = last2.next;
  }
  return last2;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals2(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a8 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a8, b3, c3) >= 0)
    return false;
  var ax = a8.x, bx = b3.x, cx = c3.x, ay = a8.y, by = b3.y, cy = c3.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p2 = c3.next;
  while (p2 !== a8) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a8 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a8, b3, c3) >= 0)
    return false;
  var ax = a8.x, bx = b3.x, cx = c3.x, ay = a8.y, by = b3.y, cy = c3.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a8 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a8 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a8 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a8 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a8 = p2.prev, b3 = p2.next.next;
    if (!equals2(a8, b3) && intersects(a8, p2, p2.next, b3) && locallyInside(a8, b3) && locallyInside(b3, a8)) {
      triangles.push(a8.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b3.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b3;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a8 = start;
  do {
    var b3 = a8.next.next;
    while (b3 !== a8.prev) {
      if (a8.i !== b3.i && isValidDiagonal(a8, b3)) {
        var c3 = splitPolygon(a8, b3);
        a8 = filterPoints(a8, a8.next);
        c3 = filterPoints(c3, c3.next);
        earcutLinked(a8, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c3, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b3 = b3.next;
    }
    a8 = a8.next;
  } while (a8 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue2 = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue2.push(getLeftmost(list));
  }
  queue2.sort(compareX);
  for (i2 = 0; i2 < queue2.length; i2++) {
    outerNode = eliminateHole(queue2[i2], outerNode);
  }
  return outerNode;
}
function compareX(a8, b3) {
  return a8.x - b3.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx)
          return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === 0)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i2, p2, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e3 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e3 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e3;
        else
          list = e3;
        e3.prevZ = tail;
        tail = e3;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a8, b3) {
  return a8.next.i !== b3.i && a8.prev.i !== b3.i && !intersectsPolygon(a8, b3) && // dones't intersect other edges
  (locallyInside(a8, b3) && locallyInside(b3, a8) && middleInside(a8, b3) && // locally visible
  (area(a8.prev, a8, b3.prev) || area(a8, b3.prev, b3)) || // does not create opposite-facing sectors
  equals2(a8, b3) && area(a8.prev, a8, a8.next) > 0 && area(b3.prev, b3, b3.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals2(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a8, b3) {
  var p2 = a8;
  do {
    if (p2.i !== a8.i && p2.next.i !== a8.i && p2.i !== b3.i && p2.next.i !== b3.i && intersects(p2, p2.next, a8, b3))
      return true;
    p2 = p2.next;
  } while (p2 !== a8);
  return false;
}
function locallyInside(a8, b3) {
  return area(a8.prev, a8, a8.next) < 0 ? area(a8, b3, a8.next) >= 0 && area(a8, a8.prev, b3) >= 0 : area(a8, b3, a8.prev) < 0 || area(a8, a8.next, b3) < 0;
}
function middleInside(a8, b3) {
  var p2 = a8, inside = false, px = (a8.x + b3.x) / 2, py = (a8.y + b3.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a8);
  return inside;
}
function splitPolygon(a8, b3) {
  var a23 = new Node(a8.i, a8.x, a8.y), b22 = new Node(b3.i, b3.x, b3.y), an = a8.next, bp = b3.prev;
  a8.next = b3;
  b3.prev = a8;
  a23.next = an;
  an.prev = a23;
  b22.next = a23;
  a23.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last2) {
  var p2 = new Node(i2, x2, y2);
  if (!last2) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last2.next;
    p2.prev = last2;
    last2.next.prev = p2;
    last2.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start = holeIndices[i2] * dim;
      var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a8 = triangles[i2] * dim;
    var b3 = triangles[i2 + 1] * dim;
    var c3 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs(
      (data[a8] - data[c3]) * (data[b3 + 1] - data[a8 + 1]) - (data[a8] - data[b3]) * (data[c3 + 1] - data[a8 + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data.length; i2++) {
    for (var j2 = 0; j2 < data[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
/*! https://mths.be/punycode v1.4.1 by @mathias */
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\x20-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$5(array2, fn) {
  var length = array2.length;
  var result = [];
  while (length--) {
    result[length] = fn(array2[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map$5(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k4 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k4 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k4 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(input) {
  var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k4, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n2 = initialN;
  delta = 0;
  bias = initialBias;
  for (j2 = 0; j2 < inputLength; ++j2) {
    currentValue = input[j2];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue < n2 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        for (q2 = delta, k4 = base; ; k4 += base) {
          t2 = k4 <= bias ? tMin : k4 >= bias + tMax ? tMax : k4 - bias;
          if (q2 < t2) {
            break;
          }
          qMinusT = q2 - t2;
          baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
function hasOwnProperty$3(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray$2 = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
};
function stringifyPrimitive(v2) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "true" : "false";
    case "number":
      return isFinite(v2) ? v2 : "";
    default:
      return "";
  }
}
function stringify(obj, sep2, eq2, name2) {
  sep2 = sep2 || "&";
  eq2 = eq2 || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map$4(objectKeys(obj), function(k4) {
      var ks = encodeURIComponent(stringifyPrimitive(k4)) + eq2;
      if (isArray$2(obj[k4])) {
        return map$4(obj[k4], function(v2) {
          return ks + encodeURIComponent(stringifyPrimitive(v2));
        }).join(sep2);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k4]));
      }
    }).join(sep2);
  }
  if (!name2)
    return "";
  return encodeURIComponent(stringifyPrimitive(name2)) + eq2 + encodeURIComponent(stringifyPrimitive(obj));
}
function map$4(xs, f3) {
  if (xs.map)
    return xs.map(f3);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    res.push(f3(xs[i2], i2));
  }
  return res;
}
var objectKeys = Object.keys || function(obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
      res.push(key);
  }
  return res;
};
function parse$1(qs, sep2, eq2, options2) {
  sep2 = sep2 || "&";
  eq2 = eq2 || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep2);
  var maxKeys = 1e3;
  if (options2 && typeof options2.maxKeys === "number") {
    maxKeys = options2.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i2 = 0; i2 < len; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq2), kstr, vstr, k4, v2;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k4 = decodeURIComponent(kstr);
    v2 = decodeURIComponent(vstr);
    if (!hasOwnProperty$3(obj, k4)) {
      obj[k4] = v2;
    } else if (isArray$2(obj[k4])) {
      obj[k4].push(v2);
    } else {
      obj[k4] = [obj[k4], v2];
    }
  }
  return obj;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && isObject$3(url2) && url2 instanceof Url)
    return url2;
  var u2 = new Url();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  return parse(this, url2, parseQueryString, slashesDenoteHost);
};
function parse(self2, url2, parseQueryString, slashesDenoteHost) {
  if (!isString$a(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse$1(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i2, hec, l2, p2;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i2 = 0; i2 < hostEndingChars.length; i2++) {
      hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i2 = 0; i2 < nonHostChars.length; i2++) {
      hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k4 = part.length; j2 < k4; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p2 = self2.port ? ":" + self2.port : "";
    var h2 = self2.hostname || "";
    self2.host = h2 + p2;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse$1(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p2 = self2.pathname || "";
    var s2 = self2.search || "";
    self2.path = p2 + s2;
  }
  self2.href = format(self2);
  return self2;
}
function urlFormat(obj) {
  if (isString$a(obj))
    obj = parse({}, obj);
  return format(obj);
}
function format(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject$3(self2.query) && Object.keys(self2.query).length) {
    query = stringify(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
Url.prototype.format = function() {
  return format(this);
};
function urlResolve(source, relative2) {
  return urlParse(source, false, true).resolve(relative2);
}
Url.prototype.resolve = function(relative2) {
  return this.resolveObject(urlParse(relative2, false, true)).format();
};
Url.prototype.resolveObject = function(relative2) {
  if (isString$a(relative2)) {
    var rel = new Url();
    rel.parse(relative2, false, true);
    relative2 = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative2.hash;
  if (relative2.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative2.slashes && !relative2.protocol) {
    var rkeys = Object.keys(relative2);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative2[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative2.protocol && relative2.protocol !== result.protocol) {
    if (!slashedProtocol[relative2.protocol]) {
      var keys2 = Object.keys(relative2);
      for (var v2 = 0; v2 < keys2.length; v2++) {
        var k4 = keys2[v2];
        result[k4] = relative2[k4];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative2.protocol;
    if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
      relPath = (relative2.pathname || "").split("/");
      while (relPath.length && !(relative2.host = relPath.shift()))
        ;
      if (!relative2.host)
        relative2.host = "";
      if (!relative2.hostname)
        relative2.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative2.pathname;
    }
    result.search = relative2.search;
    result.query = relative2.query;
    result.host = relative2.host || "";
    result.auth = relative2.auth;
    result.hostname = relative2.hostname || relative2.host;
    result.port = relative2.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative2.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative2.pathname && relative2.pathname.split("/") || [];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative2.protocol) {
      relative2.hostname = null;
      relative2.port = null;
      if (relative2.host) {
        if (relPath[0] === "")
          relPath[0] = relative2.host;
        else
          relPath.unshift(relative2.host);
      }
      relative2.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  var authInHost;
  if (isRelAbs) {
    result.host = relative2.host || relative2.host === "" ? relative2.host : result.host;
    result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname;
    result.search = relative2.search;
    result.query = relative2.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative2.search;
    result.query = relative2.query;
  } else if (!isNullOrUndefined(relative2.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative2.search;
    result.query = relative2.query;
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last2 = srcPath[i2];
    if (last2 === ".") {
      srcPath.splice(i2, 1);
    } else if (last2 === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
    authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute2) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative2.auth || result.auth;
  result.slashes = result.slashes || relative2.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  return parseHost(this);
};
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
const url = {
  parse: urlParse,
  format: urlFormat,
  resolve: urlResolve
};
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url2) {
  const re = url2.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str2, find, replace) {
  return str2.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1)
        ;
      else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile2 = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile2 || isHttp || isWindows) {
      const arr = (isFile2 == null ? void 0 : isFile2[0]) || (isHttp == null ? void 0 : isHttp[0]) || (isWindows == null ? void 0 : isWindows[0]);
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url2, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url2))
      return url2;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url2);
    url2 = this.toPosix(url2);
    if (url2.startsWith("/")) {
      return path.join(rootUrl, url2.slice(1));
    }
    const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute2 = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute2)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i2 = 0; i2 < segments.length; ++i2) {
      const arg = segments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i2 - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i2 = path2.length - 1; i2 >= 1; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root2 = "";
    if (path2.startsWith("/"))
      root2 = "/";
    else {
      root2 = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index2 = path2.indexOf("/", root2.length);
      if (index2 !== -1) {
        root2 = path2.slice(0, index2);
      } else
        root2 = path2;
      if (!root2.endsWith("/"))
        root2 += "/";
    }
    return root2;
  },
  basename(path2, ext2) {
    assertPath(path2);
    if (ext2)
      assertPath(ext2);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext2 !== void 0 && ext2.length > 0 && ext2.length <= path2.length) {
      if (ext2.length === path2.length && ext2 === path2)
        return "";
      let extIdx = ext2.length - 1;
      let firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code === ext2.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i2 = path2.length - 1; i2 >= 0; --i2) {
      if (path2.charCodeAt(i2) === 47) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i2 = path2.length - 1; i2 >= 0; --i2) {
      const code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute2 = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2);
    if (isAbsolute2 || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for (; i2 >= start; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute2)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute2) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    return ret;
  },
  sep: "/",
  delimiter: ":"
};
const warnings = {};
function deprecation(version2, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version2}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version2}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version2}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
function skipHello() {
  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}
let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var _a;
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!((_a = gl == null ? void 0 : gl.getContextAttributes()) == null ? void 0 : _a.stencil);
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e3) {
        return false;
      }
    }();
  }
  return supported;
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
}, n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e$1 = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a$1 = function(r2) {
  return { r: e$1(r2.r, 0, 255), g: e$1(r2.g, 0, 255), b: e$1(r2.b, 0, 255), a: e$1(r2.a) };
}, o$1 = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i$1 = /^#([0-9a-f]{3,8})$/i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h$1 = function(r2) {
  var t2 = r2.r, n2 = r2.g, e3 = r2.b, u2 = r2.a, a8 = Math.max(t2, n2, e3), o2 = a8 - Math.min(t2, n2, e3), i2 = o2 ? a8 === t2 ? (n2 - e3) / o2 : a8 === n2 ? 2 + (e3 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a8 ? o2 / a8 * 100 : 0, v: a8 / 255 * 100, a: u2 };
}, b$2 = function(r2) {
  var t2 = r2.h, n2 = r2.s, e3 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e3 /= 100;
  var a8 = Math.floor(t2), o2 = e3 * (1 - n2), i2 = e3 * (1 - (t2 - a8) * n2), s2 = e3 * (1 - (1 - t2 + a8) * n2), h2 = a8 % 6;
  return { r: 255 * [e3, i2, o2, o2, s2, e3][h2], g: 255 * [s2, e3, e3, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e3, e3, i2][h2], a: u2 };
}, g$1 = function(r2) {
  return { h: u(r2.h), s: e$1(r2.s, 0, 100), l: e$1(r2.l, 0, 100), a: e$1(r2.a) };
}, d$1 = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f$2 = function(r2) {
  return b$2((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e3 = t2.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n2 / (e3 + n2) * 100 : 0, v: e3 + n2, a: t2.a }));
  var t2, n2, e3;
}, c$1 = function(r2) {
  return { h: (t2 = h$1(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e3 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e3 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e3, u2;
}, l$1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p$1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m$2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = { string: [[function(r2) {
  var t2 = i$1.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m$2.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a$1({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l$1.exec(t2) || p$1.exec(t2);
  if (!n2)
    return null;
  var e3, u2, a8 = g$1({ h: (e3 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e3) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f$2(a8);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e3 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e3) && t(u2) ? a$1({ r: Number(n2), g: Number(e3), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e3 = r2.s, u2 = r2.l, a8 = r2.a, o2 = void 0 === a8 ? 1 : a8;
  if (!t(n2) || !t(e3) || !t(u2))
    return null;
  var i2 = g$1({ h: Number(n2), s: Number(e3), l: Number(u2), a: Number(o2) });
  return f$2(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a8 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a8) || !t(o2))
    return null;
  var h2 = function(r3) {
    return { h: u(r3.h), s: e$1(r3.s, 0, 100), v: e$1(r3.v, 0, 100), a: e$1(r3.a) };
  }({ h: Number(n2), s: Number(a8), v: Number(o2), a: Number(s2) });
  return b$2(h2);
}, "hsv"]] }, N$1 = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e3 = t2[n2][0](r2);
    if (e3)
      return [e3, t2[n2][1]];
  }
  return [null, void 0];
}, x = function(r2) {
  return "string" == typeof r2 ? N$1(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N$1(r2, y.object) : [null, void 0];
}, M$1 = function(r2, t2) {
  var n2 = c$1(r2);
  return { h: n2.h, s: e$1(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H$1 = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $$1 = function(r2, t2) {
  var n2 = c$1(r2);
  return { h: n2.h, s: n2.s, l: e$1(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j$2 = function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H$1(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H$1(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H$1(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o$1(this.rgba), t2 = r3.r, e3 = r3.g, u2 = r3.b, i2 = (a8 = r3.a) < 1 ? s(n(255 * a8)) : "", "#" + s(t2) + s(e3) + s(u2) + i2;
    var r3, t2, e3, u2, a8, i2;
  }, r2.prototype.toRgb = function() {
    return o$1(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o$1(this.rgba), t2 = r3.r, n2 = r3.g, e3 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e3 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e3 + ")";
    var r3, t2, n2, e3, u2;
  }, r2.prototype.toHsl = function() {
    return d$1(c$1(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d$1(c$1(this.rgba)), t2 = r3.h, n2 = r3.s, e3 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e3 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e3 + "%)";
    var r3, t2, n2, e3, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h$1(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w$1({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M$1(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1(M$1(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w$1(M$1(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($$1(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w$1($$1(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w$1({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c$1(this.rgba);
    return "number" == typeof r3 ? w$1({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w$1(r3).toHex();
  }, r2;
}(), w$1 = function(r2) {
  return r2 instanceof j$2 ? r2 : new j$2(r2);
}, S$1 = [], k$3 = function(r2) {
  r2.forEach(function(r3) {
    S$1.indexOf(r3) < 0 && (r3(j$2, y), S$1.push(r3));
  });
};
function namesPlugin(e3, f3) {
  var a8 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a8)
    r2[a8[d2]] = d2;
  var l2 = {};
  e3.prototype.toName = function(f4) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (null == f4 ? void 0 : f4.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b3 = "black";
      if (!l2.length)
        for (var c3 in a8)
          l2[c3] = new e3(a8[c3]).toRgb();
      for (var g2 in a8) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b3 = g2);
      }
      return b3;
    }
  };
  f3.string.push([function(f4) {
    var r3 = f4.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a8[r3];
    return d3 ? new e3(d3).toRgb() : null;
  }, "name"]);
}
k$3([namesPlugin]);
const _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v2, i2) => v2 === value2[i2]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r2, g2, b3, a8] = this._components;
    return { r: r2, g: g2, b: b3, a: a8 };
  }
  toRgb() {
    const [r2, g2, b3] = this._components;
    return { r: r2, g: g2, b: b3 };
  }
  toRgbaString() {
    const [r2, g2, b3] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b3},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r2, g2, b3] = this._components;
    out = out ?? [];
    out[0] = Math.round(r2 * 255);
    out[1] = Math.round(g2 * 255);
    out[2] = Math.round(b3 * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r2, g2, b3] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b3;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r2, g2, b3, a8] = _Color.temp.setValue(value)._components;
    this._components[0] *= r2;
    this._components[1] *= g2;
    this._components[2] *= b3;
    this._components[3] *= a8;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r2 = this._int >> 16 & 255;
    let g2 = this._int >> 8 & 255;
    let b3 = this._int & 255;
    if (applyToRGB) {
      r2 = r2 * alpha + 0.5 | 0;
      g2 = g2 * alpha + 0.5 | 0;
      b3 = b3 * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b3;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r2, g2, b3] = this._components;
    this._components[0] = Math.round(r2 * steps) / steps;
    this._components[1] = Math.round(g2 * steps) / steps;
    this._components[2] = Math.round(b3 * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r2, g2, b3, a8] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b3;
    out[3] = a8;
    return out;
  }
  normalize(value) {
    let r2;
    let g2;
    let b3;
    let a8;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r2 = (int >> 16 & 255) / 255;
      g2 = (int >> 8 & 255) / 255;
      b3 = (int & 255) / 255;
      a8 = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r2, g2, b3, a8 = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r2, g2, b3, a8 = 255] = value;
      r2 /= 255;
      g2 /= 255;
      b3 /= 255;
      a8 /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = w$1(value);
      if (color.isValid()) {
        ({ r: r2, g: g2, b: b3, a: a8 } = color.rgba);
        r2 /= 255;
        g2 /= 255;
        b3 /= 255;
      }
    }
    if (r2 !== void 0) {
      this._components[0] = r2;
      this._components[1] = g2;
      this._components[2] = b3;
      this._components[3] = a8;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b3] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b3 * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v2, i2) => {
      value[i2] = Math.min(Math.max(v2, min), max);
    });
    return value;
  }
};
let Color = _Color;
Color.shared = new _Color();
Color.temp = new _Color();
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
function hex2rgb(hex, out = []) {
  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return Color.shared.setValue(rgb).toNumber();
}
function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i2 = 0; i2 < 32; i2++) {
    pm[i2] = i2;
    npm[i2] = i2;
  }
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  const array2 = [];
  array2.push(npm);
  array2.push(pm);
  return array2;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function createIndicesForQuads(size2, outBuffer = null) {
  const totalIndices = size2 * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
function getBufferType(array2) {
  if (array2.BYTES_PER_ELEMENT === 4) {
    if (array2 instanceof Float32Array) {
      return "Float32Array";
    } else if (array2 instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array2.BYTES_PER_ELEMENT === 2) {
    if (array2 instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array2.BYTES_PER_ELEMENT === 1) {
    if (array2 instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
const map$3 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays$1(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const size2 = sizes[i2];
    const array2 = arrays[i2];
    const type = getBufferType(array2);
    if (!views[type]) {
      views[type] = new map$3[type](buffer2);
    }
    out = views[type];
    for (let j2 = 0; j2 < array2.length; j2++) {
      const indexStart = (j2 / size2 | 0) * stride + littleOffset;
      const index2 = j2 % size2;
      out[indexStart + index2] = array2[j2];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer2);
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  let r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  let shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
function sign(n2) {
  if (n2 === 0)
    return 0;
  return n2 < 0 ? -1 : 1;
}
let nextUid = 0;
function uid$2() {
  return ++nextUid;
}
const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}
class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index2 = 4 * y2 * width; x2 < width; ++x2, index2 += 4) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index2 = top * stride + 4 * x2; y2 <= bottom; ++y2, index2 += stride) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context2 === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context2.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new BoundingBox(left, top, right, bottom);
}
function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context2 = canvas.getContext("2d");
    if (context2 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context2.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}
function decomposeDataUri(dataUri) {
  const dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}
let tempAnchor;
function determineCrossOrigin(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2 = 1) {
  var _a;
  const resolution = (_a = settings.RETINA_PREFIX) == null ? void 0 : _a.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2;
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTextureCache,
  BoundingBox,
  CanvasRenderTarget,
  DATA_URI,
  EventEmitter: EventEmitter2,
  ProgramCache,
  TextureCache,
  clearTextureCache,
  correctBlendMode,
  createIndicesForQuads,
  decomposeDataUri,
  deprecation,
  destroyTextureCache,
  determineCrossOrigin,
  earcut: earcut$1,
  getBufferType,
  getCanvasBoundingBox,
  getResolutionOfUrl,
  hex2rgb,
  hex2string,
  interleaveTypedArrays: interleaveTypedArrays$1,
  isMobile,
  isPow2,
  isWebGLSupported,
  log2,
  nextPow2,
  path,
  premultiplyBlendMode,
  premultiplyRgba,
  premultiplyTint,
  premultiplyTintToRgba,
  removeItems,
  rgb2hex,
  sayHello,
  sign,
  skipHello,
  string2hex,
  trimCanvas,
  uid: uid$2,
  url
}, Symbol.toStringTag, { value: "Module" }));
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext2) => {
  if (typeof ext2 === "function" || typeof ext2 === "object" && ext2.extension) {
    if (!ext2.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext2.extension !== "object" ? { type: ext2.extension } : ext2.extension;
    ext2 = { ...metadata, ref: ext2 };
  }
  if (typeof ext2 === "object") {
    ext2 = { ...ext2 };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext2.type === "string") {
    ext2.type = [ext2.type];
  }
  return ext2;
};
const normalizePriority = (ext2, defaultPriority) => normalizeExtension(ext2).priority ?? defaultPriority;
const extensions$1 = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext2) => {
      ext2.type.forEach((type) => {
        var _a, _b;
        return (_b = (_a = this._removeHandlers)[type]) == null ? void 0 : _b.call(_a, ext2);
      });
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext2) => {
      ext2.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue2 = this._queue;
        if (!handlers[type]) {
          queue2[type] = queue2[type] || [];
          queue2[type].push(ext2);
        } else {
          handlers[type](ext2);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue2 = this._queue;
    if (queue2[type]) {
      queue2[type].forEach((ext2) => onAdd(ext2));
      delete queue2[type];
    }
    return this;
  },
  handleByMap(type, map2) {
    return this.handle(type, (extension) => {
      map2[extension.name] = extension.ref;
    }, (extension) => {
      delete map2[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a8, b3) => normalizePriority(b3, defaultPriority) - normalizePriority(a8, defaultPriority));
    }, (extension) => {
      const index2 = list.indexOf(extension.ref);
      if (index2 !== -1) {
        list.splice(index2, 1);
      }
    });
  }
};
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}
const fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
const BLEND$1 = 0;
const OFFSET$1 = 1;
const CULLING$1 = 2;
const DEPTH_TEST$1 = 3;
const WINDING$1 = 4;
const DEPTH_MASK$1 = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND$1);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND$1) !== value) {
      this.data ^= 1 << BLEND$1;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET$1);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET$1) !== value) {
      this.data ^= 1 << OFFSET$1;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING$1);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING$1) !== value) {
      this.data ^= 1 << CULLING$1;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST$1);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
      this.data ^= 1 << DEPTH_TEST$1;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK$1);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
      this.data ^= 1 << DEPTH_MASK$1;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING$1);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING$1) !== value) {
      this.data ^= 1 << WINDING$1;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}
const INSTALLED = [];
function autoDetectResource(source, options2) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
    const ResourcePlugin = INSTALLED[i2];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options2);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
class Runner {
  constructor(name2) {
    this.items = [];
    this._name = name2;
    this._aliasCount = 0;
  }
  emit(a0, a12, a23, a32, a42, a52, a62, a72) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name: name2, items } = this;
    this._aliasCount++;
    for (let i2 = 0, len = items.length; i2 < len; i2++) {
      items[i2][name2](a0, a12, a23, a32, a42, a52, a62, a72);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index2 = this.items.indexOf(item);
    if (index2 !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index2, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}
class BufferResource extends Resource {
  constructor(source, options2) {
    const { width, height } = options2 || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer2, baseTexture, glTexture) {
    const gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}
const defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
};
const _BaseTexture = class extends EventEmitter2 {
  constructor(resource = null, options2 = null) {
    super();
    options2 = Object.assign({}, _BaseTexture.defaultOptions, options2);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format: format2,
      type,
      target,
      resolution,
      resourceOptions
    } = options2;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format2;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = uid$2();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options2, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = (options2 == null ? void 0 : options2.pixiIdPrefix) || "pixiid";
        source._pixiId = `${prefix}_${uid$2()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options2);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer2, width, height, options2) {
    buffer2 = buffer2 || new Float32Array(width * height * 4);
    const resource = new BufferResource(buffer2, { width, height });
    const type = buffer2 instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options2));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index2 > -1) {
          baseTextureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture == null ? void 0 : baseTexture.textureCacheIds) {
      for (let i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: SCALE_MODES.LINEAR,
  wrapMode: WRAP_MODES.CLAMP,
  alphaMode: ALPHA_MODES.UNPACK,
  target: TARGETS.TEXTURE_2D,
  format: FORMATS.RGBA,
  type: TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;
class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}
let UID$4 = 0;
class Buffer {
  constructor(data, _static = true, index2 = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index2;
    this.static = _static;
    this.id = UID$4++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
}
class Attribute {
  constructor(buffer2, size2 = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer2;
    this.size = size2;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer2, size2, normalized, type, stride) {
    return new Attribute(buffer2, size2, normalized, type, stride);
  }
}
const map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const size2 = sizes[i2];
    const array2 = arrays[i2];
    const type = getBufferType(array2);
    if (!views[type]) {
      views[type] = new map$2[type](buffer2);
    }
    out = views[type];
    for (let j2 = 0; j2 < array2.length; j2++) {
      const indexStart = (j2 / size2 | 0) * stride + littleOffset;
      const index2 = j2 % size2;
      out[indexStart + index2] = array2[j2];
    }
    littleOffset += size2;
  }
  return new Float32Array(buffer2);
}
const byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
let UID$3 = 0;
const map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$3++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer2, size2 = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer2) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer2 instanceof Buffer)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Float32Array(buffer2);
      }
      buffer2 = new Buffer(buffer2);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i2 = 0; i2 < ids.length; i2++) {
        this.addAttribute(ids[i2], buffer2, size2, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer2);
    if (bufferIndex === -1) {
      this.buffers.push(buffer2);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size2, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer2) {
    if (!(buffer2 instanceof Buffer)) {
      if (buffer2 instanceof Array) {
        buffer2 = new Uint16Array(buffer2);
      }
      buffer2 = new Buffer(buffer2);
    }
    buffer2.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer2;
    if (!this.buffers.includes(buffer2)) {
      this.buffers.push(buffer2);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new Buffer();
    let i2;
    for (i2 in this.attributes) {
      const attribute = this.attributes[i2];
      const buffer2 = this.buffers[attribute.buffer];
      arrays.push(buffer2.data);
      sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i2 = 0; i2 < this.buffers.length; i2++) {
      if (this.buffers[i2] !== this.indexBuffer) {
        this.buffers[i2].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i2 in this.attributes) {
      const attribute = this.attributes[i2];
      const buffer2 = this.buffers[attribute.buffer];
      return buffer2.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i2 = 0; i2 < this.buffers.length; i2++) {
      geometry.buffers[i2] = new Buffer(this.buffers[i2].data.slice(0));
    }
    for (const i2 in this.attributes) {
      const attrib = this.attributes[i2];
      geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++) {
        sizes[j2] = sizes[j2] || 0;
        sizes[j2] += geometry.buffers[j2].data.length;
        offsets[j2] = 0;
      }
    }
    for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
      arrays[i2] = new map$1[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
      geometryOut.buffers[i2] = new Buffer(arrays[i2]);
    }
    for (let i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (let j2 = 0; j2 < geometry.buffers.length; j2++) {
        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
        offsets[j2] += geometry.buffers[j2].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
        if (geometry.buffers[i2] !== geometry.indexBuffer) {
          bufferIndexToCount = i2;
          break;
        }
      }
      for (const i2 in geometry.attributes) {
        const attribute = geometry.attributes[i2];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
        }
      }
      for (let i2 = 0; i2 < geometries.length; i2++) {
        const indexBufferData = geometries[i2].indexBuffer.data;
        for (let j2 = 0; j2 < indexBufferData.length; j2++) {
          geometryOut.indexBuffer.data[j2 + offset2] += offset;
        }
        offset += geometries[i2].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}
class BatchGeometry extends Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new Buffer(null, _static, false);
    this._indexBuffer = new Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});
class Point {
  constructor(x2 = 0, y2 = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p2) {
    this.set(p2.x, p2.y);
    return this;
  }
  copyTo(p2) {
    p2.set(this.x, this.y);
    return p2;
  }
  equals(p2) {
    return p2.x === this.x && p2.y === this.y;
  }
  set(x2 = 0, y2 = x2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}
const tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints$1[0].set(other.left, other.top);
    const lb = tempPoints$1[1].set(other.left, other.bottom);
    const rt = tempPoints$1[2].set(other.right, other.top);
    const rb = tempPoints$1[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s2 * (lb.y - lt.y);
    const ny = s2 * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s2 * (lt.y - rt.y);
    const my = s2 * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
class Circle {
  constructor(x2 = 0, y2 = 0, radius = 0) {
    this.x = x2;
    this.y = y2;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x2, y2) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x2;
    let dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class Ellipse {
  constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x2;
    this.y = y2;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x2 - this.x) / this.width;
    let normy = (y2 - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p2 = [];
      for (let i2 = 0, il = flat.length; i2 < il; i2++) {
        p2.push(flat[i2].x, flat[i2].y);
      }
      flat = p2;
    }
    this.points = flat;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x2, y2) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
      const xi = this.points[i2 * 2];
      const yi = this.points[i2 * 2 + 1];
      const xj = this.points[j2 * 2];
      const yj = this.points[j2 * 2 + 1];
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}
class RoundedRectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        let dx = x2 - (this.x + radius);
        let dy = y2 - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
class Matrix {
  constructor(a8 = 1, b3 = 0, c3 = 0, d2 = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a8;
    this.b = b3;
    this.c = c3;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array2) {
    this.a = array2[0];
    this.b = array2[1];
    this.c = array2[3];
    this.d = array2[4];
    this.tx = array2[2];
    this.ty = array2[5];
  }
  set(a8, b3, c3, d2, tx, ty) {
    this.a = a8;
    this.b = b3;
    this.c = c3;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array2 = out || this.array;
    if (transpose) {
      array2[0] = this.a;
      array2[1] = this.b;
      array2[2] = 0;
      array2[3] = this.c;
      array2[4] = this.d;
      array2[5] = 0;
      array2[6] = this.tx;
      array2[7] = this.ty;
      array2[8] = 1;
    } else {
      array2[0] = this.a;
      array2[1] = this.c;
      array2[2] = this.tx;
      array2[3] = this.b;
      array2[4] = this.d;
      array2[5] = this.ty;
      array2[6] = 0;
      array2[7] = 0;
      array2[8] = 1;
    }
    return array2;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  }
  scale(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  }
  rotate(angle2) {
    const cos = Math.cos(angle2);
    const sin = Math.sin(angle2);
    const a12 = this.a;
    const c12 = this.c;
    const tx1 = this.tx;
    this.a = a12 * cos - this.b * sin;
    this.b = a12 * sin + this.b * cos;
    this.c = c12 * cos - this.d * sin;
    this.d = c12 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a12 = this.a;
    const b12 = this.b;
    const c12 = this.c;
    const d12 = this.d;
    this.a = matrix.a * a12 + matrix.b * c12;
    this.b = matrix.a * b12 + matrix.b * d12;
    this.c = matrix.c * a12 + matrix.d * c12;
    this.d = matrix.c * b12 + matrix.d * d12;
    this.tx = matrix.tx * a12 + matrix.ty * c12 + this.tx;
    this.ty = matrix.tx * b12 + matrix.ty * d12 + this.ty;
    return this;
  }
  setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a12 = this.a;
      const c12 = this.c;
      this.a = a12 * matrix.a + this.b * matrix.c;
      this.b = a12 * matrix.b + this.b * matrix.d;
      this.c = c12 * matrix.a + this.d * matrix.c;
      this.d = c12 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a8 = this.a;
    const b3 = this.b;
    const c3 = this.c;
    const d2 = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c3, d2);
    const skewY = Math.atan2(b3, a8);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a8 * a8 + b3 * b3);
    transform.scale.y = Math.sqrt(c3 * c3 + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a8 + pivot.y * c3);
    transform.position.y = this.ty + (pivot.x * b3 + pivot.y * d2);
    return transform;
  }
  invert() {
    const a12 = this.a;
    const b12 = this.b;
    const c12 = this.c;
    const d12 = this.d;
    const tx1 = this.tx;
    const n2 = a12 * d12 - b12 * c12;
    this.a = d12 / n2;
    this.b = -b12 / n2;
    this.c = -c12 / n2;
    this.d = a12 / n2;
    this.tx = (c12 * this.ty - d12 * tx1) / n2;
    this.ty = -(a12 * this.ty - b12 * tx1) / n2;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k4 = 0; k4 < 16; k4++) {
        if (ux[k4] === _ux && uy[k4] === _uy && vx[k4] === _vx && vy[k4] === _vy) {
          row.push(k4);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
class ObservablePoint {
  constructor(cb, scope, x2 = 0, y2 = 0) {
    this._x = x2;
    this._y = y2;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x2 = 0, y2 = x2) {
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p2) {
    p2.set(this._x, this._y);
    return p2;
  }
  equals(p2) {
    return p2.x === this._x && p2.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}
const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function booleanArray(size2) {
  const array2 = new Array(size2);
  for (let i2 = 0; i2 < array2.length; i2++) {
    array2[i2] = false;
  }
  return array2;
}
function defaultValue(type, size2) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name2) => `
            if(uv["${name2}"] !== ud["${name2}"].value)
            {
                ud["${name2}"].value = uv["${name2}"]
                gl.uniform1f(ud["${name2}"].location, uv["${name2}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name2) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name2}"], t);

            if(ud["${name2}"].value !== t)
            {
                ud["${name2}"].value = t;
                gl.uniform1i(ud["${name2}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name2) => `
            gl.uniformMatrix3fv(ud["${name2}"].location, false, uv["${name2}"].toArray(true));
            `,
    codeUbo: (name2) => `
                var ${name2}_matrix = uv.${name2}.toArray(true);

                data[offset] = ${name2}_matrix[0];
                data[offset+1] = ${name2}_matrix[1];
                data[offset+2] = ${name2}_matrix[2];
        
                data[offset + 4] = ${name2}_matrix[3];
                data[offset + 5] = ${name2}_matrix[4];
                data[offset + 6] = ${name2}_matrix[5];
        
                data[offset + 8] = ${name2}_matrix[6];
                data[offset + 9] = ${name2}_matrix[7];
                data[offset + 10] = ${name2}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name2}"].location, v.x, v.y);
                }`,
    codeUbo: (name2) => `
                v = uv.${name2};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name2}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name2}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name2}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name2}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name2) => `
                    v = uv.${name2};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name2) => `
                cv = ud["${name2}"].value;
                v = uv["${name2}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name2}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];
const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a;
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i2 in group.uniforms) {
    const data = uniformData[i2];
    if (!data) {
      if ((_a = group.uniforms[i2]) == null ? void 0 : _a.group) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i2}, '${i2}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i2}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i2];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i2, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || (context == null ? void 0 : context.isContextLost())) {
    const canvas = settings.ADAPTER.createCanvas();
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
      precision = PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e3) {
    unsafeEval = false;
  }
  return unsafeEval;
}
let UID$2 = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name2 = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID$2++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name2 = name2.replace(/\s+/g, "-");
      if (nameCache[name2]) {
        nameCache[name2]++;
        name2 += `-${nameCache[name2]}`;
      } else {
        nameCache[name2] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name2}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name2}
${this.fragmentSrc}`;
      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, PRECISION.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return defaultVertex$3;
  }
  static get defaultFragmentSrc() {
    return defaultFragment$2;
  }
  static from(vertexSrc, fragmentSrc, name2) {
    const key = vertexSrc + fragmentSrc;
    let program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name2);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = PRECISION.HIGH;
Program.defaultFragmentPrecision = isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;
let UID$1 = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$1++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name2, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name2] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}
class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
    this.disposeRunner = new Runner("disposeShader");
  }
  checkUniformExists(name2, group) {
    if (group.uniforms[name2]) {
      return true;
    }
    for (const i2 in group.uniforms) {
      const uniform = group.uniforms[i2];
      if (uniform.group) {
        if (this.checkUniformExists(name2, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}
class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate2.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate2.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i2 = 0; i2 < maxTextures; i2++) {
        sampleValues[i2] = i2;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src += "\nelse ";
      }
      if (i2 < maxTextures - 1) {
        src += `if(vTextureId < ${i2}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i2}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}
class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i2 = 0; i2 < this.count; i2++) {
      this.elements[i2] = null;
    }
    this.count = 0;
  }
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator2 = settings.ADAPTER.getNavigator();
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
class ObjectRenderer {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}
var defaultFragment$1 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
const _BatchRenderer = class extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    this.setShaderGenerator();
    this.geometryClass = BatchGeometry;
    this.vertexSize = 6;
    this.state = State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer2.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return defaultVertex$2;
  }
  static get defaultFragmentTemplate() {
    return defaultFragment$1;
  }
  setShaderGenerator({
    vertex: vertex2 = _BatchRenderer.defaultVertexSrc,
    fragment: fragment2 = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      this._packedGeometries[i2] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (let i2 = 0; i2 < this.maxTextures; i2++) {
      this._tempBoundTextures[i2] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i2 = 0; i2 < this._bufferSize; ++i2) {
      const tex = textures[i2];
      textures[i2] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i2);
        start = i2;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i2 = 0; i2 < boundTextures.length; i2++) {
      boundTextures[i2] = null;
    }
    BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i2 = start; i2 < finish; ++i2) {
      const sprite2 = elements[i2];
      const tex = sprite2._texture.baseTexture;
      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite2.blendMode];
      elements[i2] = null;
      if (start < i2 && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i2;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite2, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite2.vertexData.length / 2 * vertexSize;
      iIndex += sprite2.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j2 = 0; j2 < texArray.count; j2++) {
      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
      texArray.elements[j2] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i2 = 0; i2 < dcCount; i2++) {
      const { texArray, type, size: size2, start, blend } = drawCalls[i2];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size2, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      if (this._packedGeometries[i2]) {
        this._packedGeometries[i2].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 8));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer2 = this._aBuffers[roundedSize];
    if (!buffer2) {
      this._aBuffers[roundedSize] = buffer2 = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer2;
  }
  getIndexBuffer(size2) {
    const roundedP2 = nextPow2(Math.ceil(size2 / 12));
    const roundedSizeIndex = log2(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer2 = this._iBuffers[roundedSizeIndex];
    if (!buffer2) {
      this._iBuffers[roundedSizeIndex] = buffer2 = new Uint16Array(roundedSize);
    }
    return buffer2;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i2 = 0; i2 < vertexData.length; i2 += 2) {
      float32View[aIndex++] = vertexData[i2];
      float32View[aIndex++] = vertexData[i2 + 1];
      float32View[aIndex++] = uvs[i2];
      float32View[aIndex++] = uvs[i2 + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i2 = 0; i2 < indicies.length; i2++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i2];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
extensions$1.add(BatchRenderer);
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
const _Filter = class extends Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return defaultVertex$1;
  }
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = MSAA_QUALITY.NONE;
class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color(0);
    this.alpha = 1;
  }
  init(options2) {
    this.clearBeforeRender = options2.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options2;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions$1.add(BackgroundSystem);
class BatchSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.emptyRenderer = new ObjectRenderer(renderer2);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i2 = maxTextures - 1; i2 >= 0; --i2) {
      arr[i2] = boundTextures[i2] || null;
      if (arr[i2]) {
        arr[i2]._batchLocation = i2;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j2 = 0;
    for (let i2 = 0; i2 < count; i2++) {
      const tex = elements[i2];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i2] = loc;
        continue;
      }
      while (j2 < maxTextures) {
        const bound = boundTextures[j2];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
          j2++;
          continue;
        }
        ids[i2] = j2;
        tex._batchLocation = j2;
        boundTextures[j2] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "batch"
};
extensions$1.add(BatchSystem);
let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options2) {
    if (options2.context) {
      this.initFromContext(options2.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options2.premultipliedAlpha;
      this.preserveDrawingBuffer = options2.preserveDrawingBuffer;
      this.useContextAlpha = options2.useContextAlpha;
      this.powerPreference = options2.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options2.antialias,
        stencil: true,
        preserveDrawingBuffer: options2.preserveDrawingBuffer,
        powerPreference: options2.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options2) {
    const gl = this.createContext(this.renderer.view, options2);
    this.initFromContext(gl);
  }
  createContext(canvas, options2) {
    let gl;
    if (settings.PREFER_ENV >= ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options2);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options2) || canvas.getContext("experimental-webgl", options2);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "context"
};
extensions$1.add(ContextSystem);
class DepthResource extends BufferResource {
  upload(renderer2, baseTexture, glTexture) {
    const gl = renderer2.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}
class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index2 = 0, texture) {
    this.colorTextures[index2] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i2 = 0; i2 < this.colorTextures.length; i2++) {
      const texture = this.colorTextures[i2];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}
class BaseRenderTexture extends BaseTexture {
  constructor(options2 = {}) {
    if (typeof options2 === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options2 = { width, height, scaleMode, resolution };
    }
    options2.width = options2.width || 100;
    options2.height = options2.height || 100;
    options2.multisample ?? (options2.multisample = MSAA_QUALITY.NONE);
    super(null, options2);
    this.mipmap = MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new Color([0, 0, 0, 0]);
    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options2.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}
class BaseImageResource extends Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url2, crossorigin) {
    if (crossorigin === void 0 && !url2.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer2, baseTexture, glTexture, source) {
    const gl = renderer2.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}
class ImageResource extends BaseImageResource {
  constructor(source, options2) {
    options2 = options2 || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options2.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options2.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options2.alphaMode === "number" ? options2.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options2.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve2, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve2(this.process());
        } else {
          resolve2(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap2 = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r2) => r2.blob()).then((blob) => createImageBitmap2(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer2, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer2, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer2, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}
class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate);
      this.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate);
      this.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate);
      this.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate);
      this.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}
const DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends EventEmitter2 {
  constructor(baseTexture, frame, orig, trim2, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim2;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if ((resource == null ? void 0 : resource.url) && TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    var _a;
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, (_a = this.trim) == null ? void 0 : _a.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options2 = {}, strict = settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        const prefix = (options2 == null ? void 0 : options2.pixiIdPrefix) || "pixiid";
        source.cacheId = `${prefix}-${uid$2()}`;
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = (options2 == null ? void 0 : options2.pixiIdPrefix) || "pixiid";
        source._pixiId = `${prefix}_${uid$2()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options2.resolution) {
        options2.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture(new BaseTexture(source, options2));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url2, options2) {
    const resourceOptions = Object.assign({ autoLoad: false }, options2 == null ? void 0 : options2.resourceOptions);
    const texture = Texture.from(url2, Object.assign({ resourceOptions }, options2), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer2, width, height, options2) {
    return new Texture(BaseTexture.fromBuffer(buffer2, width, height, options2));
  }
  static fromLoader(source, imageUrl, name2, options2) {
    const baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl(imageUrl)
    }, options2));
    const { resource } = baseTexture;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name2) {
      name2 = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name2);
    Texture.addToCache(texture, name2);
    if (name2 !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve2) => {
      texture.baseTexture.once("loaded", () => resolve2(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id] && TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        const index2 = textureFromCache.textureCacheIds.indexOf(texture);
        if (index2 > -1) {
          textureFromCache.textureCacheIds.splice(index2, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture == null ? void 0 : texture.textureCacheIds) {
      for (let i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
        if (TextureCache[texture.textureCacheIds[i2]] === texture) {
          delete TextureCache[texture.textureCacheIds[i2]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x: x2, y: y2, width, height } = frame;
    const xNotFit = x2 + width > this.baseTexture.width;
    const yNotFit = y2 + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x2} + ${width} = ${x2 + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y2} + ${height} = ${y2 + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.ADAPTER.createCanvas(16, 16);
      const context2 = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}
class RenderTexture extends Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options2) {
    return new RenderTexture(new BaseRenderTexture(options2));
  }
}
class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i2 in this.texturePool) {
        const textures = this.texturePool[i2];
        if (textures) {
          for (let j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size2) {
    if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size2.width > 0 && size2.height > 0;
    for (const i2 in this.texturePool) {
      if (!(Number(i2) < 0)) {
        continue;
      }
      const textures = this.texturePool[i2];
      if (textures) {
        for (let j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[i2] = [];
    }
    this._pixelsWidth = size2.width;
    this._pixelsHeight = size2.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;
class Quad extends Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}
class QuadUv extends Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new Buffer(this.vertices);
    this.uvBuffer = new Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x2 = 0;
    let y2 = 0;
    this.uvs[0] = x2;
    this.uvs[1] = y2;
    this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y2;
    this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x2;
    this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
    x2 = destinationFrame.x;
    y2 = destinationFrame.y;
    this.vertices[0] = x2;
    this.vertices[1] = y2;
    this.vertices[2] = x2 + destinationFrame.width;
    this.vertices[3] = y2;
    this.vertices[4] = x2 + destinationFrame.width;
    this.vertices[5] = y2 + destinationFrame.height;
    this.vertices[6] = x2;
    this.vertices[7] = y2 + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}
class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}
const tempPoints = [new Point(), new Point(), new Point(), new Point()];
const tempMatrix$2 = new Matrix();
class FilterSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters2) {
    const renderer2 = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters2[0].resolution;
    let multisample = filters2[0].multisample;
    let padding = filters2[0].padding;
    let autoFit = filters2[0].autoFit;
    let legacy = filters2[0].legacy ?? true;
    for (let i2 = 1; i2 < filters2.length; i2++) {
      const filter3 = filters2[i2];
      resolution = Math.min(resolution, filter3.resolution);
      multisample = Math.min(multisample, filter3.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter3.padding) : padding + filter3.padding;
      autoFit = autoFit && filter3.autoFit;
      legacy = legacy || (filter3.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer2.projection.transform) {
      this.transformAABB(tempMatrix$2.copyFrom(renderer2.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters2;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer2.projection.transform;
    renderer2.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer2.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters2 = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters2.length === 1) {
      filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i2 = 0;
      for (i2 = 0; i2 < filters2.length - 1; ++i2) {
        if (i2 === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters2[i2].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        const t2 = flip;
        flip = flop;
        flop = t2;
      }
      filters2[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
      if (i2 > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture == null ? void 0 : filterTexture.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter3, input, output, clearMode) {
    const renderer2 = this.renderer;
    renderer2.state.set(filter3.state);
    this.bindAndClear(output, clearMode);
    filter3.uniforms.uSampler = input;
    filter3.uniforms.filterGlobals = this.globalUniforms;
    renderer2.shader.bind(filter3);
    filter3.legacy = !!filter3.program.attributeData.aTextureCoord;
    if (filter3.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer2.geometry.bind(this.quadUv);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLES);
    } else {
      renderer2.geometry.bind(this.quad);
      renderer2.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite2) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite2._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite2.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite2.anchor.x, sprite2.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap2 = input;
      input = resolution;
      resolution = swap2;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints[0];
    const lb = tempPoints[1];
    const rt = tempPoints[2];
    const rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a: a8, b: b3, c: c3, d: d2 } = transform;
      if ((Math.abs(b3) > 1e-4 || Math.abs(c3) > 1e-4) && (Math.abs(a8) > 1e-4 || Math.abs(d2) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "filter"
};
extensions$1.add(FilterSystem);
class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}
const tempRectangle = new Rectangle();
class FramebufferSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
        const tex = framebuffer.colorTextures[i2];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x2, y2, width, height) {
    const v2 = this.viewport;
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    width = Math.round(width);
    height = Math.round(height);
    if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
      v2.x = x2;
      v2.y = y2;
      v2.width = width;
      v2.height = height;
      this.gl.viewport(x2, y2, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r2, g2, b3, a8, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r2, g2, b3, a8);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i2 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i2 = 0; i2 < count; i2++) {
      const texture = colorTextures[i2];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i2 === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i2 = 0; i2 < msaaSamples.length; i2++) {
      if (msaaSamples[i2] <= samples) {
        res = msaaSamples[i2];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer: renderer2, gl, CONTEXT_UID } = this;
    if (renderer2.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index2 = this.managedFramebuffers.indexOf(framebuffer);
    if (index2 >= 0) {
      this.managedFramebuffers.splice(index2, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i2 = 0; i2 < list.length; i2++) {
      this.disposeFramebuffer(list[i2], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w2 = framebuffer.width;
    const h2 = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions$1.add(FramebufferSystem);
const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context2.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a8, b3) => instanceExt.vertexAttribDivisorANGLE(a8, b3);
        gl.drawElementsInstanced = (a8, b3, c3, d2, e3) => instanceExt.drawElementsInstancedANGLE(a8, b3, c3, d2, e3);
        gl.drawArraysInstanced = (a8, b3, c3, d2) => instanceExt.drawArraysInstancedANGLE(a8, b3, c3, d2);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
      const buffer2 = geometry.buffers[i2];
      bufferSystem.update(buffer2);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j2 in shaderAttributes) {
      if (!geometryAttributes[j2]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i2 in attribs) {
      if (shaderAttributes[i2]) {
        strings.push(i2, shaderAttributes[i2].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      tempStride[j2] = 0;
      tempStart[j2] = 0;
    }
    for (const j2 in attributes) {
      if (!attributes[j2].size && program.attributeData[j2]) {
        attributes[j2].size = program.attributeData[j2].size;
      } else if (!attributes[j2].size) {
        console.warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer2 = buffers[i2];
      bufferSystem.bind(buffer2);
      if (incRefCount) {
        buffer2._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    var _a;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = (_a = this.renderer) == null ? void 0 : _a.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i2 = 0; i2 < buffers.length; i2++) {
        const buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i2], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all2 = Object.keys(this.managedGeometries);
    for (let i2 = 0; i2 < all2.length; i2++) {
      this.disposeGeometry(this.managedGeometries[all2[i2]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      const buffer2 = buffers[attribute.buffer];
      const glBuffer = buffer2._glBuffers[CONTEXT_UID];
      if (program.attributeData[j2]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer2);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j2].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size2, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size2 || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size2 || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "geometry"
};
extensions$1.add(GeometrySystem);
const tempMat$1 = new Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i2 = 0; i2 < uvs.length; i2 += 2) {
      const x2 = uvs[i2];
      const y2 = uvs[i2 + 1];
      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
      out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim2 = tex.trim;
    if (trim2) {
      tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);
      this.mapCoord.append(tempMat$1);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
class SpriteMaskFilter extends Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite2 = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite2 = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms);
    this.maskSprite = sprite2;
    this.maskMatrix = new Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}
class MaskData {
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}
class MaskSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d2 = this.maskDataPool.pop() || new MaskData();
      d2.pooled = true;
      d2.maskObject = maskDataOrTarget;
      maskData = d2;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES.SCISSOR;
    } else {
      maskData.type = MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    const renderer2 = this.renderer;
    const renderTextureSystem = renderer2.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer2.resolution;
      multisample = maskData.multisample ?? renderer2.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer2.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "mask"
};
extensions$1.add(MaskSystem);
class AbstractMaskSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}
const tempMatrix$1 = new Matrix();
const rectPool = [];
const _ScissorSystem = class extends AbstractMaskSystem {
  constructor(renderer2) {
    super(renderer2);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer: renderer2 } = this;
    const renderTextureSystem = renderer2.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer2.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer2.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a: a8, b: b3, c: c3, d: d2 } = matrix;
    return (Math.abs(b3) > 1e-4 || Math.abs(c3) > 1e-4) && (Math.abs(a8) > 1e-4 || Math.abs(d2) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y2;
    if (this.renderer.renderTexture.current) {
      y2 = rect.y;
    } else {
      y2 = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "scissor"
};
extensions$1.add(ScissorSystem);
class StencilSystem extends AbstractMaskSystem {
  constructor(renderer2) {
    super(renderer2);
    this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "stencil"
};
extensions$1.add(StencilSystem);
class PluginSystem2 {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer2.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer2.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer2.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o2 in staticMap) {
      this.plugins[o2] = new staticMap[o2](this.renderer);
    }
  }
  destroy() {
    for (const o2 in this.plugins) {
      this.plugins[o2].destroy();
      this.plugins[o2] = null;
    }
  }
}
PluginSystem2.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions$1.add(PluginSystem2);
class ProjectionSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root2) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer2 = this.renderer;
    renderer2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer2.globalUniforms.update();
    if (renderer2.shader.shader) {
      renderer2.shader.syncUniformGroup(renderer2.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root2) {
    const pm = this.projectionMatrix;
    const sign2 = !root2 ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "projection"
};
extensions$1.add(ProjectionSystem);
const tempTransform = new Transform();
class GenerateTextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this._tempMatrix = new Matrix();
  }
  generateTexture(displayObject, options2) {
    const { region: manualRegion, ...textureOptions } = options2 || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions$1.add(GenerateTextureSystem);
const tempRect = new Rectangle();
const tempRect2 = new Rectangle();
class RenderTextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  contextChange() {
    var _a;
    const attributes = (_a = this.renderer) == null ? void 0 : _a.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer2 = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer2.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer2._view.screen.width;
        tempRect.height = renderer2._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer2.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color = Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color.premultiply(color.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x: x2, y: y2, width, height } = this.viewportFrame;
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x2, y2, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions$1.add(RenderTextureSystem);
class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}
function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name2 = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name2] = {
      name: name2,
      index: i2,
      type,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var _a;
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = (_a = program.extra) == null ? void 0 : _a.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys2 = Object.keys(program.attributeData);
    keys2.sort((a8, b3) => a8 > b3 ? 1 : -1);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      program.attributeData[keys2[i2]].location = i2;
      gl.bindAttribLocation(webGLProgram, i2, keys2[i2]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program.uniformData) {
    const data = program.uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer2) {
  _renderer.buffer.update(buffer2);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size2 = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size2 = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size2 = Math.max(size2, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size2;
    if (chunkSize % size2 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size2 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size2;
      chunkSize = size2;
    } else {
      uboElement.offset = offset;
      chunkSize += size2;
      offset += size2;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i2 in uniforms) {
    if (uniformData[i2]) {
      usedUniformDatas.push(uniformData[i2]);
    }
  }
  usedUniformDatas.sort((a8, b3) => a8.index - b3.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size: size2 } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const uniform = group.uniforms[uboElement.data.name];
    const name2 = uboElement.data.name;
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size22 = mapSize(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size22 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name2}.value;
                v = uv.${name2};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name2}.value;
                v = uv.${name2};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size: size2,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer2) {
    this.destroyed = false;
    this.renderer = renderer2;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name2) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name2);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name2]);
  }
  createSyncBufferGroup(group, glProgram, name2) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name2);
    glProgram.uniformBufferBindings[name2] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i2 in uniforms) {
      strings.push(i2);
      if (uniformData[i2]) {
        strings.push(uniformData[i2].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "shader"
};
extensions$1.add(ShaderSystem);
class StartupSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  run(options2) {
    const { renderer: renderer2 } = this;
    renderer2.runners.init.emit(renderer2.options);
    if (options2.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer2.rendererLogId} - https://pixijs.com`);
    }
    renderer2.resize(renderer2.screen.width, renderer2.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions$1.add(StartupSystem);
function mapWebGLBlendModesToPixi(gl, array2 = []) {
  array2[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array2[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.NONE] = [0, 0];
  array2[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array2[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array2[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array2[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array2[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array2[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array2[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array2;
}
const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i2 = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        diff = diff >> 1;
        i2++;
      }
      this.stateId = state.data;
    }
    for (let i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i2 = 0; i2 < this.map.length; i2++) {
      this.map[i2].call(this, !!(state.data & 1 << i2));
    }
    for (let i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index2 = this.checks.indexOf(func);
    if (value && index2 === -1) {
      this.checks.push(func);
    } else if (!value && index2 !== -1) {
      this.checks.splice(index2, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "state"
};
extensions$1.add(StateSystem);
class SystemManager extends EventEmitter2 {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config2) {
    this.addRunners(...config2.runners);
    const priority = (config2.priority ?? []).filter((key) => config2.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config2.systems).filter((key) => !priority.includes(key))
    ];
    for (const i2 of orderByPriority) {
      this.addSystem(config2.systems[i2], i2);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner(runnerId);
    });
  }
  addSystem(ClassRef, name2) {
    const system = new ClassRef(this);
    if (this[name2]) {
      throw new Error(`Whoops! The name "${name2}" is already in use`);
    }
    this[name2] = system;
    this._systemsHash[name2] = system;
    for (const i2 in this.runners) {
      this.runners[i2].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options2) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options2[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}
const _TextureGCSystem = class {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i2 = 0; i2 < managedTextures.length; i2++) {
      const texture = managedTextures[i2];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i2] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j2 = 0;
      for (let i2 = 0; i2 < managedTextures.length; i2++) {
        if (managedTextures[i2] !== null) {
          managedTextures[j2++] = managedTextures[i2];
        }
      }
      managedTextures.length = j2;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
      this.unload(displayObject.children[i2]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "textureGC"
};
extensions$1.add(TextureGCSystem);
class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES.UNSIGNED_BYTE;
    this.internalFormat = FORMATS.RGBA;
    this.samplerType = 0;
  }
}
function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8,
        [FORMATS.RGB]: gl.RGB8,
        [FORMATS.RG]: gl.RG8,
        [FORMATS.RED]: gl.R8,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [FORMATS.RG_INTEGER]: gl.RG8UI,
        [FORMATS.RED_INTEGER]: gl.R8UI,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8_SNORM,
        [FORMATS.RGB]: gl.RGB8_SNORM,
        [FORMATS.RG]: gl.RG8_SNORM,
        [FORMATS.RED]: gl.R8_SNORM,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [FORMATS.RGB_INTEGER]: gl.RGB8I,
        [FORMATS.RG_INTEGER]: gl.RG8I,
        [FORMATS.RED_INTEGER]: gl.R8I
      },
      [TYPES.UNSIGNED_SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [FORMATS.RG_INTEGER]: gl.RG16UI,
        [FORMATS.RED_INTEGER]: gl.R16UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [TYPES.SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [FORMATS.RGB_INTEGER]: gl.RGB16I,
        [FORMATS.RG_INTEGER]: gl.RG16I,
        [FORMATS.RED_INTEGER]: gl.R16I
      },
      [TYPES.UNSIGNED_INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [FORMATS.RG_INTEGER]: gl.RG32UI,
        [FORMATS.RED_INTEGER]: gl.R32UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [TYPES.INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [FORMATS.RGB_INTEGER]: gl.RGB32I,
        [FORMATS.RG_INTEGER]: gl.RG32I,
        [FORMATS.RED_INTEGER]: gl.R32I
      },
      [TYPES.FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA32F,
        [FORMATS.RGB]: gl.RGB32F,
        [FORMATS.RG]: gl.RG32F,
        [FORMATS.RED]: gl.R32F,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [TYPES.HALF_FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA16F,
        [FORMATS.RGB]: gl.RGB16F,
        [FORMATS.RG]: gl.RG16F,
        [FORMATS.RED]: gl.R16F
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB565
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA4
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGB5_A1
      },
      [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [FORMATS.RGBA]: gl.RGB10_A2,
        [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [FORMATS.RGB]: gl.RGB9_E5
      },
      [TYPES.UNSIGNED_INT_24_8]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA,
        [FORMATS.RGB]: gl.RGB,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}
class TextureSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      this.boundTextures[i2] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i2 = 0; i2 < 6; i2++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.bind(null, i2);
    }
  }
  bind(texture, location = 0) {
    const { gl } = this;
    texture = texture == null ? void 0 : texture.castToBaseTexture();
    if ((texture == null ? void 0 : texture.valid) && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.boundTextures[i2] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i2 = 0; i2 < boundTextures.length; i2++) {
        if (boundTextures[i2] === this.unknownTexture) {
          this.bind(null, i2);
        }
      }
    }
    for (let i2 = 0; i2 < boundTextures.length; i2++) {
      if (boundTextures[i2] === texture) {
        if (this.currentLocation !== i2) {
          gl.activeTexture(gl.TEXTURE0 + i2);
          this.currentLocation = i2;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i2] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i2 = maxTextures - 1; i2 >= 0; --i2) {
      const tex = boundTextures[i2];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    var _a;
    glTexture.internalFormat = ((_a = this.internalFormats[texture.type]) == null ? void 0 : _a[texture.format]) ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    var _a;
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer2 = this.renderer;
    this.initTextureType(texture, glTexture);
    if ((_a = texture.resource) == null ? void 0 : _a.upload(renderer2, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer2.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i2 = this.managedTextures.indexOf(texture);
        if (i2 !== -1) {
          removeItems(this.managedTextures, i2, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    var _a;
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if ((_a = texture.resource) == null ? void 0 : _a.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "texture"
};
extensions$1.add(TextureSystem);
class TransformFeedbackSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer: renderer2 } = this;
    if (shader) {
      renderer2.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer: renderer2, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i2 = 0; i2 < tf.buffers.length; i2++) {
      const buffer2 = tf.buffers[i2];
      if (!buffer2)
        continue;
      renderer2.buffer.update(buffer2);
      buffer2._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i2, buffer2._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i2 = 0; i2 < tf.buffers.length; i2++) {
        const buffer2 = tf.buffers[i2];
        if (!buffer2)
          continue;
        const buf = buffer2._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer2, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions$1.add(TransformFeedbackSystem);
class ViewSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  init(options2) {
    this.screen = new Rectangle(0, 0, options2.width, options2.height);
    this.element = options2.view || settings.ADAPTER.createCanvas();
    this.resolution = options2.resolution || settings.RESOLUTION;
    this.autoDensity = !!options2.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    var _a;
    if (removeView) {
      (_a = this.element.parentNode) == null ? void 0 : _a.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions$1.add(ViewSystem);
settings.PREFER_ENV = ENV.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
settings.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem.defaultOptions,
  ...ViewSystem.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings, {
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return Filter.defaultResolution;
    },
    set(value) {
      Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return Filter.defaultMultisample;
    },
    set(value) {
      Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value) {
      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return TextureGCSystem.defaultMode;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value) {
      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      Program.defaultFragmentPrecision = value;
    }
  }
});
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});
class TickerListener {
  constructor(fn, context2 = null, priority = 0, once3 = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once3;
  }
  match(fn, context2 = null) {
    return this.fn === fn && this.context === context2;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}
const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority));
  }
  addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context2) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;
Object.defineProperties(settings, {
  TARGET_FPMS: {
    get() {
      return Ticker.targetFPMS;
    },
    set(value) {
      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      Ticker.targetFPMS = value;
    }
  }
});
class TickerPlugin {
  static init(options2) {
    options2 = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options2);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options2.sharedTicker ? Ticker.shared : new Ticker();
    if (options2.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = ExtensionType.Application;
extensions$1.add(TickerPlugin);
const renderers = [];
extensions$1.handleByList(ExtensionType.Renderer, renderers);
function autoDetectRenderer(options2) {
  for (const RendererType of renderers) {
    if (RendererType.test(options2)) {
      return new RendererType(options2);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
const defaultVertex = $defaultVertex;
const defaultFilterVertex = $defaultFilterVertex;
class MultisampleSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY.HIGH) {
      this.multisample = MSAA_QUALITY.HIGH;
    } else if (samples >= MSAA_QUALITY.MEDIUM) {
      this.multisample = MSAA_QUALITY.MEDIUM;
    } else if (samples >= MSAA_QUALITY.LOW) {
      this.multisample = MSAA_QUALITY.LOW;
    } else {
      this.multisample = MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions$1.add(MultisampleSystem);
class GLBuffer {
  constructor(buffer2) {
    this.buffer = buffer2 || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}
class BufferSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer2) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer2, index2) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index2] !== buffer2) {
      const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
      this.boundBufferBases[index2] = buffer2;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer2, index2, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer2) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    if (buffer2._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer2._updateID;
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer2.data.byteLength) {
      gl.bufferSubData(buffer2.type, 0, buffer2.data);
    } else {
      const drawType = buffer2.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer2.data.byteLength;
      gl.bufferData(buffer2.type, buffer2.data, drawType);
    }
  }
  dispose(buffer2, contextLost) {
    if (!this.managedBuffers[buffer2.id]) {
      return;
    }
    delete this.managedBuffers[buffer2.id];
    const glBuffer = buffer2._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer2.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer2._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all2 = Object.keys(this.managedBuffers);
    for (let i2 = 0; i2 < all2.length; i2++) {
      this.dispose(this.managedBuffers[all2[i2]], contextLost);
    }
  }
  createGLBuffer(buffer2) {
    const { CONTEXT_UID, gl } = this;
    buffer2._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer2.id] = buffer2;
    buffer2.disposeRunner.add(this);
    return buffer2._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "buffer"
};
extensions$1.add(BufferSystem);
class ObjectRendererSystem {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  render(displayObject, options2) {
    const renderer2 = this.renderer;
    let renderTexture;
    let clear2;
    let transform;
    let skipUpdateTransform;
    if (options2) {
      renderTexture = options2.renderTexture;
      clear2 = options2.clear;
      transform = options2.transform;
      skipUpdateTransform = options2.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer2.runners.prerender.emit();
    renderer2.emit("prerender");
    renderer2.projection.transform = transform;
    if (renderer2.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer2.renderTexture.bind(renderTexture);
    renderer2.batch.currentRenderer.start();
    if (clear2 ?? renderer2.background.clearBeforeRender) {
      renderer2.renderTexture.clear();
    }
    displayObject.render(renderer2);
    renderer2.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options2.blit) {
        renderer2.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer2.runners.postrender.emit();
    renderer2.projection.transform = null;
    renderer2.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions$1.add(ObjectRendererSystem);
const _Renderer = class extends SystemManager {
  constructor(options2) {
    super();
    this.type = RENDERER_TYPE.WEBGL;
    options2 = Object.assign({}, settings.RENDER_OPTIONS, options2);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options2) {
      deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options2.premultipliedAlpha = options2.useContextAlpha && options2.useContextAlpha !== "notMultiplied";
      options2.backgroundAlpha = options2.useContextAlpha === false ? 1 : options2.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options2;
    this.startup.run(this.options);
  }
  static test(options2) {
    if (options2 == null ? void 0 : options2.forceCanvas) {
      return false;
    }
    return isWebGLSupported();
  }
  render(displayObject, options2) {
    this.objectRenderer.render(displayObject, options2);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options2) {
    return this.textureGenerator.generateTexture(displayObject, options2);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
extensions$1.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
extensions$1.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
extensions$1.add(Renderer);
class AbstractMultiResource extends Resource {
  constructor(length, options2) {
    const { width, height } = options2 || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i2 = 0; i2 < length; i2++) {
      const partTexture = new BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options2) {
    for (let i2 = 0; i2 < this.length; i2++) {
      if (!resources[i2]) {
        continue;
      }
      if (resources[i2].castToBaseTexture) {
        this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2);
      } else if (resources[i2] instanceof Resource) {
        this.addResourceAt(resources[i2], i2);
      } else {
        this.addResourceAt(autoDetectResource(resources[i2], options2), i2);
      }
    }
  }
  dispose() {
    for (let i2 = 0, len = this.length; i2 < len; i2++) {
      this.items[i2].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index2) {
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index2].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = baseTexture;
      this.items[i2].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = null;
      this.items[i2].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}
class ArrayResource extends AbstractMultiResource {
  constructor(source, options2) {
    const { width, height } = options2 || {};
    let urls;
    let length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    super(length, { width, height });
    if (urls) {
      this.initFromArray(urls, options2);
    }
  }
  addBaseTextureAt(baseTexture, index2) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index2);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer2, texture, glTexture) {
    const { length, itemDirtyIds, items } = this;
    const { gl } = renderer2;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (let i2 = 0; i2 < length; i2++) {
      const item = items[i2];
      if (itemDirtyIds[i2] < item.dirtyId) {
        itemDirtyIds[i2] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i2, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}
class CanvasResource extends BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}
const _CubeResource = class extends AbstractMultiResource {
  constructor(source, options2) {
    const { width, height, autoLoad, linkBaseTexture } = options2 || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i2 = 0; i2 < _CubeResource.SIDES; i2++) {
      this.items[i2].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options2);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index2, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index2]) {
      throw new Error(`Index ${index2} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index2] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index2] = baseTexture;
    return this;
  }
  upload(renderer2, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i2 = 0; i2 < _CubeResource.SIDES; i2++) {
      const side = this.items[i2];
      if (dirty[i2] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer2, side, glTexture);
          dirty[i2] = side.dirtyId;
        } else if (dirty[i2] < -1) {
          renderer2.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i2] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;
class ImageBitmapResource extends BaseImageResource {
  constructor(source, options2) {
    options2 = options2 || {};
    let baseSource;
    let url2;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url2 = source;
    } else {
      baseSource = source;
      url2 = null;
    }
    super(baseSource);
    this.url = url2;
    this.crossOrigin = options2.crossOrigin ?? true;
    this.alphaMode = typeof options2.alphaMode === "number" ? options2.alphaMode : null;
    this._load = null;
    if (options2.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve2, reject) => {
      if (this.url === null) {
        resolve2(this);
        return;
      }
      try {
        const response = await settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve2(this);
      } catch (e3) {
        if (this.destroyed)
          return;
        reject(e3);
        this.onError.emit(e3);
      }
    });
    return this._load;
  }
  upload(renderer2, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer2, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}
const _SVGResource = class extends BaseImageResource {
  constructor(sourceBase64, options2) {
    options2 = options2 || {};
    super(settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options2.scale || 1;
    this._overrideWidth = options2.width;
    this._overrideHeight = options2.height;
    this._resolve = null;
    this._crossorigin = options2.crossorigin;
    this._load = null;
    if (options2.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve2) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve2(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${uid$2()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size2 = {};
    if (sizeMatch) {
      size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size2;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const _VideoResource = class extends BaseImageResource {
  constructor(source, options2) {
    options2 = options2 || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options2.crossorigin);
      for (let i2 = 0; i2 < source.length; ++i2) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i2];
        src = src || source[i2];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext2 = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext2] || `video/${ext2}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options2.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options2.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options2.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve2) => {
      if (this.valid) {
        resolve2(this);
      } else {
        this._resolve = resolve2;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new Runner("disposeTransformFeedback");
  }
  bindBuffer(index2, buffer2) {
    this.buffers[index2] = buffer2;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}
const VERSION = "7.2.4";
class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a: a8, b: b3, c: c3, d: d2, tx, ty } = matrix;
    const x2 = a8 * point.x + c3 * point.y + tx;
    const y2 = b3 * point.x + d2 * point.y + ty;
    this.minX = Math.min(this.minX, x2);
    this.maxX = Math.max(this.maxX, x2);
    this.minY = Math.min(this.minY, y2);
    this.maxY = Math.max(this.maxY, y2);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = vertices[0];
    let y2 = vertices[1];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[2];
    y2 = vertices[3];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[4];
    y2 = vertices[5];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[6];
    y2 = vertices[7];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a8 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = a8 * x0 + c3 * y0 + tx;
    let y2 = b3 * x0 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x1 + c3 * y0 + tx;
    y2 = b3 * x1 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x0 + c3 * y1 + tx;
    y2 = b3 * x0 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a8 * x1 + c3 * y1 + tx;
    y2 = b3 * x1 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const x2 = vertexData[i2];
      const y2 = vertexData[i2 + 1];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a8 = matrix.a;
    const b3 = matrix.b;
    const c3 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const rawX = vertices[i2];
      const rawY = vertices[i2 + 1];
      const x2 = a8 * rawX + c3 * rawY + tx;
      const y2 = d2 * rawY + b3 * rawX + ty;
      minX = Math.min(minX, x2 - padX);
      maxX = Math.max(maxX, x2 + padX);
      minY = Math.min(minY, y2 - padY);
      maxY = Math.max(maxY, y2 + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area2) {
    const _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
    const _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
    const _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
    const _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}
class DisplayObject extends EventEmitter2 {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys2 = Object.keys(source);
    for (let i2 = 0; i2 < keys2.length; ++i2) {
      const propertyName = keys2[i2];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from2, point, skipUpdate) {
    if (from2) {
      position = from2.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  setTransform(x2 = 0, y2 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x2;
    this.position.y = y2;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
const tempMatrix = new Matrix();
function sortChildren(a8, b3) {
  if (a8.zIndex === b3.zIndex) {
    return a8._lastSortedIndex - b3._lastSortedIndex;
  }
  return a8.zIndex - b3.zIndex;
}
const _Container = class extends DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.addChild(children[i2]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index2) {
    if (index2 < 0 || index2 > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index2, 0, child);
    this._boundsID++;
    this.onChildrenChange(index2);
    child.emit("added", this);
    this.emit("childAdded", child, this, index2);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index2 = this.children.indexOf(child);
    if (index2 === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index2;
  }
  setChildIndex(child, index$1) {
    if (index$1 < 0 || index$1 >= this.children.length) {
      throw new Error(`The index ${index$1} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index$1, 0, child);
    this.onChildrenChange(index$1);
  }
  getChildAt(index2) {
    if (index2 < 0 || index2 >= this.children.length) {
      throw new Error(`getChildAt: Index (${index2}) does not exist.`);
    }
    return this.children[index2];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
    } else {
      const child = children[0];
      const index$1 = this.children.indexOf(child);
      if (index$1 === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index$1, 1);
      this._boundsID++;
      this.onChildrenChange(index$1);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index$1);
    }
    return children[0];
  }
  removeChildAt(index$1) {
    const child = this.getChildAt(index$1);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index$1, 1);
    this._boundsID++;
    this.onChildrenChange(index$1);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index$1);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].parent = null;
        if (removed[i2].transform) {
          removed[i2].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].emit("removed", this);
        this.emit("childRemoved", removed[i2], this, i2);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      child._lastSortedIndex = i2;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        const child = this.children[i2];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer2) {
    const sourceFrame = renderer2.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer2.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer2);
    } else if (this.cullArea) {
      return;
    }
    for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      const child = this.children[i2];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer2);
      child.cullable = childCullable;
    }
  }
  render(renderer2) {
    var _a;
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || ((_a = this.filters) == null ? void 0 : _a.length)) {
      this.renderAdvanced(renderer2);
    } else if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer2);
      }
    }
  }
  renderAdvanced(renderer2) {
    var _a, _b, _c;
    const filters2 = this.filters;
    const mask = this._mask;
    if (filters2) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i2 = 0; i2 < filters2.length; i2++) {
        if (filters2[i2].enabled) {
          this._enabledFilters.push(filters2[i2]);
        }
      }
    }
    const flush = filters2 && ((_a = this._enabledFilters) == null ? void 0 : _a.length) || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
    if (flush) {
      renderer2.batch.flush();
    }
    if (filters2 && ((_b = this._enabledFilters) == null ? void 0 : _b.length)) {
      renderer2.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer2.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer2);
    } else {
      this._render(renderer2);
      for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer2);
      }
    }
    if (flush) {
      renderer2.batch.flush();
    }
    if (mask) {
      renderer2.mask.pop(this);
    }
    if (filters2 && ((_c = this._enabledFilters) == null ? void 0 : _c.length)) {
      renderer2.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options2) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options2 === "boolean" ? options2 : options2 == null ? void 0 : options2.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i2 = 0; i2 < oldChildren.length; ++i2) {
        oldChildren[i2].destroy(options2);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
let Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
Object.defineProperties(settings, {
  SORTABLE_CHILDREN: {
    get() {
      return Container.defaultSortableChildren;
    },
    set(value) {
      deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      Container.defaultSortableChildren = value;
    }
  }
});
const tempPoint$2 = new Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends Container {
  constructor(texture) {
    super();
    this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim2 = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim2) {
      w1 = trim2.x - anchor._x * orig.width;
      w0 = w1 + trim2.width;
      h1 = trim2.y - anchor._y * orig.height;
      h0 = h1 + trim2.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a8 * w1 + c3 * h1 + tx;
    vertexData[1] = d2 * h1 + b3 * w1 + ty;
    vertexData[2] = a8 * w0 + c3 * h1 + tx;
    vertexData[3] = d2 * h1 + b3 * w0 + ty;
    vertexData[4] = a8 * w0 + c3 * h0 + tx;
    vertexData[5] = d2 * h0 + b3 * w0 + ty;
    vertexData[6] = a8 * w1 + c3 * h0 + tx;
    vertexData[7] = d2 * h0 + b3 * w1 + ty;
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a8 * w1 + c3 * h1 + tx;
    vertexData[1] = d2 * h1 + b3 * w1 + ty;
    vertexData[2] = a8 * w0 + c3 * h1 + tx;
    vertexData[3] = d2 * h1 + b3 * w0 + ty;
    vertexData[4] = a8 * w0 + c3 * h0 + tx;
    vertexData[5] = d2 * h0 + b3 * w0 + ty;
    vertexData[6] = a8 * w1 + c3 * h0 + tx;
    vertexData[7] = d2 * h0 + b3 * w1 + ty;
  }
  _render(renderer2) {
    this.calculateVertices();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim2 = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options2) {
    super.destroy(options2);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options2 === "boolean" ? options2 : options2 == null ? void 0 : options2.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options2 === "boolean" ? options2 : options2 == null ? void 0 : options2.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options2) {
    const texture = source instanceof Texture ? source : Texture.from(source, options2);
    return new Sprite(texture);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}
const _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer2);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer2);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer2) {
  var _a, _b;
  if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer2.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if ((_b = this.filters) == null ? void 0 : _b.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  const cachedRenderTexture = renderer2.renderTexture.current;
  const cachedSourceFrame = renderer2.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer2.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer2.projection.transform;
  const renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer2.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer2.multisample
  });
  const textureCacheId = `cacheAsBitmap_${uid$2()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.framebuffer.blit();
  renderer2.projection.transform = cachedProjectionTransform;
  renderer2.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer2) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer2);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer2);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer2) {
  var _a;
  if ((_a = this._cacheData) == null ? void 0 : _a.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer2.canvasContext.activeContext;
  const cachedProjectionTransform = renderer2._projTransform;
  bounds.ceil(settings.RESOLUTION);
  const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${uid$2()}`;
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  const m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2);
  m2.invert();
  m2.tx -= bounds.x;
  m2.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer2.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer2.canvasContext.activeContext = cachedRenderTarget;
  renderer2._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer2._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options2) {
  this.cacheAsBitmap = false;
  this.destroy(options2);
};
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name2, deep) {
  for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
    if (this.children[i2].name === name2) {
      return this.children[i2];
    }
  }
  if (deep) {
    for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
      const child = this.children[i2];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name2, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
var fragment$6 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
class AlphaFilter extends Filter {
  constructor(alpha = 1) {
    super(defaultVertex, fragment$6, { uAlpha: 1 });
    this.alpha = alpha;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    value = i2;
    if (i2 >= halfLength) {
      value = kernelSize - i2 - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x2) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", `${i2 - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
class BlurFilterPass extends Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource(kernelSize, horizontal);
    const fragSrc = generateBlurFragSource(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer2 = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
      for (let i2 = 1; i2 < this.passes - 1; i2++) {
        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer2.shader.bind(this);
        renderer2.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}
class BlurFilter extends Filter {
  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}
var fragment$5 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
class ColorMatrixFilter extends Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(defaultFilterVertex, fragment$5, uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a8, b3) {
    out[0] = a8[0] * b3[0] + a8[1] * b3[5] + a8[2] * b3[10] + a8[3] * b3[15];
    out[1] = a8[0] * b3[1] + a8[1] * b3[6] + a8[2] * b3[11] + a8[3] * b3[16];
    out[2] = a8[0] * b3[2] + a8[1] * b3[7] + a8[2] * b3[12] + a8[3] * b3[17];
    out[3] = a8[0] * b3[3] + a8[1] * b3[8] + a8[2] * b3[13] + a8[3] * b3[18];
    out[4] = a8[0] * b3[4] + a8[1] * b3[9] + a8[2] * b3[14] + a8[3] * b3[19] + a8[4];
    out[5] = a8[5] * b3[0] + a8[6] * b3[5] + a8[7] * b3[10] + a8[8] * b3[15];
    out[6] = a8[5] * b3[1] + a8[6] * b3[6] + a8[7] * b3[11] + a8[8] * b3[16];
    out[7] = a8[5] * b3[2] + a8[6] * b3[7] + a8[7] * b3[12] + a8[8] * b3[17];
    out[8] = a8[5] * b3[3] + a8[6] * b3[8] + a8[7] * b3[13] + a8[8] * b3[18];
    out[9] = a8[5] * b3[4] + a8[6] * b3[9] + a8[7] * b3[14] + a8[8] * b3[19] + a8[9];
    out[10] = a8[10] * b3[0] + a8[11] * b3[5] + a8[12] * b3[10] + a8[13] * b3[15];
    out[11] = a8[10] * b3[1] + a8[11] * b3[6] + a8[12] * b3[11] + a8[13] * b3[16];
    out[12] = a8[10] * b3[2] + a8[11] * b3[7] + a8[12] * b3[12] + a8[13] * b3[17];
    out[13] = a8[10] * b3[3] + a8[11] * b3[8] + a8[12] * b3[13] + a8[13] * b3[18];
    out[14] = a8[10] * b3[4] + a8[11] * b3[9] + a8[12] * b3[14] + a8[13] * b3[19] + a8[14];
    out[15] = a8[15] * b3[0] + a8[16] * b3[5] + a8[17] * b3[10] + a8[18] * b3[15];
    out[16] = a8[15] * b3[1] + a8[16] * b3[6] + a8[17] * b3[11] + a8[18] * b3[16];
    out[17] = a8[15] * b3[2] + a8[16] * b3[7] + a8[17] * b3[12] + a8[18] * b3[17];
    out[18] = a8[15] * b3[3] + a8[16] * b3[8] + a8[17] * b3[13] + a8[18] * b3[18];
    out[19] = a8[15] * b3[4] + a8[16] * b3[9] + a8[17] * b3[14] + a8[18] * b3[19] + a8[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m2 = new Float32Array(matrix);
    m2[4] /= 255;
    m2[9] /= 255;
    m2[14] /= 255;
    m2[19] /= 255;
    return m2;
  }
  brightness(b3, multiply) {
    const matrix = [
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r2, g2, b3] = Color.shared.setValue(color).toArray();
    const matrix = [
      r2,
      0,
      0,
      0,
      0,
      0,
      g2,
      0,
      0,
      0,
      0,
      0,
      b3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w2 = 1 / 3;
    const sqrW = sqrt(w2);
    const a00 = cosR + (1 - cosR) * w2;
    const a01 = w2 * (1 - cosR) - sqrW * sinR;
    const a02 = w2 * (1 - cosR) + sqrW * sinR;
    const a10 = w2 * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w2 * (1 - cosR);
    const a12 = w2 * (1 - cosR) - sqrW * sinR;
    const a20 = w2 * (1 - cosR) - sqrW * sinR;
    const a21 = w2 * (1 - cosR) + sqrW * sinR;
    const a222 = cosR + w2 * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a222,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v2 = (amount || 0) + 1;
    const o2 = -0.5 * (v2 - 1);
    const matrix = [
      v2,
      0,
      0,
      0,
      o2,
      0,
      v2,
      0,
      0,
      o2,
      0,
      0,
      v2,
      0,
      o2,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x2 = amount * 2 / 3 + 1;
    const y2 = (x2 - 1) * -0.5;
    const matrix = [
      x2,
      y2,
      y2,
      0,
      0,
      y2,
      x2,
      y2,
      0,
      0,
      y2,
      y2,
      x2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
var fragment$4 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$3 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
class DisplacementFilter extends Filter {
  constructor(sprite2, scale) {
    const maskMatrix = new Matrix();
    sprite2.renderable = false;
    super(vertex$3, fragment$4, {
      mapSampler: sprite2._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite2;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}
var fragment$3 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
var vertex$2 = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
class FXAAFilter extends Filter {
  constructor() {
    super(vertex$2, fragment$3);
  }
}
var fragment$2 = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
class NoiseFilter extends Filter {
  constructor(noise = 0.5, seed = Math.random()) {
    super(defaultFilterVertex, fragment$2, {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}
const filters = {
  AlphaFilter,
  BlurFilter,
  BlurFilterPass,
  ColorMatrixFilter,
  DisplacementFilter,
  FXAAFilter,
  NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events2) {
    this.removeTickerListener();
    this.events = events2;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();
class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point();
    this.page = new Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}
class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new Point();
    this.movement = new Point();
    this.offset = new Point();
    this.global = new Point();
    this.screen = new Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}
class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;
const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new Point();
const tempLocalMapping = new Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new EventEmitter2();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a8, b3) => a8.priority - b3.priority);
  }
  dispatchEvent(e3, type) {
    e3.propagationStopped = false;
    e3.propagationImmediatelyStopped = false;
    this.propagate(e3, type);
    this.dispatch.emit(type || e3.type, e3);
  }
  mapEvent(e3) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e3.type];
    if (mappers) {
      for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
        mappers[i2].fn(e3);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
    }
  }
  hitTest(x2, y2) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x2, y2), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e3, type) {
    if (!e3.target) {
      return;
    }
    const composedPath = e3.composedPath();
    e3.eventPhase = e3.CAPTURING_PHASE;
    for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
      e3.currentTarget = composedPath[i2];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
    e3.eventPhase = e3.AT_TARGET;
    e3.currentTarget = e3.target;
    this.notifyTarget(e3, type);
    if (e3.propagationStopped || e3.propagationImmediatelyStopped)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
      e3.currentTarget = composedPath[i2];
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped)
        return;
    }
  }
  all(e3, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e3.eventPhase = e3.BUBBLING_PHASE;
    const events2 = Array.isArray(type) ? type : [type];
    for (let i2 = targets.length - 1; i2 >= 0; i2--) {
      events2.forEach((event) => {
        e3.currentTarget = targets[i2];
        this.notifyTarget(e3, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1; i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    var _a;
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !((_a = maskObject.containsPoint) == null ? void 0 : _a.call(maskObject, location))) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e3, type) {
    var _a, _b;
    type = type ?? e3.type;
    const handlerKey = `on${type}`;
    (_b = (_a = e3.currentTarget)[handlerKey]) == null ? void 0 : _b.call(_a, e3);
    const key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e3, key);
    if (e3.eventPhase === e3.AT_TARGET) {
      this.notifyListeners(e3, type);
    }
  }
  mapPointerDown(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e3 = this.createPointerEvent(from2);
    this.dispatchEvent(e3, "pointerdown");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchstart");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from2.pointerId);
    trackingData.pressTargetsByButton[from2.button] = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerMove(from2) {
    var _a, _b;
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e3 = this.createPointerEvent(from2);
    this._isPointerMoveEvent = false;
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    const trackingData = this.trackingData(from2.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (((_a = trackingData.overTargets) == null ? void 0 : _a.length) > 0 && outTarget !== e3.target) {
      const outType = from2.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from2, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e3.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e3.target) {
      const overType = from2.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e3, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget == null ? void 0 : outTarget.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e3.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e3.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = (_b = e3.target) == null ? void 0 : _b.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e3, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
  }
  mapPointerOver(from2) {
    var _a;
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    const e3 = this.createPointerEvent(from2);
    const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
    this.dispatchEvent(e3, "pointerover");
    if (isMouse)
      this.dispatchEvent(e3, "mouseover");
    if (e3.pointerType === "mouse")
      this.cursor = (_a = e3.target) == null ? void 0 : _a.cursor;
    const enterEvent = this.clonePointerEvent(e3, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e3.composedPath();
    this.freeEvent(e3);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from2.pointerType === "mouse" || from2.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from2, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from2, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e3 = this.createPointerEvent(from2);
    this.dispatchEvent(e3, "pointerup");
    if (e3.pointerType === "touch") {
      this.dispatchEvent(e3, "touchend");
    } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
      const isRightButton = e3.button === 2;
      this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from2.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e3.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e3.composedPath().includes(currentTarget)) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from2.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e3, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from2.button]) {
        trackingData.clicksByButton[from2.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from2.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e3);
  }
  mapPointerUpOutside(from2) {
    if (!(from2 instanceof FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from2.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from2.button]);
    const e3 = this.createPointerEvent(from2);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e3.currentTarget = currentTarget;
        this.notifyTarget(e3, "pointerupoutside");
        if (e3.pointerType === "touch") {
          this.notifyTarget(e3, "touchendoutside");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from2.button];
    }
    this.freeEvent(e3);
  }
  mapWheel(from2) {
    if (!(from2 instanceof FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from2);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i2 = 1; i2 < propagationPath.length; i2++) {
      if (propagationPath[i2].parent === currentTarget) {
        currentTarget = propagationPath[i2];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from2, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from2) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from2, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from2.nativeEvent;
    event.originalEvent = from2.originalEvent;
    this.copyPointerData(from2, event);
    this.copyMouseData(from2, event);
    this.copyData(from2, event);
    event.target = from2.target;
    event.path = from2.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from2, to) {
    to.deltaMode = from2.deltaMode;
    to.deltaX = from2.deltaX;
    to.deltaY = from2.deltaY;
    to.deltaZ = from2.deltaZ;
  }
  copyPointerData(from2, to) {
    if (!(from2 instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
      return;
    to.pointerId = from2.pointerId;
    to.width = from2.width;
    to.height = from2.height;
    to.isPrimary = from2.isPrimary;
    to.pointerType = from2.pointerType;
    to.pressure = from2.pressure;
    to.tangentialPressure = from2.tangentialPressure;
    to.tiltX = from2.tiltX;
    to.tiltY = from2.tiltY;
    to.twist = from2.twist;
  }
  copyMouseData(from2, to) {
    if (!(from2 instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
      return;
    to.altKey = from2.altKey;
    to.button = from2.button;
    to.buttons = from2.buttons;
    to.client.copyFrom(from2.client);
    to.ctrlKey = from2.ctrlKey;
    to.metaKey = from2.metaKey;
    to.movement.copyFrom(from2.movement);
    to.screen.copyFrom(from2.screen);
    to.shiftKey = from2.shiftKey;
    to.global.copyFrom(from2.global);
  }
  copyData(from2, to) {
    to.isTrusted = from2.isTrusted;
    to.srcElement = from2.srcElement;
    to.timeStamp = performance.now();
    to.type = from2.type;
    to.detail = from2.detail;
    to.view = from2.view;
    to.which = from2.which;
    to.layer.copyFrom(from2.layer);
    to.page.copyFrom(from2.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e3, type) {
    const listeners2 = e3.currentTarget._events[type];
    if (!listeners2)
      return;
    if (!e3.currentTarget.isInteractive())
      return;
    if ("fn" in listeners2) {
      if (listeners2.once)
        e3.currentTarget.removeListener(type, listeners2.fn, void 0, true);
      listeners2.fn.call(listeners2.context, e3);
    } else {
      for (let i2 = 0, j2 = listeners2.length; i2 < j2 && !e3.propagationImmediatelyStopped; i2++) {
        if (listeners2[i2].once)
          e3.currentTarget.removeListener(type, listeners2[i2].fn, void 0, true);
        listeners2[i2].fn.call(listeners2[i2].context, e3);
      }
    }
  }
}
const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer2) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer2;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options2) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options2.eventMode ?? "auto";
    Object.assign(this.features, options2.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events2 = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events2[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i2 = 0, j2 = events2.length; i2 < j2; i2++) {
      const nativeEvent2 = events2[i2];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x2, y2) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
        const touch = event.changedTouches[i2];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.RendererSystem,
    ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
extensions$1.add(EventSystem);
function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
  },
  set interactive(value) {
    deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options2) {
    const capture = typeof options2 === "boolean" && options2 || typeof options2 === "object" && options2.capture;
    const context2 = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context2);
  },
  removeEventListener(type, listener, options2) {
    const capture = typeof options2 === "boolean" && options2 || typeof options2 === "object" && options2.capture;
    const context2 = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context2);
  },
  dispatchEvent(e3) {
    if (!(e3 instanceof FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e3.defaultPrevented = false;
    e3.path = null;
    e3.target = this;
    e3.manager.dispatchEvent(e3);
    return !e3.defaultPrevented;
  }
};
DisplayObject.mixin(FederatedDisplayObject);
const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer2) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile.tablet || isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer2;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    var _a;
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    (_a = this.renderer.view.parentNode) == null ? void 0 : _a.appendChild(this.div);
  }
  deactivate() {
    var _a;
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    (_a = this.div.parentNode) == null ? void 0 : _a.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.updateAccessibleObjects(children[i2]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x: x2, y: y2, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x2}px`;
    div.style.top = `${y2}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const child = this.children[i2];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i2, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i2--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e3, type) {
    const { displayObject: target } = e3.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e3) {
    this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
  }
  _onFocus(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e3, ["mouseover"]);
  }
  _onFocusOut(e3) {
    if (!e3.target.getAttribute("aria-live")) {
      e3.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e3, ["mouseout"]);
  }
  _onKeyDown(e3) {
    if (e3.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e3) {
    if (e3.movementX === 0 && e3.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    ExtensionType.RendererPlugin,
    ExtensionType.CanvasRendererPlugin
  ]
};
extensions$1.add(AccessibilityManager);
const _Application = class {
  constructor(options2) {
    this.stage = new Container();
    options2 = Object.assign({
      forceCanvas: false
    }, options2);
    this.renderer = autoDetectRenderer(options2);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options2);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
extensions$1.handleByList(ExtensionType.Application, Application._plugins);
class ResizePlugin {
  static init(options2) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options2.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = ExtensionType.Application;
extensions$1.add(ResizePlugin);
const assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions$1.handle(ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions$1.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions$1.remove(ref[key]));
});
class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a8) => {
      this._assetList.push(a8);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i2 = 0; i2 < toLoadAmount; i2++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}
function checkDataUrl(url2, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url2.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url2.startsWith(`data:${mimes}`);
}
function checkExtension(url2, extension) {
  const tempURL = url2.split("?")[0];
  const ext2 = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext2);
  }
  return ext2 === extension;
}
const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};
function processX(base2, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i2 = 0; i2 < id.length; i2++) {
    const value = id[i2];
    if (depth < ids.length - 1) {
      processX(base2.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base2.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
const isSingleItem = (item) => !Array.isArray(item);
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys2 = convertToList(key);
    let cacheableAssets;
    for (let i2 = 0; i2 < this.parsers.length; i2++) {
      const parser = this.parsers[i2];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys2, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys2.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys: keys2
    };
    keys2.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof Texture) {
      const texture = value;
      keys2.forEach((key2) => {
        if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
          BaseTexture.addToCache(texture.baseTexture, key2);
        }
        Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();
class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url2, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      var _a, _b;
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`);
        }
      }
      if (!parser) {
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parserX = this.parsers[i2];
          if (parserX.load && ((_a = parserX.test) == null ? void 0 : _a.call(parserX, url2, data, this))) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url2, data, this);
      result.parser = parser;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser2 = this.parsers[i2];
        if (parser2.parse) {
          if (parser2.parse && await ((_b = parser2.testParse) == null ? void 0 : _b.call(parser2, asset, data, this))) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url2 = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url2]) {
            this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
          }
          assets[asset.src] = await this.promiseCache[url2].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e3) {
          delete this.promiseCache[url2];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url2}.
${e3}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      var _a, _b;
      const url2 = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url2];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        (_b = (_a = loadPromise.parser) == null ? void 0 : _a.unload) == null ? void 0 : _b.call(_a, loadedAsset, asset, this);
        delete this.promiseCache[url2];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});
const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url2) {
    return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
  },
  async load(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    const json = await response.json();
    return json;
  }
};
extensions$1.add(loadJson);
const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  test(url2) {
    return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
  },
  async load(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    const txt = await response.text();
    return txt;
  }
};
extensions$1.add(loadTxt);
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url2) {
  const ext2 = path.extname(url2);
  const name2 = path.basename(url2, ext2);
  const nameWithSpaces = name2.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url2) {
    return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
  },
  async load(url2, options2) {
    var _a, _b, _c;
    const fonts = settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name2 = ((_a = options2.data) == null ? void 0 : _a.family) ?? getFontFamilyName(url2);
      const weights = ((_c = (_b = options2.data) == null ? void 0 : _b.weights) == null ? void 0 : _c.filter((weight) => validWeights.includes(weight))) ?? ["normal"];
      const data = options2.data ?? {};
      for (let i2 = 0; i2 < weights.length; i2++) {
        const weight = weights[i2];
        const font = new FontFace(name2, `url(${encodeURI(url2)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t2) => settings.ADAPTER.getFontFaceSet().delete(t2));
  }
};
extensions$1.add(loadWebFont);
let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve2) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve2(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve2, reject) => {
      this.queue.push({ id, arguments: args, resolve: resolve2, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();
function createTexture(base2, loader, url2) {
  const texture = new Texture(base2);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url2];
  });
  return texture;
}
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url2) {
  const response = await settings.ADAPTER.fetch(url2);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url2) {
    return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
  },
  async load(url2, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.loadImageBitmap(url2);
      } else {
        src = await loadImageBitmap(url2);
      }
    } else {
      src = await new Promise((resolve2) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url2;
        if (src.complete) {
          resolve2(src);
        } else {
          src.onload = () => {
            resolve2(src);
          };
        }
      });
    }
    const base2 = new BaseTexture(src, {
      resolution: getResolutionOfUrl(url2),
      ...asset.data
    });
    base2.resource.src = url2;
    return createTexture(base2, loader, url2);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
extensions$1.add(loadTextures);
const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url2) {
    return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
  },
  async testParse(data) {
    return SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    var _a;
    const src = new SVGResource(asset, (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.resourceOptions);
    await src.load();
    const base2 = new BaseTexture(src, {
      resolution: getResolutionOfUrl(asset),
      ...data == null ? void 0 : data.data
    });
    base2.resource.src = asset;
    const texture = createTexture(base2, loader, asset);
    return texture;
  },
  async load(url2, _options) {
    const response = await settings.ADAPTER.fetch(url2);
    return response.text();
  },
  unload: loadTextures.unload
};
extensions$1.add(loadSVG);
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name2) => this._createBundleAssetId(bundleId, name2));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys2 = convertToList(keysIn);
    keys2.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = createStringVariations(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i2 = 0; i2 < this._parsers.length; i2++) {
          const parser = this._parsers[i2];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys2;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys2.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i2 in result) {
        out[i2] = result[i2].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys2) {
    const singleAsset = isSingleItem(keys2);
    keys2 = convertToList(keys2);
    const result = {};
    keys2.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys2[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i2 = 0; i2 < assets.length; i2++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url2) {
    if (!this._defaultSearchParams)
      return url2;
    const paramConnector = /\?/.test(url2) ? "&" : "?";
    return `${url2}${paramConnector}${this._defaultSearchParams}`;
  }
}
class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options2 = {}) {
    var _a, _b, _c;
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options2.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options2.defaultSearchParams);
    }
    if (options2.basePath) {
      this.resolver.basePath = options2.basePath;
    }
    if (options2.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options2.bundleIdentifier);
    }
    if (options2.manifest) {
      let manifest = options2.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = ((_a = options2.texturePreference) == null ? void 0 : _a.resolution) ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats2 = [];
    if ((_b = options2.texturePreference) == null ? void 0 : _b.format) {
      const formatPref = (_c = options2.texturePreference) == null ? void 0 : _c.format;
      formats2 = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats2 = await detection.remove(formats2);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats2 = await detection.add(formats2);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats2,
        resolution
      }
    });
    if (options2.preferences) {
      this.setPreferences(options2.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url2) => {
      if (typeof url2 !== "string") {
        this.resolver.add(url2.src, url2);
        return url2.src;
      }
      if (!this.resolver.hasKey(url2)) {
        this.resolver.add(url2, url2);
      }
      return url2;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys2 = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress == null ? void 0 : onProgress(++count / total);
    };
    const promises = keys2.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys2) {
    if (typeof keys2 === "string") {
      return Cache.get(keys2);
    }
    const assets = {};
    for (let i2 = 0; i2 < keys2.length; i2++) {
      assets[i2] = Cache.get(keys2[i2]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i2) => {
      const asset = loadedAssets[resolveResult.src];
      const keys2 = [resolveResult.src];
      if (resolveResult.alias) {
        keys2.push(...resolveResult.alias);
      }
      out[resolveKeys[i2]] = asset;
      Cache.set(keys2, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
extensions$1.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
const cacheTextureArray = {
  extension: ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
  getCacheableAssets: (keys2, asset) => {
    const out = {};
    keys2.forEach((key) => {
      asset.forEach((item, i2) => {
        out[key + (i2 === 0 ? "" : i2 + 1)] = item;
      });
    });
    return out;
  }
};
extensions$1.add(cacheTextureArray);
const detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await settings.ADAPTER.fetch(avifData).then((r2) => r2.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats2) => [...formats2, "avif"],
  remove: async (formats2) => formats2.filter((f3) => f3 !== "avif")
};
extensions$1.add(detectAvif);
const detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await settings.ADAPTER.fetch(webpData).then((r2) => r2.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats2) => [...formats2, "webp"],
  remove: async (formats2) => formats2.filter((f3) => f3 !== "webp")
};
extensions$1.add(detectWebp);
const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats2) => [...formats2, ...imageFormats],
  remove: async (formats2) => formats2.filter((f3) => !imageFormats.includes(f3))
};
extensions$1.add(detectDefaults);
const resolveTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: loadTextures.test,
  parse: (value) => {
    var _a;
    return {
      resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
extensions$1.add(resolveTextureUrl);
var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [
    33776
    /* COMPRESSED_RGB_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    33777
    /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    33778
    /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
  ]: 1,
  [
    33779
    /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
  ]: 1,
  [
    35916
    /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    35917
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
  ]: 0.5,
  [
    35918
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
  ]: 1,
  [
    35919
    /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
  ]: 1,
  [
    37488
    /* COMPRESSED_R11_EAC */
  ]: 0.5,
  [
    37489
    /* COMPRESSED_SIGNED_R11_EAC */
  ]: 0.5,
  [
    37490
    /* COMPRESSED_RG11_EAC */
  ]: 1,
  [
    37491
    /* COMPRESSED_SIGNED_RG11_EAC */
  ]: 1,
  [
    37492
    /* COMPRESSED_RGB8_ETC2 */
  ]: 0.5,
  [
    37496
    /* COMPRESSED_RGBA8_ETC2_EAC */
  ]: 1,
  [
    37493
    /* COMPRESSED_SRGB8_ETC2 */
  ]: 0.5,
  [
    37497
    /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
  ]: 1,
  [
    37494
    /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
  ]: 0.5,
  [
    37495
    /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
  ]: 0.5,
  [
    35840
    /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */
  ]: 0.5,
  [
    35842
    /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */
  ]: 0.5,
  [
    35841
    /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */
  ]: 0.25,
  [
    35843
    /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */
  ]: 0.25,
  [
    36196
    /* COMPRESSED_RGB_ETC1_WEBGL */
  ]: 0.5,
  [
    35986
    /* COMPRESSED_RGB_ATC_WEBGL */
  ]: 0.5,
  [
    35986
    /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */
  ]: 1,
  [
    34798
    /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */
  ]: 1,
  [
    37808
    /* COMPRESSED_RGBA_ASTC_4x4_KHR */
  ]: 1
};
let storedGl;
let extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats2) => {
    if (!extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      const extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats2];
  },
  remove: async (formats2) => {
    if (!extensions)
      getCompressedTextureExtensions();
    return formats2.filter((f3) => !(f3 in extensions));
  }
};
extensions$1.add(detectCompressedTextures);
class BlobResource extends BufferResource {
  constructor(source, options2 = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options2);
    this.origin = origin;
    this.buffer = data ? new ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options2.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}
class CompressedTextureResource extends BlobResource {
  constructor(source, options2) {
    super(source, options2);
    this.format = options2.format;
    this.levels = options2.levels || 1;
    this._width = options2.width;
    this._height = options2.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options2.levelBuffers || this.buffer) {
      this._levelBuffers = options2.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer2, _texture, _glTexture) {
    const gl = renderer2.gl;
    const extension = renderer2.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i2 = 0, j2 = this.levels; i2 < j2; i2++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i2];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format2) {
    if (format2 >= 33776 && format2 <= 33779) {
      return "s3tc";
    } else if (format2 >= 37488 && format2 <= 37497) {
      return "etc";
    } else if (format2 >= 35840 && format2 <= 35843) {
      return "pvrtc";
    } else if (format2 >= 36196) {
      return "etc1";
    } else if (format2 >= 35986 && format2 <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer2, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer2.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (let i2 = 0; i2 < levels; i2++) {
      buffers[i2] = {
        levelID: i2,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer2.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    }
    return buffers;
  }
}
const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [
    70
    /* DXGI_FORMAT_BC1_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [
    71
    /* DXGI_FORMAT_BC1_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [
    73
    /* DXGI_FORMAT_BC2_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [
    74
    /* DXGI_FORMAT_BC2_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [
    76
    /* DXGI_FORMAT_BC3_TYPELESS */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [
    77
    /* DXGI_FORMAT_BC3_UNORM */
  ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [
    72
    /* DXGI_FORMAT_BC1_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [
    75
    /* DXGI_FORMAT_BC2_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [
    78
    /* DXGI_FORMAT_BC3_UNORM_SRGB */
  ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i2 = 0; i2 < mipmapCount; i2++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i2 = 0; i2 < arraySize; i2++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer2) => new CompressedTextureResource(buffer2, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [TYPES.UNSIGNED_BYTE]: 1,
  [TYPES.UNSIGNED_SHORT]: 2,
  [TYPES.INT]: 4,
  [TYPES.UNSIGNED_INT]: 4,
  [TYPES.FLOAT]: 4,
  [TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [FORMATS.RGBA]: 4,
  [FORMATS.RGB]: 3,
  [FORMATS.RG]: 2,
  [FORMATS.RED]: 1,
  [FORMATS.LUMINANCE]: 1,
  [FORMATS.LUMINANCE_ALPHA]: 2,
  [FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url2, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer2 = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === TYPES.FLOAT) {
          buffer2 = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer2 = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === TYPES.INT) {
          convertToInt = true;
          buffer2 = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new BufferResource(buffer2, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url2, dataView) {
  for (let i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {
    if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2]) {
      console.error(`${url2} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format2) {
  switch (format2) {
    case FORMATS.RGBA:
      return FORMATS.RGBA_INTEGER;
    case FORMATS.RGB:
      return FORMATS.RGB_INTEGER;
    case FORMATS.RG:
      return FORMATS.RG_INTEGER;
    case FORMATS.RED:
      return FORMATS.RED_INTEGER;
    default:
      return format2;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
const loadDDS = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url2) {
    return checkExtension(url2, ".dds");
  },
  async load(url2, asset, loader) {
    const response = await settings.ADAPTER.fetch(url2);
    const arrayBuffer = await response.arrayBuffer();
    const resources = parseDDS(arrayBuffer);
    const textures = resources.map((resource) => {
      const base2 = new BaseTexture(resource, {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: getResolutionOfUrl(url2),
        ...asset.data
      });
      return createTexture(base2, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t2) => t2.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions$1.add(loadDDS);
const loadKTX = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url2) {
    return checkExtension(url2, ".ktx");
  },
  async load(url2, asset, loader) {
    const response = await settings.ADAPTER.fetch(url2);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options2 = {
      mipmap: MIPMAP_MODES.OFF,
      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: getResolutionOfUrl(url2),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options2, {
          type: resource.type,
          format: resource.format
        });
      }
      const base2 = new BaseTexture(resource, options2);
      base2.ktxKeyValueData = kvData;
      return createTexture(base2, loader, url2);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t2) => t2.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
extensions$1.add(loadKTX);
const resolveCompressedTextureUrl = {
  extension: ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    var _a, _b;
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext2) => value.endsWith(ext2))) {
        return {
          resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) ?? "1"),
          format: extensions2.find((ext2) => value.endsWith(ext2)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(((_b = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _b[1]) ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
extensions$1.add(resolveCompressedTextureUrl);
const TEMP_RECT = new Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer2) {
    this.renderer = renderer2;
  }
  async image(target, format2, quality) {
    const image = new Image();
    image.src = await this.base64(target, format2, quality);
    return image;
  }
  async base64(target, format2, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve2, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve2(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format2, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format2, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format2, quality });
      return new Promise((resolve2, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve2(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer2 = this.renderer;
    if (!renderer2) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer2.generateTexture(target, {
          resolution: renderer2.resolution,
          multisample: renderer2.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer2.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer2.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer2.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer2.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer2.width / resolution;
        frame.height = renderer2.height / resolution;
      }
      flipY = true;
      renderer2.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer2.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture == null ? void 0 : renderTexture.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w2 = width << 2;
    const h2 = height >> 1;
    const temp = new Uint8Array(w2);
    for (let y2 = 0; y2 < h2; y2++) {
      const t2 = y2 * w2;
      const b3 = (height - y2 - 1) * w2;
      temp.set(pixels.subarray(t2, t2 + w2));
      pixels.copyWithin(t2, b3, b3 + w2);
      pixels.set(temp, b3);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n2 = pixels.length;
    for (let i2 = 0; i2 < n2; i2 += 4) {
      const alpha = pixels[i2 + 3];
      if (alpha !== 0) {
        const a8 = 255.001 / alpha;
        pixels[i2] = pixels[i2] * a8 + 0.5;
        pixels[i2 + 1] = pixels[i2 + 1] * a8 + 0.5;
        pixels[i2 + 2] = pixels[i2 + 2] * a8 + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: ExtensionType.RendererSystem
};
extensions$1.add(Extract);
const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x2;
    let y2;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x2 = ellipse.x;
      y2 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m2;
    if (m2 === 0) {
      return;
    }
    if (n2 === 0) {
      points.length = 8;
      points[0] = points[6] = x2 + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x2 - dx;
      points[5] = points[7] = y2 - dy;
      return;
    }
    let j1 = 0;
    let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m2;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy) {
        const y22 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
    }
    for (let i2 = 1; i2 < n2; i2++) {
      const a8 = Math.PI / 2 * (i2 / n2);
      const x0 = dx + Math.cos(a8) * rx;
      const y0 = dy + Math.sin(a8) * ry;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x2 + x0;
      const x22 = x2 - x0;
      const y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x2;
    let y2;
    if (graphicsData.type !== SHAPES.RREC) {
      const circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x2 = roundedRect.x + roundedRect.width / 2;
      y2 = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i2 = 2; i2 < points.length; i2 += 2) {
      verts.push(points[i2], points[i2 + 1]);
      indices2.push(vertPos++, center, vertPos);
    }
    indices2.push(center + 1, center, vertPos);
  }
};
function fixOrientation(points, hole = false) {
  const m2 = points.length;
  if (m2 < 6) {
    return;
  }
  let area2 = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    const x2 = points[i2];
    const y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    const n2 = m2 / 2;
    for (let i2 = n2 + n2 % 2; i2 < m2; i2 += 2) {
      const i1 = m2 - i2 - 2;
      const i22 = m2 - i2 - 1;
      const i3 = i2;
      const i4 = i2 + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i22], points[i4]] = [points[i4], points[i22]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i2 = 0; i2 < holes.length; i2++) {
        const hole = holes[i2];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i2 = 0; i2 < triangles.length; i2 += 3) {
        indices2.push(triangles[i2] + vertPos);
        indices2.push(triangles[i2 + 1] + vertPos);
        indices2.push(triangles[i2 + 2] + vertPos);
      }
      for (let i2 = 0; i2 < points.length; i2++) {
        verts.push(points[i2]);
      }
    }
  }
};
const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x2 = rectData.x;
    const y2 = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};
var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    let result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = curves;
class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a12 = fromY - y1;
    const b12 = fromX - x1;
    const a23 = y2 - y1;
    const b22 = x2 - x1;
    const mm = Math.abs(a12 * b22 - b12 * a23);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a12 * a12 + b12 * b12;
    const cc = a23 * a23 + b22 * b22;
    const tt2 = a12 * a23 + b12 * b22;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k22 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt2 / dd;
    const j2 = k22 * tt2 / cc;
    const cx = k1 * b22 + k22 * b12;
    const cy = k1 * a23 + k22 * a12;
    const px = b12 * (k22 + j1);
    const py = a12 * (k22 + j1);
    const qx = b22 * (k1 + j2);
    const qy = a23 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b12 * a23 > b22 * a12
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n2 = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    const theta = sweep / (n2 * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n2 - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i2 = 0; i2 <= segMinus; ++i2) {
      const real = i2 + remainder * i2;
      const angle2 = theta + startAngle + theta2 * real;
      const c3 = Math.cos(angle2);
      const s2 = -Math.sin(angle2);
      points.push((cTheta * c3 + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c3) * radius + cy);
    }
  }
}
class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}
class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n2 = 10;
    let result = 0;
    let t2 = 0;
    let t22 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x2 = 0;
    let y2 = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i2 = 1; i2 <= n2; ++i2) {
      t2 = i2 / n2;
      t22 = t2 * t2;
      t3 = t22 * t2;
      nt = 1 - t2;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
      y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
      dx = prevX - x2;
      dy = prevY - y2;
      prevX = x2;
      prevY = y2;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n2 = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i2 = 1, j2 = 0; i2 <= n2; ++i2) {
      j2 = i2 / n2;
      dt = 1 - j2;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j2 * j2;
      t3 = t2 * j2;
      points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i2 = 1, angle2 = startAngle; i2 < segCount; i2++, angle2 += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle2) * radius, cy + Math.cos(angle2) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i2 = 1, angle2 = startAngle; i2 < segCount; i2++, angle2 += angleInc) {
      verts.push(cx + Math.sin(angle2) * radius, cy + Math.cos(angle2) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i2 = 1; i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c12 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c22 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c22 - dx1 * c12) / cross;
    const py = (dy1 * c12 - dy0 * c22) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join2 = style.join;
    if (join2 === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join2 = LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join2) {
        case LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join2) {
        case LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices2 = graphicsGeometry.indices;
  const eps2 = curves.epsilon * curves.epsilon;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i2, i2 + 1, i2 + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i2 = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices2 = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i2 = 1; i2 < length; i2++) {
    verts.push(points[i2 * 2], points[i2 * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a8 = 4 * (ax * ax + ay * ay);
    const b3 = 4 * (ax * bx + ay * by);
    const c3 = bx * bx + by * by;
    const s2 = 2 * Math.sqrt(a8 + b3 + c3);
    const a23 = Math.sqrt(a8);
    const a32 = 2 * a8 * a23;
    const c22 = 2 * Math.sqrt(c3);
    const ba = b3 / a23;
    return (a32 * s2 + a23 * b3 * (s2 - c22) + (4 * c3 * a8 - b3 * b3) * Math.log((2 * a23 + ba + s2) / (ba + c22))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n2 = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i2 = 1; i2 <= n2; ++i2) {
      const j2 = i2 / n2;
      xa = fromX + (cpX - fromX) * j2;
      ya = fromY + (cpY - fromY) * j2;
      points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);
    }
  }
}
const FILL_COMMANDS = {
  [SHAPES.POLY]: buildPoly,
  [SHAPES.CIRC]: buildCircle,
  [SHAPES.ELIP]: buildCircle,
  [SHAPES.RECT]: buildRectangle,
  [SHAPES.RREC]: buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];
class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}
const tmpPoint = new Point();
const _GraphicsGeometry = class extends BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const batchPart = this.batches[i2];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i2 = 0; i2 < this.graphicsData.length; ++i2) {
      this.graphicsData[i2].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i2 = 0; i2 < graphicsData.length; ++i2) {
      const data = graphicsData[i2];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i22 = 0; i22 < data.holes.length; i22++) {
              const hole = data.holes[i22];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
      this.shapeIndex++;
      const data = graphicsData[i2];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j2 = 0; j2 < 2; j2++) {
        const style = j2 === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index22 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j2 === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size2 = this.points.length / 2 - attribIndex;
        if (size2 === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index22, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index22, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix);
      }
    }
    const index2 = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index2, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
      const data = this.graphicsData[i2];
      const fill2 = data.fillStyle;
      const line = data.lineStyle;
      if (fill2 && !fill2.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i2 = 0, l2 = batches.length; i2 < l2; i2++) {
      const batch = batches[i2];
      for (let j2 = 0; j2 < batch.size; j2++) {
        const index2 = batch.start + j2;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i2 = 0; i2 < batches.length; i2++) {
      if (batches[i2].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++BaseTexture._globalBatch;
    for (let i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = DRAW_MODES.TRIANGLES;
    let index2 = 0;
    this.drawCalls.push(currentGroup);
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      const data = this.batches[i2];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index2;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index2 += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p2 = 0;
    for (let i2 = 0; i2 < verts.length / 2; i2++) {
      f32[p2++] = verts[i2 * 2];
      f32[p2++] = verts[i2 * 2 + 1];
      f32[p2++] = uvs[i2 * 2];
      f32[p2++] = uvs[i2 * 2 + 1];
      u32[p2++] = colors[i2];
      f32[p2++] = textureIds[i2];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      const command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    buildLine(data, this);
    for (let i2 = 0; i2 < data.holes.length; i2++) {
      buildLine(data.holes[i2], this);
    }
  }
  processHoles(holes) {
    for (let i2 = 0; i2 < holes.length; i2++) {
      const hole = holes[i2];
      const command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i2 = 0; i2 < points.length / 2; i2++) {
      const x2 = points[i2 * 2];
      const y2 = points[i2 * 2 + 1];
      points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
      points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size2, offset = 0) {
    const bgr = Color.shared.setValue(color).toLittleEndianNumber();
    const result = Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size2);
    for (let i2 = 0; i2 < size2; i2++) {
      colors[offset + i2] = result;
    }
  }
  addTextureIds(textureIds, id, size2, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size2);
    for (let i2 = 0; i2 < size2; i2++) {
      textureIds[offset + i2] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size2, matrix = null) {
    let index2 = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index2 < size2) {
      let x2 = verts[(start + index2) * 2];
      let y2 = verts[(start + index2) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        x2 = nx;
      }
      index2++;
      uvs.push(x2 / frame.width, y2 / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size2);
    }
  }
  adjustUvs(uvs, texture, start, size2) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size2 * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i2 = start + 2; i2 < finish; i2 += 2) {
      minX = Math.min(minX, Math.floor(uvs[i2] + eps));
      minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i2 = start; i2 < finish; i2 += 2) {
      uvs[i2] = (uvs[i2] + offsetX) * scaleX;
      uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;
class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}
class LineStyle extends FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}
const DEFAULT_SHADERS = {};
const _Graphics = class extends Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new FillStyle();
    this._lineStyle = new LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = State.for2d();
    this._geometry = geometry || new GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new Color(16777215);
    this.blendMode = BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options2 = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options2 === "number") {
      options2 = { width: options2, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options2);
  }
  lineTextureStyle(options2) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: Texture.WHITE,
      color: (options2 == null ? void 0 : options2.texture) ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    };
    options2 = Object.assign(defaultLineStyleOptions, options2);
    this.normalizeColor(options2);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options2.width > 0 && options2.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options2.matrix) {
        options2.matrix = options2.matrix.clone();
        options2.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options2);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x2, y2) {
    this.startPoly();
    this.currentPath.points[0] = x2;
    this.currentPath.points[1] = y2;
    return this;
  }
  lineTo(x2, y2) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  }
  _initCurve(x2 = 0, y2 = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x2, y2];
      }
    } else {
      this.moveTo(x2, y2);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  }
  normalizeColor(options2) {
    const temp = Color.shared.setValue(options2.color ?? 0);
    options2.color = temp.toNumber();
    options2.alpha ?? (options2.alpha = temp.alpha);
  }
  beginTextureFill(options2) {
    const defaultOptions = {
      texture: Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options2 = Object.assign(defaultOptions, options2);
    this.normalizeColor(options2);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options2.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options2.matrix) {
        options2.matrix = options2.matrix.clone();
        options2.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options2);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x2, y2, width, height) {
    return this.drawShape(new Rectangle(x2, y2, width, height));
  }
  drawRoundedRect(x2, y2, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
  }
  drawCircle(x2, y2, radius) {
    return this.drawShape(new Circle(x2, y2, radius));
  }
  drawEllipse(x2, y2, width, height) {
    return this.drawShape(new Ellipse(x2, y2, width, height));
  }
  drawPolygon(...path2) {
    let points;
    let closeStroke = true;
    const poly = path2[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path2[0])) {
      points = path2[0];
    } else {
      points = path2;
    }
    const shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer2) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer2);
    } else {
      renderer2.batch.flush();
      this._renderDirect(renderer2);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i2 = 0; i2 < len; i2++) {
      const gI = geometry.batches[i2];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices: indices2,
        uvs,
        _batchRGB: Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i2] = batch;
    }
  }
  _renderBatched(renderer2) {
    if (!this.batches.length) {
      return;
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
      const batch = this.batches[i2];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer2.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer2) {
    const shader = this._resolveDirectShader(renderer2);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(geometry, shader);
    renderer2.state.set(this.state);
    for (let i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
      this._renderDrawCallDirect(renderer2, geometry.drawCalls[i2]);
    }
  }
  _renderDrawCallDirect(renderer2, drawCall) {
    const { texArray, type, size: size2, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j2 = 0; j2 < groupTextureCount; j2++) {
      renderer2.texture.bind(texArray.elements[j2], j2);
    }
    renderer2.geometry.draw(type, size2, start);
  }
  _resolveDirectShader(renderer2) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer2.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i2 = 0; i2 < maxTextures; i2++) {
          sampleValues[i2] = i2;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer2.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i2 = 0; i2 < this.batches.length; i2++) {
        const batch = this.batches[i2];
        batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i2 = 0; i2 < data.length; i2 += 2) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      vertexData[count++] = a8 * x2 + c3 * y2 + tx;
      vertexData[count++] = d2 * y2 + b3 * x2 + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options2) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options2);
  }
};
let Graphics = _Graphics;
Graphics.curves = curves;
Graphics._TEMP_POINT = new Point();
const graphicsUtils = {
  buildPoly,
  buildCircle,
  buildRectangle,
  buildRoundedRectangle,
  buildLine,
  ArcUtils,
  BezierUtils,
  QuadraticUtils,
  BatchPart,
  FILL_COMMANDS,
  BATCH_POOL,
  DRAW_CALL_POOL
};
class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}
const tempPoint$1 = new Point();
const tempPolygon = new Polygon();
const _Mesh = class extends Container {
  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer2) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer2);
    } else {
      this._renderDefault(renderer2);
    }
  }
  _renderDefault(renderer2) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer2.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer2.shader.bind(shader);
    renderer2.state.set(this.state);
    renderer2.geometry.bind(this.geometry, shader);
    renderer2.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer2) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer2.batch.setObjectRenderer(renderer2.plugins[pluginName]);
    renderer2.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a8 = wt.a;
    const b3 = wt.b;
    const c3 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i2 = 0; i2 < vertexData.length / 2; i2++) {
      const x2 = vertices[i2 * 2];
      const y2 = vertices[i2 * 2 + 1];
      vertexData[i2 * 2] = a8 * x2 + c3 * y2 + tx;
      vertexData[i2 * 2 + 1] = b3 * x2 + d2 * y2 + ty;
    }
    if (this._roundPixels) {
      const resolution = settings.RESOLUTION;
      for (let i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint$1);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices2 = this.geometry.getIndex().data;
    const len = indices2.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i2 = 0; i2 + 2 < len; i2 += step) {
      const ind0 = indices2[i2] * 2;
      const ind1 = indices2[i2 + 1] * 2;
      const ind2 = indices2[i2 + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint$1.x, tempPoint$1.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options2) {
    super.destroy(options2);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;
class MeshGeometry extends Geometry {
  constructor(vertices, uvs, index2) {
    super();
    const verticesBuffer = new Buffer(vertices);
    const uvsBuffer = new Buffer(uvs, true);
    const indexBuffer = new Buffer(index2, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
var fragment$1 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
class MeshMaterial extends Shader {
  constructor(uSampler, options2) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options2 = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options2);
    if (options2.uniforms) {
      Object.assign(uniforms, options2.uniforms);
    }
    super(options2.program || Program.from(vertex$1, fragment$1), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new TextureMatrix(uSampler);
    this.batchable = options2.program === void 0;
    this.pluginName = options2.pluginName;
    this._tintColor = new Color(options2.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options2.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}
class PlaneGeometry extends MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices2 = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i2 = 0; i2 < total; i2++) {
      const x2 = i2 % this.segWidth;
      const y2 = i2 / this.segWidth | 0;
      verts.push(x2 * sizeX, y2 * sizeY);
      uvs.push(x2 / segmentsX, y2 / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i2 = 0; i2 < totalSub; i2++) {
      const xpos = i2 % segmentsX;
      const ypos = i2 / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices2.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices2);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}
class RopeGeometry extends MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices2 = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i2 = 0; i2 < total; i2++) {
      const index2 = i2 * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i2].x;
        const dy = prev.y - points[i2].y;
        const distance2 = Math.sqrt(dx * dx + dy * dy);
        prev = points[i2];
        amount += distance2 / textureWidth;
      } else {
        amount = i2 / (total - 1);
      }
      uvs[index2] = amount;
      uvs[index2 + 1] = 0;
      uvs[index2 + 2] = amount;
      uvs[index2 + 3] = 1;
    }
    let indexCount = 0;
    for (let i2 = 0; i2 < total - 1; i2++) {
      const index2 = i2 * 2;
      indices2[indexCount++] = index2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 2;
      indices2[indexCount++] = index2 + 1;
      indices2[indexCount++] = index2 + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i2 = 0; i2 < total; i2++) {
      const point = points[i2];
      const index2 = i2 * 4;
      if (i2 < points.length - 1) {
        nextPoint = points[i2 + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index2] = point.x + perpX;
      vertices[index2 + 1] = point.y + perpY;
      vertices[index2 + 2] = point.x - perpX;
      vertices[index2 + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}
class SimplePlane extends Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new MeshMaterial(Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer2) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer2);
  }
  destroy(options2) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options2);
  }
}
const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    var _a, _b, _c, _d;
    super(Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? ((_a = texture.defaultBorders) == null ? void 0 : _a.left) ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? ((_b = texture.defaultBorders) == null ? void 0 : _b.right) ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? ((_c = texture.defaultBorders) == null ? void 0 : _c.top) ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? ((_d = texture.defaultBorders) == null ? void 0 : _d.bottom) ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w2 = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w2 ? 1 : this._width / w2;
    const h2 = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h2 ? 1 : this._height / h2;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}
class SimpleMesh extends Mesh {
  constructor(texture = Texture.EMPTY, vertices, uvs, indices2, drawMode) {
    const geometry = new MeshGeometry(vertices, uvs, indices2);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer2) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer2);
  }
}
class SimpleRope extends Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer2) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer2);
  }
}
class ParticleContainer extends Container {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer2.batch.setObjectRenderer(renderer2.plugins.particle);
    renderer2.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i2 = 0; i2 < this._buffers.length; ++i2) {
        this._buffers[i2].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options2) {
    super.destroy(options2);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}
class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size2) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size2;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i2 = 0; i2 < properties.length; ++i2) {
      let property = properties[i2];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i2]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer(this.staticData, true, false);
    for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      const property = this.dynamicProperties[i2];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
      const property = this.staticProperties[i2];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.dynamicProperties.length; i2++) {
      const property = this.dynamicProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i2 = 0; i2 < this.staticProperties.length; i2++) {
      const property = this.staticProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}
var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
class ParticleRenderer extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = Shader.from(vertex, fragment, {});
    this.state = State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer2 = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
    renderer2.state.set(this.state);
    const gl = renderer2.gl;
    const m2 = container.worldTransform.copyTo(this.tempMatrix);
    m2.prepend(renderer2.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m2.toArray(true);
    this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
      let amount = totalChildren - i2;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j2 >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer2 = buffers[j2];
      buffer2.uploadDynamic(children, i2, amount);
      const bid = container._bufferUpdateIDs[j2] || 0;
      updateStatic = updateStatic || buffer2._updateID < bid;
      if (updateStatic) {
        buffer2._updateID = container._updateID;
        buffer2.uploadStatic(children, i2, amount);
      }
      renderer2.geometry.bind(buffer2.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size2 = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i2 = 0; i2 < size2; i2 += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array2, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite2 = children[startIndex + i2];
      const texture = sprite2._texture;
      const sx = sprite2.scale.x;
      const sy = sprite2.scale.y;
      const trim2 = texture.trim;
      const orig = texture.orig;
      if (trim2) {
        w1 = trim2.x - sprite2.anchor.x * orig.width;
        w0 = w1 + trim2.width;
        h1 = trim2.y - sprite2.anchor.y * orig.height;
        h0 = h1 + trim2.height;
      } else {
        w0 = orig.width * (1 - sprite2.anchor.x);
        w1 = orig.width * -sprite2.anchor.x;
        h0 = orig.height * (1 - sprite2.anchor.y);
        h1 = orig.height * -sprite2.anchor.y;
      }
      array2[offset] = w1 * sx;
      array2[offset + 1] = h1 * sy;
      array2[offset + stride] = w0 * sx;
      array2[offset + stride + 1] = h1 * sy;
      array2[offset + stride * 2] = w0 * sx;
      array2[offset + stride * 2 + 1] = h0 * sy;
      array2[offset + stride * 3] = w1 * sx;
      array2[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spritePosition = children[startIndex + i2].position;
      array2[offset] = spritePosition.x;
      array2[offset + 1] = spritePosition.y;
      array2[offset + stride] = spritePosition.x;
      array2[offset + stride + 1] = spritePosition.y;
      array2[offset + stride * 2] = spritePosition.x;
      array2[offset + stride * 2 + 1] = spritePosition.y;
      array2[offset + stride * 3] = spritePosition.x;
      array2[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; i2++) {
      const spriteRotation = children[startIndex + i2].rotation;
      array2[offset] = spriteRotation;
      array2[offset + stride] = spriteRotation;
      array2[offset + stride * 2] = spriteRotation;
      array2[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const textureUvs = children[startIndex + i2]._texture._uvs;
      if (textureUvs) {
        array2[offset] = textureUvs.x0;
        array2[offset + 1] = textureUvs.y0;
        array2[offset + stride] = textureUvs.x1;
        array2[offset + stride + 1] = textureUvs.y1;
        array2[offset + stride * 2] = textureUvs.x2;
        array2[offset + stride * 2 + 1] = textureUvs.y2;
        array2[offset + stride * 3] = textureUvs.x3;
        array2[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array2[offset] = 0;
        array2[offset + 1] = 0;
        array2[offset + stride] = 0;
        array2[offset + stride + 1] = 0;
        array2[offset + stride * 2] = 0;
        array2[offset + stride * 2 + 1] = 0;
        array2[offset + stride * 3] = 0;
        array2[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array2, stride, offset) {
    for (let i2 = 0; i2 < amount; ++i2) {
      const sprite2 = children[startIndex + i2];
      const result = Color.shared.setValue(sprite2._tintRGB).toPremultiplied(sprite2.alpha, sprite2.texture.baseTexture.alphaMode > 0);
      array2[offset] = result;
      array2[offset + stride] = result;
      array2[offset + stride * 2] = result;
      array2[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(ParticleRenderer);
var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});
const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context2 = canvas.getContext("2d", contextSettings);
    context2.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const lineWidth = _TextMetrics._measureText(lines[i2], style.letterSpacing, context2);
      lineWidths[i2] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    let width = context2.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i2 = 0; i2 < tokens.length; i2++) {
      let token = tokens[i2];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j2 = 0; j2 < characters.length; j2++) {
            let char = characters[j2];
            let lastChar = char;
            let k4 = 1;
            while (characters[j2 + k4]) {
              const nextChar = characters[j2 + k4];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k4++;
            }
            j2 += k4 - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i2 === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache, context2) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i2 = text.length - 1; i2 >= 0; i2--) {
      const char = text[i2];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i2 = 0; i2 < text.length; i2++) {
      const char = text[i2];
      const nextChar = text[i2 + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context2 = _TextMetrics._context;
    context2.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context2.measureText(metricsString).width);
    let baseline = Math.ceil(context2.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    const imagedata = context2.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i2 = 0;
    let idx = 0;
    let stop = false;
    for (i2 = 0; i2 < baseline; ++i2) {
      for (let j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i2;
    idx = pixels - line;
    stop = false;
    for (i2 = height; i2 > baseline; --i2) {
      for (let j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i2 - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c3 = new OffscreenCanvas(0, 0);
        const context2 = c3.getContext("2d", contextSettings);
        if (context2 == null ? void 0 : context2.measureText) {
          _TextMetrics.__canvas = c3;
          return c3;
        }
        canvas = settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|ÉqÅ";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
    const segmenter = new Intl.Segmenter();
    return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
  }
  return (s2) => [...s2];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill2) {
    const outputColor = getColor(fill2);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim2) {
    if (this._trim !== trim2) {
      this._trim = trim2;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c3) => temp.setValue(c3).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i2 = 0; i2 < array1.length; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = Texture.from(canvas);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context2 = this.context;
    const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i2 = 0; i2 < passesCount; ++i2) {
      const isShadowPass = style.dropShadow && i2 === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i22 = 0; i22 < lines.length; i22++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i22];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i22], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x2, y2, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (TextMetrics.experimentalLetterSpacingSupported) {
      if (TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x2, y2);
      } else {
        this.context.fillText(text, x2, y2);
      }
      return;
    }
    let currentPosition = x2;
    const stringArray = TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i2 = 0; i2 < stringArray.length; ++i2) {
      const currentChar = stringArray[i2];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y2);
      } else {
        this.context.fillText(currentChar, currentPosition, y2);
      }
      let textStr = "";
      for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer2);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill2 = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill2.length + 1;
      for (let i2 = 1; i2 < lengthPlus1; ++i2) {
        fillGradientStops.push(i2 / lengthPlus1);
      }
    }
    fill2.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill2.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i2;
        let thisLineGradientStart = thisLineTop;
        if (i2 > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i2 + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i2 + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j2 = 0; j2 < fill2.length; j2++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j2] === "number") {
            lineStop = fillGradientStops[j2];
          } else {
            lineStop = j2 / fill2.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill2[j2]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill2.length + 1;
      let currentIteration = 1;
      for (let i2 = 0; i2 < fill2.length; i2++) {
        let stop;
        if (typeof fillGradientStops[i2] === "number") {
          stop = fillGradientStops[i2];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill2[i2]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options2) {
    if (typeof options2 === "boolean") {
      options2 = { children: options2 };
    }
    options2 = Object.assign({}, defaultDestroyOptions, options2);
    super.destroy(options2);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
let Text$1 = _Text;
Text$1.defaultAutoResolution = true;
class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}
function findMultipleBaseTextures(item, queue2) {
  var _a;
  let result = false;
  if ((_a = item == null ? void 0 : item._textures) == null ? void 0 : _a.length) {
    for (let i2 = 0; i2 < item._textures.length; i2++) {
      if (item._textures[i2] instanceof Texture) {
        const baseTexture = item._textures[i2].baseTexture;
        if (!queue2.includes(baseTexture)) {
          queue2.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue2) {
  if (item.baseTexture instanceof BaseTexture) {
    const texture = item.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue2) {
  if (item._texture && item._texture instanceof Texture) {
    const texture = item._texture.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text$1) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    const font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue2) {
  if (item instanceof Text$1) {
    if (!queue2.includes(item.style)) {
      queue2.push(item.style);
    }
    if (!queue2.includes(item)) {
      queue2.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue2.includes(texture)) {
      queue2.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue2) {
  if (item instanceof TextStyle) {
    if (!queue2.includes(item)) {
      queue2.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer2) {
    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer2;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve2) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve2);
        if (!this.ticking) {
          this.ticking = true;
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve2();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
          if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i2 = 0, len = completes.length; i2 < len; i2++) {
        completes[i2]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
      if (this.addHooks[i2](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (let i2 = item.children.length - 1; i2 >= 0; i2--) {
        this.add(item.children[i2]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;
Object.defineProperties(settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.uploadsPerFrame;
    },
    set(value) {
      deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      BasePrepare.uploadsPerFrame = value;
    }
  }
});
function uploadBaseTextures(renderer2, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer2.CONTEXT_UID]) {
      renderer2.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer2, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i2 = 0; i2 < batches.length; i2++) {
    const { texture } = batches[i2].style;
    if (texture) {
      uploadBaseTextures(renderer2, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer2.geometry.bind(geometry, item._resolveDirectShader(renderer2));
  }
  return true;
}
function findGraphics(item, queue2) {
  if (item instanceof Graphics) {
    queue2.push(item);
    return true;
  }
  return false;
}
class Prepare extends BasePrepare {
  constructor(renderer2) {
    super(renderer2);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: ExtensionType.RendererSystem
};
extensions$1.add(Prepare);
class TimeLimiter {
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds;
    this.frameStart = 0;
  }
  beginFrame() {
    this.frameStart = Date.now();
  }
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}
class AnimatedSprite extends Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options2) {
    this.stop();
    super.destroy(options2);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i2 = 0; i2 < frames.length; ++i2) {
      textures.push(Texture.from(frames[i2]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i2 = 0; i2 < images.length; ++i2) {
      textures.push(Texture.from(images[i2]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i2 = 0; i2 < value.length; i2++) {
        this._textures.push(value[i2].texture);
        this._durations.push(value[i2].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}
const tempPoint = new Point();
class TilingSprite extends Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer2) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer2.batch.setObjectRenderer(renderer2.plugins[this.pluginName]);
    renderer2.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options2) {
    super.destroy(options2);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options2) {
    const texture = source instanceof Texture ? source : Texture.from(source, options2);
    return new TilingSprite(texture, options2.width, options2.height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
const tempMat = new Matrix();
class TilingSpriteRenderer extends ObjectRenderer {
  constructor(renderer2) {
    super(renderer2);
    renderer2.runners.contextChange.add(this);
    this.quad = new QuadUv();
    this.state = State.for2d();
  }
  contextChange() {
    const renderer2 = this.renderer;
    const uniforms = { globals: renderer2.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer2.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  }
  render(ts) {
    const renderer2 = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer2.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
          baseTex.wrapMode = WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w2 = tex.width;
    const h2 = tex.height;
    const W2 = ts._width;
    const H2 = ts._height;
    tempMat.set(lt.a * w2 / W2, lt.b * w2 / H2, lt.c * h2 / W2, lt.d * h2 / H2, lt.tx / W2, lt.ty / H2);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer2.shader.bind(shader);
    renderer2.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
    renderer2.state.set(this.state);
    renderer2.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: ExtensionType.RendererPlugin
};
extensions$1.add(TilingSpriteRenderer);
const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve2) => {
      this._callback = resolve2;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i2 = this._frameKeys[frameIndex];
      const data = this._frames[i2];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim2 = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim2 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i2] = new Texture(this.baseTexture, frame, orig, trim2, data.rotated ? 2 : 0, data.anchor, data.borders);
        Texture.addToCache(this.textures[i2], i2);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i2 = 0; i2 < animations[animName].length; i2++) {
        const frameName = animations[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    var _a;
    for (const i2 in this.textures) {
      this.textures[i2].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a = this._texture) == null ? void 0 : _a.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet$1 = _Spritesheet;
Spritesheet$1.BATCH_SIZE = 1e3;
const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys2, asset, ignoreMultiPack) {
  const out = {};
  keys2.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys2[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof Spritesheet$1,
    getCacheableAssets: (keys2, asset) => getCacheableAssets(keys2, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format2 = split.pop();
      return extension === "json" && validImages.includes(format2);
    },
    parse: (value) => {
      var _a;
      const split = value.split(".");
      return {
        resolution: parseFloat(((_a = settings.RETINA_PREFIX.exec(value)) == null ? void 0 : _a[1]) ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    async testParse(asset, options2) {
      return path.extname(options2.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options2, loader) {
      var _a, _b;
      let basePath = path.dirname(options2.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = copySearchParams(imagePath, options2.src);
      const assets = await loader.load([imagePath]);
      const texture = assets[imagePath];
      const spritesheet = new Spritesheet$1(texture.baseTexture, asset, options2.src);
      await spritesheet.parse();
      const multiPacks = (_a = asset == null ? void 0 : asset.meta) == null ? void 0 : _a.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if ((_b = options2.data) == null ? void 0 : _b.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options2.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
extensions$1.add(spritesheetAsset);
class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}
class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i2 in items) {
      const name2 = items[i2].match(/^[a-z]+/gm)[0];
      const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i22 in attributeList) {
        const split = attributeList[i22].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name2].push(itemData);
    }
    const font = new BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}
class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i2 = 0; i2 < info.length; i2++) {
      data.info.push({
        face: info[i2].getAttribute("face"),
        size: parseInt(info[i2].getAttribute("size"), 10)
      });
    }
    for (let i2 = 0; i2 < common.length; i2++) {
      data.common.push({
        lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
      });
    }
    for (let i2 = 0; i2 < page.length; i2++) {
      data.page.push({
        id: parseInt(page[i2].getAttribute("id"), 10) || 0,
        file: page[i2].getAttribute("file")
      });
    }
    for (let i2 = 0; i2 < char.length; i2++) {
      const letter = char[i2];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i2 = 0; i2 < kerning.length; i2++) {
      data.kerning.push({
        first: parseInt(kerning[i2].getAttribute("first"), 10),
        second: parseInt(kerning[i2].getAttribute("second"), 10),
        amount: parseInt(kerning[i2].getAttribute("amount"), 10)
      });
    }
    for (let i2 = 0; i2 < distanceField.length; i2++) {
      data.distanceField.push({
        fieldType: distanceField[i2].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}
class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return XMLFormat.test(settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
  }
}
const formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i2 = 0; i2 < formats.length; i2++) {
    if (formats[i2].test(data)) {
      return formats[i2];
    }
  }
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill2 = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill2.length + 1;
    for (let i2 = 1; i2 < lengthPlus1; ++i2) {
      fillGradientStops.push(i2 / lengthPlus1);
    }
  }
  fill2.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill2.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const thisLineTop = metrics.lineHeight * i2;
      for (let j2 = 0; j2 < fill2.length; j2++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j2] === "number") {
          lineStop = fillGradientStops[j2];
        } else {
          lineStop = j2 / fill2.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill2[j2]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill2.length + 1;
    let currentIteration = 1;
    for (let i2 = 0; i2 < fill2.length; i2++) {
      let stop;
      if (typeof fillGradientStops[i2] === "number") {
        stop = fillGradientStops[i2];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill2[i2]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x2, y2, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context2.translate(x2, y2);
  context2.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function extractCharCode(str2) {
  return str2.codePointAt ? str2.codePointAt(0) : str2.charCodeAt(0);
}
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    var _a;
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i2 = 0; i2 < data.page.length; i2++) {
      const { id, file } = data.page[i2];
      pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file];
      if ((distanceField == null ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
      }
    }
    for (let i2 = 0; i2 < data.char.length; i2++) {
      const { id, page: page2 } = data.char[i2];
      let { x: x2, y: y2, width, height, xoffset, yoffset, xadvance } = data.char[i2];
      x2 /= res;
      y2 /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new Rectangle(x2 + pageTextures[page2].frame.x / res, y2 + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i2 = 0; i2 < data.kerning.length; i2++) {
      let { first, second, amount } = data.kerning[i2];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField == null ? void 0 : distanceField.distanceRange;
    this.distanceFieldType = ((_a = distanceField == null ? void 0 : distanceField.fieldType) == null ? void 0 : _a.toLowerCase()) ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      const format2 = autoDetectFormat(data);
      if (!format2) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format2.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name2) {
    const font = _BitmapFont.available[name2];
    if (!font) {
      throw new Error(`No font found named '${name2}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name2];
  }
  static from(name2, textStyle, options2) {
    if (!name2) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options2);
    const charsList = resolveCharacters(chars);
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context2;
    let baseTexture;
    let maxCharHeight = 0;
    const textures = [];
    for (let i2 = 0; i2 < charsList.length; i2++) {
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context2 = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i2];
      const metrics = TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i2;
        canvas = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i2;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i2 = 0, len = charsList.length; i2 < len; i2++) {
      const first = charsList[i2];
      for (let j2 = 0; j2 < len; j2++) {
        const second = charsList[j2];
        const c12 = context2.measureText(first).width;
        const c22 = context2.measureText(second).width;
        const total = context2.measureText(first + second).width;
        const amount = total - (c12 + c22);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name2] !== void 0) {
      _BitmapFont.uninstall(name2);
    }
    _BitmapFont.available[name2] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    var _a;
    const data = BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new Point();
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = splitTextToCharacters(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i2 = 0; i2 < charsInput.length; i2++) {
      const char = charsInput[i2];
      const charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i2;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
        i2 = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i2 = 0; i2 <= line; i2++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i2];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i2 = 0; i2 < lenChars; i2++) {
      const texture = chars[i2].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES.NORMAL_NPM;
          }
          const mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i2 = 0; i2 < activePagesMeshData.length; i2++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i2])) {
        this.removeChild(activePagesMeshData[i2].mesh);
      }
    }
    for (let i2 = 0; i2 < newPagesMeshData.length; i2++) {
      if (newPagesMeshData[i2].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i2].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2];
      const total = pageMeshData.total;
      if (!(((_a = pageMeshData.indices) == null ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i22 = total2 * 4 * 2; i22 < vertices.length; i22++) {
          vertices[i22] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i2 = 0; i2 < lenChars; i2++) {
      const char = chars[i2];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index2 = pageMesh.index++;
      pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
      pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
      pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
      pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
      pageMesh.vertices[index2 * 8 + 0] = xPos;
      pageMesh.vertices[index2 * 8 + 1] = yPos;
      pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 3] = yPos;
      pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index2 * 8 + 6] = xPos;
      pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i2 in pagesMeshData) {
      const pageMeshData = pagesMeshData[i2];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i22 = 0; i22 < pageMeshData.total; i22++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i2 = 0; i2 < chars.length; i2++) {
      charRenderDataPool.push(chars[i2]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size: size2 } = BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a: a8, b: b3, c: c3, d: d2 } = this.worldTransform;
      const dx = Math.sqrt(a8 * a8 + b3 * b3);
      const dy = Math.sqrt(c3 * c3 + d2 * d2);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size2;
      const resolution = renderer2._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer2);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
      this._activePagesMeshData[i2].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options2) {
    const { _textureCache } = this;
    const data = BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options2);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};
const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url2) {
    return validExtensions.includes(path.extname(url2).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.test(data) || XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i2 = 0; i2 < pages.length; ++i2) {
      const pageFile = pages[i2].file;
      let imagePath = path.join(path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url2) => loadedTextures[url2]);
    return BitmapFont.install(fontData, textures, true);
  },
  async load(url2, _options) {
    const response = await settings.ADAPTER.fetch(url2);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions$1.add(loadBitmapFont);
const _HTMLTextStyle = class extends TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url2, options2 = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url2]) {
      const font = availableFonts[url2];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return settings.ADAPTER.fetch(url2).then((response) => response.blob()).then(async (blob) => new Promise((resolve2, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve2([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: path.basename(url2, path.extname(url2)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url2,
        fontFace: null
      }, options2);
      availableFonts[url2] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v2) => !this._overrides.includes(v2));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v2) => this._overrides.includes(v2));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v2) => !toRemove.includes(v2));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = rgb2hex(color);
    }
    if (typeof color === "number") {
      return hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x2 = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y2 = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x2}px ${y2}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};
const _HTMLText = class extends Sprite {
  constructor(text = "", style = {}) {
    super(Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = Texture.from(image, {
      scaleMode: settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    var _a, _b;
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: (_a = this._style) == null ? void 0 : _a.toCSS(resolution) });
      this._styleElement.textContent = (_b = this._style) == null ? void 0 : _b.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve2) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve2();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer2);
  }
  _renderCanvas(renderer2) {
    if (this._autoResolution && this._resolution !== renderer2.resolution) {
      this._resolution = renderer2.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer2);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options2) {
    var _a, _b, _c, _d, _e;
    if (typeof options2 === "boolean") {
      options2 = { children: options2 };
    }
    options2 = Object.assign({}, _HTMLText.defaultDestroyOptions, options2);
    super.destroy(options2);
    const forceClear = null;
    if (this.ownsStyle) {
      (_a = this._style) == null ? void 0 : _a.cleanFonts();
    }
    this._style = forceClear;
    (_b = this._svgRoot) == null ? void 0 : _b.remove();
    this._svgRoot = forceClear;
    (_c = this._domElement) == null ? void 0 : _c.remove();
    this._domElement = forceClear;
    (_d = this._foreignObject) == null ? void 0 : _d.remove();
    this._foreignObject = forceClear;
    (_e = this._styleElement) == null ? void 0 : _e.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s2 = sign(this.scale.x) || 1;
    this.scale.x = s2 * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s2 = sign(this.scale.y) || 1;
    this.scale.y = s2 * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;
const PIXI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ALPHA_MODES,
  AbstractMultiResource,
  AccessibilityManager,
  AlphaFilter,
  AnimatedSprite,
  Application,
  ArrayResource,
  Assets,
  AssetsClass,
  Attribute,
  BLEND_MODES,
  BUFFER_BITS,
  BUFFER_TYPE,
  BackgroundSystem,
  BaseImageResource,
  BasePrepare,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  BitmapFont,
  BitmapFontData,
  BitmapText,
  BlobResource,
  BlurFilter,
  BlurFilterPass,
  Bounds,
  BrowserAdapter,
  Buffer,
  BufferResource,
  BufferSystem,
  CLEAR_MODES,
  COLOR_MASK_BITS,
  Cache,
  CanvasResource,
  Circle,
  Color,
  ColorMatrixFilter,
  CompressedTextureResource,
  Container,
  ContextSystem,
  CountLimiter,
  CubeResource,
  DEG_TO_RAD,
  DRAW_MODES,
  DisplacementFilter,
  DisplayObject,
  ENV,
  Ellipse,
  EventBoundary,
  EventSystem,
  ExtensionType,
  Extract,
  FORMATS,
  FORMATS_TO_COMPONENTS,
  FXAAFilter,
  FederatedDisplayObject,
  FederatedEvent,
  FederatedMouseEvent,
  FederatedPointerEvent,
  FederatedWheelEvent,
  FillStyle,
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  GC_MODES,
  GLFramebuffer,
  GLProgram,
  GLTexture,
  GRAPHICS_CURVES,
  GenerateTextureSystem,
  Geometry,
  GeometrySystem,
  Graphics,
  GraphicsData,
  GraphicsGeometry,
  HTMLText,
  HTMLTextStyle,
  IGLUniformData,
  INSTALLED,
  INTERNAL_FORMATS,
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  ImageBitmapResource,
  ImageResource,
  LINE_CAP,
  LINE_JOIN,
  LineStyle,
  LoaderParserPriority,
  MASK_TYPES,
  MIPMAP_MODES,
  MSAA_QUALITY,
  MaskData,
  MaskSystem,
  Matrix,
  Mesh,
  MeshBatchUvs,
  MeshGeometry,
  MeshMaterial,
  MultisampleSystem,
  NineSlicePlane,
  NoiseFilter,
  ObjectRenderer,
  ObjectRendererSystem,
  ObservablePoint,
  PI_2,
  PRECISION,
  ParticleContainer,
  ParticleRenderer,
  PlaneGeometry,
  PluginSystem: PluginSystem2,
  Point,
  Polygon,
  Prepare,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RAD_TO_DEG,
  RENDERER_TYPE,
  Rectangle,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  ResizePlugin,
  Resource,
  RopeGeometry,
  RoundedRectangle,
  Runner,
  SAMPLER_TYPES,
  SCALE_MODES,
  SHAPES,
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SimpleMesh,
  SimplePlane,
  SimpleRope,
  Sprite,
  SpriteMaskFilter,
  Spritesheet: Spritesheet$1,
  StartupSystem,
  State,
  StateSystem,
  StencilSystem,
  SystemManager,
  TARGETS,
  TEXT_GRADIENT,
  TYPES,
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  TemporaryDisplayObject,
  Text: Text$1,
  TextFormat,
  TextMetrics,
  TextStyle,
  Texture,
  TextureGCSystem,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  Ticker,
  TickerPlugin,
  TilingSprite,
  TilingSpriteRenderer,
  TimeLimiter,
  Transform,
  TransformFeedback,
  TransformFeedbackSystem,
  UPDATE_PRIORITY,
  UniformGroup,
  VERSION,
  VideoResource,
  ViewSystem,
  ViewableBuffer,
  WRAP_MODES,
  XMLFormat,
  XMLStringFormat,
  accessibleTarget,
  autoDetectFormat,
  autoDetectRenderer,
  autoDetectResource,
  cacheTextureArray,
  checkDataUrl,
  checkExtension,
  checkMaxIfStatementsInShader,
  convertToList,
  copySearchParams,
  createStringVariations,
  createTexture,
  createUBOElements,
  curves,
  defaultFilterVertex,
  defaultVertex,
  detectAvif,
  detectCompressedTextures,
  detectDefaults,
  detectWebp,
  extensions: extensions$1,
  filters,
  generateProgram,
  generateUniformBufferSync,
  getFontFamilyName,
  getTestContext,
  getUBOData,
  graphicsUtils,
  groupD8,
  isMobile,
  isSingleItem,
  loadBitmapFont,
  loadDDS,
  loadImageBitmap,
  loadJson,
  loadKTX,
  loadSVG,
  loadTextures,
  loadTxt,
  loadWebFont,
  parseDDS,
  parseKTX,
  resolveCompressedTextureUrl,
  resolveTextureUrl,
  settings,
  spritesheetAsset,
  uniformParsers,
  unsafeEvalSupported,
  utils: index
}, Symbol.toStringTag, { value: "Module" }));
class CommonLayer extends Container {
  constructor(layer, map2) {
    super();
    this.layer = layer;
    this.map = map2;
    this.applyProperties();
  }
  applyProperties() {
    this.alpha = this.layer.opacity ?? 1;
    this.visible = this.layer.visible ?? true;
    this.x = this.layer.offsetx ?? 0;
    this.y = this.layer.offsety ?? 0;
    this.z = this.layer.properties.z ?? 0;
  }
}
class ImageLayer extends CommonLayer {
  applyProperties() {
    super.applyProperties();
    const engine = this.map["renderer"]["clientEngine"];
    if (this.layer.image && this.layer.image.source && engine) {
      const {
        width,
        height,
        source
      } = this.layer.image;
      const data = this.map.getData();
      const texture = Texture.from(engine.getResourceUrl(source));
      const tilingSprite = new TilingSprite(texture, this.layer.repeatx ? data.width * data.tilewidth : width, this.layer.repeaty ? data.height * data.tileheight : height);
      this.addChild(tilingSprite);
    }
  }
}
class Tile2 extends AnimatedSprite {
  static getTextures(tile, tileSet) {
    const textures = [];
    if (tile.animations && tile.animations.length) {
      tile.animations.forEach((frame) => {
        textures.push(tileSet.textures[frame.tileid].clone());
      });
    } else {
      textures.push(tileSet.textures[tile.gid - tileSet.firstgid].clone());
    }
    return textures;
  }
  constructor(tile, tileSet) {
    super(Tile2.getTextures(tile, tileSet));
    this.tile = tile;
    this.tileSet = tileSet;
    this.animations = [];
    this._x = 0;
    this._y = 0;
    this.properties = {};
    this.animations = tile.animations || [];
    this.properties = tile.properties;
    this.textures = Tile2.getTextures(tile, tileSet);
    this.texture = this.textures[0];
    this.flip();
  }
  get gid() {
    return this.tile.gid;
  }
  setAnimation(frame) {
    const size2 = this.animations.length;
    if (size2 > 1) {
      const offset = (this.animations[1].tileid - this.animations[0].tileid) * this.width;
      frame.tileAnimX(offset, size2);
    }
  }
  flip() {
    let symmetry;
    let i2 = 0;
    const add2 = (symmetrySecond) => {
      i2++;
      if (symmetry)
        symmetry = groupD8.add(symmetry, symmetrySecond);
      else
        symmetry = symmetrySecond;
    };
    if (this.tile.horizontalFlip) {
      add2(groupD8.MIRROR_HORIZONTAL);
    }
    if (this.tile.verticalFlip) {
      add2(groupD8.MIRROR_VERTICAL);
    }
    if (this.tile.diagonalFlip) {
      if (i2 % 2 == 0) {
        add2(groupD8.MAIN_DIAGONAL);
      } else {
        add2(groupD8.REVERSE_DIAGONAL);
      }
    }
    if (symmetry)
      this.texture.rotate = symmetry;
  }
}
let B$1 = class B {
  /** @param renderer */
  constructor(t2) {
    this.tileAnim = [0, 0], this.dontUseTransform = false, this.renderer = t2, this.tileAnim = [0, 0];
  }
  static registerExtension() {
    extensions$1.add({
      name: "tilemap",
      type: ExtensionType.CanvasRendererPlugin,
      ref: B
    });
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static getInstance(t2) {
    if (!t2.plugins.tilemap)
      throw new Error("Extension not registered!");
    return t2.plugins.tilemap;
  }
};
const m$1 = {
  /** The default number of textures per tilemap in a tilemap composite. */
  TEXTURES_PER_TILEMAP: 16,
  /**
   * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.
   *
   * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly
   * upload the textures togther in a tiled fashion.
   */
  TEXTILE_DIMEN: 1024,
  /**
   * The number of texture tiles per {@link TextileResource}.
   *
   * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a
   * higher value, textures will be uploaded together in a tiled fashion.
   *
   * Since {@link TextileResource} is a dual-column format, this should be even for packing
   * efficiency. The optimal value is usually 4.
   */
  TEXTILE_UNITS: 1,
  /** The scaling mode of the combined texture tiling. */
  TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,
  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */
  use32bitIndex: false,
  /** Flags whether textiles should be cleared when each tile is uploaded. */
  DO_CLEAR: true,
  // Backward compatibility
  get maxTextures() {
    return this.MAX_TEXTURES;
  },
  set maxTextures(o2) {
    this.MAX_TEXTURES = o2;
  },
  get boundSize() {
    return this.TEXTURE_TILE_DIMEN;
  },
  set boundSize(o2) {
    this.TILE_TEXTURE_DIMEN = o2;
  },
  get boundCountPerBuffer() {
    return this.TEXTILE_UNITS;
  },
  set boundCountPerBuffer(o2) {
    this.TEXTILE_UNITS = o2;
  }
};
var it = /* @__PURE__ */ ((o2) => (o2[o2.U = 0] = "U", o2[o2.V = 1] = "V", o2[o2.X = 2] = "X", o2[o2.Y = 3] = "Y", o2[o2.TILE_WIDTH = 4] = "TILE_WIDTH", o2[o2.TILE_HEIGHT = 5] = "TILE_HEIGHT", o2[o2.ROTATE = 6] = "ROTATE", o2[o2.ANIM_X = 7] = "ANIM_X", o2[o2.ANIM_Y = 8] = "ANIM_Y", o2[o2.TEXTURE_INDEX = 9] = "TEXTURE_INDEX", o2[o2.ANIM_COUNT_X = 10] = "ANIM_COUNT_X", o2[o2.ANIM_COUNT_Y = 11] = "ANIM_COUNT_Y", o2[o2.ANIM_DIVISOR = 12] = "ANIM_DIVISOR", o2[o2.ALPHA = 13] = "ALPHA", o2))(it || {});
const L$1 = Object.keys(it).length / 2;
let k$2 = class k extends Container {
  /**
   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The
   *      base-textures in this array must not be duplicated.
   */
  constructor(t2) {
    super(), this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.tileAnim = null, this.modificationMarker = 0, this.offsetX = 0, this.offsetY = 0, this.compositeParent = false, this.tilemapBounds = new Bounds(), this.hasAnimatedTile = false, this.pointsBuf = [], this.renderCanvas = (e3) => {
      const i2 = B$1.getInstance(e3);
      if (i2 && !i2.dontUseTransform) {
        const s2 = this.worldTransform;
        e3.canvasContext.activeContext.setTransform(
          s2.a,
          s2.b,
          s2.c,
          s2.d,
          s2.tx * e3.resolution,
          s2.ty * e3.resolution
        );
      }
      this.renderCanvasCore(e3);
    }, this.vbId = 0, this.vb = null, this.vbBuffer = null, this.vbArray = null, this.vbInts = null, this.setTileset(t2);
  }
  /**
   * @returns The tileset of this tilemap.
   */
  getTileset() {
    return this.tileset;
  }
  /**
   * Define the tileset used by the tilemap.
   *
   * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will
   *  be wrapped into an array. This should not contain any duplicates.
   */
  setTileset(t2 = []) {
    Array.isArray(t2) || (t2 = [t2]);
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3].baseTexture && (t2[e3] = t2[e3].baseTexture);
    return this.tileset = t2, this;
  }
  /**  Clears all the tiles added into this tilemap. */
  clear() {
    return this.pointsBuf.length = 0, this.modificationMarker = 0, this.tilemapBounds.clear(), this.hasAnimatedTile = false, this;
  }
  /**
   * Adds a tile that paints the given texture at (x, y).
   *
   * @param tileTexture - The tiling texture to render.
   * @param x - The local x-coordinate of the tile's position.
   * @param y - The local y-coordinate of the tile's position.
   * @param options - Additional tile options.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t2, e3, i2, s2 = {}) {
    let a8, u2 = -1;
    if (typeof t2 == "number")
      u2 = t2, a8 = this.tileset[u2];
    else {
      let b3;
      typeof t2 == "string" ? b3 = Texture.from(t2) : b3 = t2;
      const X2 = this.tileset;
      for (let v2 = 0; v2 < X2.length; v2++)
        if (X2[v2] === b3.castToBaseTexture()) {
          u2 = v2;
          break;
        }
      "baseTexture" in b3 && (s2.u = s2.u ?? b3.frame.x, s2.v = s2.v ?? b3.frame.y, s2.tileWidth = s2.tileWidth ?? b3.orig.width, s2.tileHeight = s2.tileHeight ?? b3.orig.height), a8 = b3.castToBaseTexture();
    }
    if (!a8 || u2 < 0)
      return console.error("The tile texture was not found in the tilemap tileset."), this;
    const {
      u: l2 = 0,
      v: h2 = 0,
      tileWidth: d2 = a8.realWidth,
      tileHeight: f3 = a8.realHeight,
      animX: p2 = 0,
      animY: r2 = 0,
      rotate: n2 = 0,
      animCountX: A2 = 1024,
      animCountY: w2 = 1024,
      animDivisor: C2 = 1,
      alpha: c3 = 1
    } = s2, E2 = this.pointsBuf;
    return this.hasAnimatedTile = this.hasAnimatedTile || p2 > 0 || r2 > 0, E2.push(l2), E2.push(h2), E2.push(e3), E2.push(i2), E2.push(d2), E2.push(f3), E2.push(n2), E2.push(p2 | 0), E2.push(r2 | 0), E2.push(u2), E2.push(A2), E2.push(w2), E2.push(C2), E2.push(c3), this.tilemapBounds.addFramePad(e3, i2, e3 + d2, i2 + f3, 0, 0), this;
  }
  /** Changes the rotation of the last tile. */
  tileRotate(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 9)] = t2;
  }
  /** Changes the `animX`, `animCountX` of the last tile. */
  tileAnimX(t2, e3) {
    const i2 = this.pointsBuf;
    i2[i2.length - (L$1 - 7)] = t2, i2[i2.length - (L$1 - 10)] = e3;
  }
  /** Changes the `animY`, `animCountY` of the last tile. */
  tileAnimY(t2, e3) {
    const i2 = this.pointsBuf;
    i2[i2.length - (L$1 - 8)] = t2, i2[i2.length - (L$1 - 11)] = e3;
  }
  /** Changes the `animDivisor` value of the last tile. */
  tileAnimDivisor(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 12)] = t2;
  }
  tileAlpha(t2) {
    const e3 = this.pointsBuf;
    e3[e3.length - (L$1 - 13)] = t2;
  }
  renderCanvasCore(t2) {
    if (this.tileset.length === 0)
      return;
    const e3 = this.pointsBuf, i2 = this.tileAnim || t2.plugins.tilemap && t2.plugins.tilemap.tileAnim;
    t2.canvasContext.activeContext.fillStyle = "#000000";
    for (let s2 = 0, a8 = e3.length; s2 < a8; s2 += L$1) {
      let u2 = e3[
        s2 + 0
        /* U */
      ], l2 = e3[
        s2 + 1
        /* V */
      ];
      const h2 = e3[
        s2 + 2
        /* X */
      ], d2 = e3[
        s2 + 3
        /* Y */
      ], f3 = e3[
        s2 + 4
        /* TILE_WIDTH */
      ], p2 = e3[
        s2 + 5
        /* TILE_HEIGHT */
      ];
      u2 += e3[
        s2 + 7
        /* ANIM_X */
      ] * i2[0], l2 += e3[
        s2 + 8
        /* ANIM_Y */
      ] * i2[1];
      const r2 = e3[
        s2 + 9
        /* TEXTURE_INDEX */
      ], n2 = e3[
        s2 + 13
        /* ALPHA */
      ];
      r2 >= 0 && this.tileset[r2] ? (t2.canvasContext.activeContext.globalAlpha = n2, t2.canvasContext.activeContext.drawImage(
        this.tileset[r2].getDrawableSource(),
        u2,
        l2,
        f3,
        p2,
        h2,
        d2,
        f3,
        p2
      )) : (t2.canvasContext.activeContext.globalAlpha = 0.5, t2.canvasContext.activeContext.fillRect(h2, d2, f3, p2)), t2.canvasContext.activeContext.globalAlpha = 1;
    }
  }
  destroyVb() {
    this.vb && (this.vb.destroy(), this.vb = null);
  }
  render(t2) {
    const e3 = t2.plugins.tilemap, i2 = e3.getShader();
    t2.batch.setObjectRenderer(e3), this._globalMat = i2.uniforms.projTransMatrix, t2.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i2.uniforms.shadowColor = this.shadowColor, i2.uniforms.animationFrame = this.tileAnim || e3.tileAnim, this.renderWebGLCore(t2, e3);
  }
  renderWebGLCore(t2, e3) {
    const i2 = this.pointsBuf;
    if (i2.length === 0)
      return;
    const s2 = i2.length / L$1, a8 = e3.getShader(), u2 = this.tileset;
    if (u2.length === 0)
      return;
    e3.bindTileTextures(t2, u2), t2.shader.bind(a8, false);
    let l2 = this.vb;
    l2 || (l2 = e3.createVb(), this.vb = l2, this.vbId = l2.id, this.vbBuffer = null, this.modificationMarker = 0), e3.checkIndexBuffer(s2, l2);
    const d2 = l2.getBuffer("aVertexPosition"), f3 = s2 * l2.vertPerQuad;
    if (f3 !== 0) {
      if (this.modificationMarker !== f3) {
        this.modificationMarker = f3;
        const p2 = l2.stride * f3;
        if (!this.vbBuffer || this.vbBuffer.byteLength < p2) {
          let c3 = l2.stride;
          for (; c3 < p2; )
            c3 *= 2;
          this.vbBuffer = new ArrayBuffer(c3), this.vbArray = new Float32Array(this.vbBuffer), this.vbInts = new Uint32Array(this.vbBuffer), d2.update(this.vbBuffer);
        }
        const r2 = this.vbArray;
        let n2 = 0, A2 = 0, w2 = this.offsetX, C2 = this.offsetY;
        for (let c3 = 0; c3 < i2.length; c3 += L$1) {
          if (this.compositeParent) {
            const M2 = i2[
              c3 + 9
              /* TEXTURE_INDEX */
            ];
            A2 = M2, w2 = 0, C2 = 0;
          }
          const b3 = i2[
            c3 + 2
            /* X */
          ], X2 = i2[
            c3 + 3
            /* Y */
          ], v2 = i2[
            c3 + 4
            /* TILE_WIDTH */
          ], y2 = i2[
            c3 + 5
            /* TILE_HEIGHT */
          ], g2 = i2[
            c3 + 0
            /* U */
          ] + w2, x2 = i2[
            c3 + 1
            /* V */
          ] + C2;
          let T2 = i2[
            c3 + 6
            /* ROTATE */
          ];
          const rt = i2[
            c3 + 7
            /* ANIM_X */
          ], nt = i2[
            c3 + 8
            /* ANIM_Y */
          ], at = i2[
            c3 + 10
            /* ANIM_COUNT_X */
          ] || 1024, ot = i2[
            c3 + 11
            /* ANIM_COUNT_Y */
          ] || 1024, D2 = rt + at * 2048, S2 = nt + ot * 2048, F2 = i2[
            c3 + 12
            /* ANIM_DIVISOR */
          ], Y2 = i2[
            c3 + 13
            /* ALPHA */
          ];
          let P, H2, U2, W2, V2, j2, G2, z2;
          if (T2 === 0)
            P = g2, H2 = x2, U2 = g2 + v2, W2 = x2, V2 = g2 + v2, j2 = x2 + y2, G2 = g2, z2 = x2 + y2;
          else {
            let M2 = v2 / 2, _2 = y2 / 2;
            T2 % 4 !== 0 && (M2 = y2 / 2, _2 = v2 / 2);
            const N2 = g2 + M2, R2 = x2 + _2;
            T2 = groupD8.add(T2, groupD8.NW), P = N2 + M2 * groupD8.uX(T2), H2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), U2 = N2 + M2 * groupD8.uX(T2), W2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), V2 = N2 + M2 * groupD8.uX(T2), j2 = R2 + _2 * groupD8.uY(T2), T2 = groupD8.add(T2, 2), G2 = N2 + M2 * groupD8.uX(T2), z2 = R2 + _2 * groupD8.uY(T2);
          }
          r2[n2++] = b3, r2[n2++] = X2, r2[n2++] = P, r2[n2++] = H2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3 + v2, r2[n2++] = X2, r2[n2++] = U2, r2[n2++] = W2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3 + v2, r2[n2++] = X2 + y2, r2[n2++] = V2, r2[n2++] = j2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2, r2[n2++] = b3, r2[n2++] = X2 + y2, r2[n2++] = G2, r2[n2++] = z2, r2[n2++] = g2 + 0.5, r2[n2++] = x2 + 0.5, r2[n2++] = g2 + v2 - 0.5, r2[n2++] = x2 + y2 - 0.5, r2[n2++] = D2, r2[n2++] = S2, r2[n2++] = A2, r2[n2++] = F2, r2[n2++] = Y2;
        }
        d2.update(r2);
      }
      t2.geometry.bind(l2, a8), t2.geometry.draw(DRAW_MODES.TRIANGLES, s2 * 6, 0);
    }
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t2) {
    return !!(this.modificationMarker !== this.pointsBuf.length || t2 && this.hasAnimatedTile);
  }
  /**
   * This will pull forward the modification marker.
   *
   * @internal
   * @ignore
   */
  clearModify() {
    this.modificationMarker = this.pointsBuf.length;
  }
  /** @override */
  _calculateBounds() {
    const { minX: t2, minY: e3, maxX: i2, maxY: s2 } = this.tilemapBounds;
    this._bounds.addFrame(this.transform, t2, e3, i2, s2);
  }
  /** @override */
  getLocalBounds(t2) {
    return this.children.length === 0 ? this.tilemapBounds.getRectangle(t2) : super.getLocalBounds.call(this, t2);
  }
  /** @override */
  destroy(t2) {
    super.destroy(t2), this.destroyVb();
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  addFrame(t2, e3, i2, s2, a8) {
    return this.tile(
      t2,
      e3,
      i2,
      {
        animX: s2,
        animY: a8
      }
    ), true;
  }
  /**
   * Deprecated signature for {@link Tilemap.tile tile}.
   *
   * @deprecated Since @pixi/tilemap 3.
   */
  // eslint-disable-next-line max-params
  addRect(t2, e3, i2, s2, a8, u2, l2, h2 = 0, d2 = 0, f3 = 0, p2 = 1024, r2 = 1024, n2 = 1, A2 = 1) {
    return this.tile(
      t2,
      s2,
      a8,
      {
        u: e3,
        v: i2,
        tileWidth: u2,
        tileHeight: l2,
        animX: h2,
        animY: d2,
        rotate: f3,
        animCountX: p2,
        animCountY: r2,
        animDivisor: n2,
        alpha: A2
      }
    );
  }
};
let Z$1 = class Z extends Container {
  /**
   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered
   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}
   *  will work equivalently.
   */
  constructor(t2) {
    super(), this.tileAnim = null, this.lastModifiedTilemap = null, this.modificationMarker = 0, this.shadowColor = new Float32Array([0, 0, 0, 0.5]), this._globalMat = null, this.setBitmaps = this.tileset, this.tileset(t2), this.texturesPerTilemap = m$1.TEXTURES_PER_TILEMAP;
  }
  /**
   * This will preinitialize the tilesets of the layered tilemaps.
   *
   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the
   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.
   *
   * @param tileTextures - The list of tile textures that make up the tileset.
   */
  tileset(t2) {
    t2 || (t2 = []);
    const e3 = this.texturesPerTilemap, i2 = this.children.length, s2 = Math.ceil(t2.length / e3);
    for (let a8 = 0; a8 < Math.min(i2, s2); a8++)
      this.children[a8].setTileset(
        t2.slice(a8 * e3, (a8 + 1) * e3)
      );
    for (let a8 = i2; a8 < s2; a8++) {
      const u2 = new k$2(t2.slice(a8 * e3, (a8 + 1) * e3));
      u2.compositeParent = true, u2.offsetX = m$1.TEXTILE_DIMEN, u2.offsetY = m$1.TEXTILE_DIMEN, this.addChild(u2);
    }
    return this;
  }
  /** Clears the tilemap composite. */
  clear() {
    for (let t2 = 0; t2 < this.children.length; t2++)
      this.children[t2].clear();
    return this.modificationMarker = 0, this;
  }
  /** Changes the rotation of the last added tile. */
  tileRotate(t2) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileRotate(t2), this;
  }
  /** Changes `animX`, `animCountX` of the last added tile. */
  tileAnimX(t2, e3) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimX(t2, e3), this;
  }
  /** Changes `animY`, `animCountY` of the last added tile. */
  tileAnimY(t2, e3) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimY(t2, e3), this;
  }
  /** Changes `tileAnimDivisor` value of the last added tile. */
  tileAnimDivisor(t2) {
    return this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimDivisor(t2), this;
  }
  /**
   * Adds a tile that paints the given tile texture at (x, y).
   *
   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.
   * @param x - The local x-coordinate of the tile's location.
   * @param y - The local y-coordinate of the tile's location.
   * @param options - Additional options to pass to {@link Tilemap.tile}.
   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.
   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.
   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.
   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.
   * @param [options.animX=0] - For animated tiles, this is the "offset" along the x-axis for adjacent
   *      animation frame textures in the base-texture.
   * @param [options.animY=0] - For animated tiles, this is the "offset" along the y-axis for adjacent
   *      animation frames textures in the base-texture.
   * @param [options.rotate=0]
   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures
   *      per row.
   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures
   *      per column.
   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame
   * @param [options.alpha=1] - Tile alpha
   * @return This tilemap, good for chaining.
   */
  tile(t2, e3, i2, s2 = {}) {
    let a8 = null;
    const u2 = this.children;
    if (this.lastModifiedTilemap = null, typeof t2 == "number") {
      const l2 = t2 / this.texturesPerTilemap >> 0;
      let h2 = 0;
      if (a8 = u2[l2], a8)
        h2 = t2 % this.texturesPerTilemap;
      else {
        if (a8 = u2[0], !a8)
          return this;
        h2 = 0;
      }
      a8.tile(
        h2,
        e3,
        i2,
        s2
      );
    } else {
      typeof t2 == "string" && (t2 = Texture.from(t2));
      for (let l2 = 0; l2 < u2.length; l2++) {
        const h2 = u2[l2], d2 = h2.getTileset();
        for (let f3 = 0; f3 < d2.length; f3++)
          if (d2[f3] === t2.baseTexture) {
            a8 = h2;
            break;
          }
        if (a8)
          break;
      }
      if (!a8) {
        for (let l2 = u2.length - 1; l2 >= 0; l2--) {
          const h2 = u2[l2];
          if (h2.getTileset().length < this.texturesPerTilemap) {
            a8 = h2, h2.getTileset().push(t2.baseTexture);
            break;
          }
        }
        a8 || (a8 = new k$2(t2.baseTexture), a8.compositeParent = true, a8.offsetX = m$1.TEXTILE_DIMEN, a8.offsetY = m$1.TEXTILE_DIMEN, this.addChild(a8));
      }
      a8.tile(
        t2,
        e3,
        i2,
        s2
      );
    }
    return this.lastModifiedTilemap = a8, this;
  }
  renderCanvas(t2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e3 = B$1.getInstance(t2);
    if (e3 && !e3.dontUseTransform) {
      const s2 = this.worldTransform;
      t2.canvasContext.activeContext.setTransform(
        s2.a,
        s2.b,
        s2.c,
        s2.d,
        s2.tx * t2.resolution,
        s2.ty * t2.resolution
      );
    }
    const i2 = this.children;
    for (let s2 = 0; s2 < i2.length; s2++) {
      const a8 = i2[s2];
      a8.tileAnim = this.tileAnim, a8.renderCanvasCore(t2);
    }
  }
  render(t2) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
      return;
    const e3 = t2.plugins.tilemap, i2 = e3.getShader();
    t2.batch.setObjectRenderer(e3), this._globalMat = i2.uniforms.projTransMatrix, t2.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform), i2.uniforms.shadowColor = this.shadowColor, i2.uniforms.animationFrame = this.tileAnim || e3.tileAnim, t2.shader.bind(i2, false);
    const s2 = this.children;
    for (let a8 = 0; a8 < s2.length; a8++)
      s2[a8].renderWebGLCore(t2, e3);
  }
  /**
   * @internal
   * @ignore
   */
  isModified(t2) {
    const e3 = this.children;
    if (this.modificationMarker !== e3.length)
      return true;
    for (let i2 = 0; i2 < e3.length; i2++)
      if (e3[i2].isModified(t2))
        return true;
    return false;
  }
  /**
   * @internal
   * @ignore
   */
  clearModify() {
    const t2 = this.children;
    this.modificationMarker = t2.length;
    for (let e3 = 0; e3 < t2.length; e3++)
      t2[e3].clearModify();
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @see CompositeTilemap.tile
   */
  addFrame(t2, e3, i2, s2, a8, u2, l2, h2, d2) {
    return this.tile(
      t2,
      e3,
      i2,
      {
        animX: s2,
        animY: a8,
        animCountX: u2,
        animCountY: l2,
        animDivisor: h2,
        alpha: d2
      }
    );
  }
  /**
   * @deprecated @pixi/tilemap 3
   * @see CompositeTilemap.tile
   */
  // eslint-disable-next-line max-params
  addRect(t2, e3, i2, s2, a8, u2, l2, h2, d2, f3, p2, r2) {
    const n2 = t2 / this.texturesPerTilemap >> 0, A2 = t2 % this.texturesPerTilemap;
    return this.children[n2] && this.children[n2].getTileset() ? (this.lastModifiedTilemap = this.children[n2], this.lastModifiedTilemap.addRect(
      A2,
      e3,
      i2,
      s2,
      a8,
      u2,
      l2,
      h2,
      d2,
      f3,
      p2,
      r2
    )) : this.lastModifiedTilemap = null, this;
  }
  /**
   * @deprecated Since @pixi/tilemap 3.
   * @readonly
   * @see CompositeTilemap.texturesPerTilemap
   */
  get texPerChild() {
    return this.texturesPerTilemap;
  }
};
function It(o2) {
  let t2 = "";
  t2 += `
`, t2 += `
`, t2 += "if(vTextureId <= -1.0) {", t2 += `
	color = shadowColor;`, t2 += `
}`;
  for (let e3 = 0; e3 < o2; e3++)
    t2 += `
else `, e3 < o2 - 1 && (t2 += `if(textureId == ${e3}.0)`), t2 += `
{`, t2 += `
	color = texture2D(uSamplers[${e3}], textureCoord * uSamplerSize[${e3}]);`, t2 += `
}`;
  return t2 += `
`, t2 += `
`, t2;
}
function At(o2, t2) {
  const e3 = [];
  for (let s2 = 0; s2 < t2; s2++)
    e3[s2] = s2;
  o2.uniforms.uSamplers = e3;
  const i2 = [];
  for (let s2 = 0; s2 < t2; s2++)
    i2.push(1 / 2048), i2.push(1 / 2048);
  o2.uniforms.uSamplerSize = i2;
}
function Mt(o2, t2) {
  return t2.replace(/%count%/gi, `${o2}`).replace(/%forloop%/gi, It(o2));
}
const yt = `#version 100
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aAnimDivisor;
attribute float aTextureId;
attribute float aAlpha;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;
varying float vAlpha;

void main(void)
{
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 currentFrame = floor(animationFrame / aAnimDivisor);
   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
   vAlpha = aAlpha;
}
`, Lt = `#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
varying float vAlpha;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void)
{
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color * vAlpha;
}
`;
let Q$1 = class Q extends Shader {
  constructor(t2) {
    super(
      new Program(
        yt,
        Mt(t2, Lt)
      ),
      {
        animationFrame: new Float32Array(2),
        uSamplers: [],
        uSamplerSize: [],
        projTransMatrix: new Matrix()
      }
    ), this.maxTextures = 0, this.maxTextures = t2, At(this, this.maxTextures);
  }
};
let K$1 = class K extends Geometry {
  constructor() {
    super(), this.vertSize = 13, this.vertPerQuad = 4, this.stride = this.vertSize * 4, this.lastTimeAccess = 0;
    const t2 = this.buf = new Buffer(new Float32Array(2), true, false);
    this.addAttribute("aVertexPosition", t2, 0, false, 0, this.stride, 0).addAttribute("aTextureCoord", t2, 0, false, 0, this.stride, 2 * 4).addAttribute("aFrame", t2, 0, false, 0, this.stride, 4 * 4).addAttribute("aAnim", t2, 0, false, 0, this.stride, 8 * 4).addAttribute("aTextureId", t2, 0, false, 0, this.stride, 10 * 4).addAttribute("aAnimDivisor", t2, 0, false, 0, this.stride, 11 * 4).addAttribute("aAlpha", t2, 0, false, 0, this.stride, 12 * 4);
  }
};
class st extends ObjectRenderer {
  /** @param renderer - The managing renderer */
  constructor(t2) {
    super(t2), this.tileAnim = [0, 0], this.ibLen = 0, this.indexBuffer = null, this.textiles = [], this.shader = new Q$1(m$1.TEXTURES_PER_TILEMAP), this.indexBuffer = new Buffer(void 0, true, true), this.checkIndexBuffer(2e3), this.makeTextiles();
  }
  /**
  * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.
  *
  * If {@link settings.TEXTILE_UNITS}
  *
  * @param renderer - The renderer to which the textures are to be bound.
  * @param textures - The tile textures being bound.
  */
  bindTileTextures(t2, e3) {
    const i2 = e3.length, s2 = this.shader, a8 = m$1.TEXTURES_PER_TILEMAP, u2 = s2.uniforms.uSamplerSize;
    if (!(i2 > m$1.TEXTILE_UNITS * a8)) {
      for (let l2 = 0; l2 < e3.length; l2++) {
        const h2 = e3[l2];
        if (!h2 || !h2.valid)
          return;
        t2.texture.bind(e3[l2], l2), u2[l2 * 2] = 1 / e3[l2].realWidth, u2[l2 * 2 + 1] = 1 / e3[l2].realHeight;
      }
      s2.uniforms.uSamplerSize = u2;
    }
  }
  start() {
  }
  /**
  * @internal
  * @ignore
  */
  createVb() {
    const t2 = new K$1();
    return t2.addIndex(this.indexBuffer), t2.lastTimeAccess = Date.now(), t2;
  }
  /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */
  getShader() {
    return this.shader;
  }
  destroy() {
    super.destroy(), this.shader = null;
  }
  // eslint-disable-next-line no-unused-vars
  checkIndexBuffer(t2, e3 = null) {
    const i2 = t2 * 6;
    i2 <= this.ibLen || (this.ibLen = i2, this.indexBuffer.update(createIndicesForQuads(
      t2,
      m$1.use32bitIndex ? new Uint32Array(t2 * 6) : void 0
    )));
  }
  /** Makes textile resources and initializes {@link TileRenderer.textiles}. */
  makeTextiles() {
  }
}
extensions$1.add({
  name: "tilemap",
  type: ExtensionType.RendererPlugin,
  ref: st
});
m$1.use32bitIndex = true;
class TileLayer extends CommonLayer {
  static findTileSet(gid, tileSets) {
    let tileset;
    for (let i2 = tileSets.length - 1; i2 >= 0; i2--) {
      tileset = tileSets[i2];
      if (tileset.firstgid && tileset.firstgid <= gid) {
        break;
      }
    }
    return tileset;
  }
  constructor(layer, tileSets, map2) {
    super(layer, map2);
    this.tileSets = tileSets;
    this._tiles = {};
  }
  /** @internal */
  createTile(x2, y2, options2 = {}) {
    const {
      real,
      filter: filter3
    } = options2;
    const {
      width,
      tilewidth,
      tileheight
    } = this.map.getData();
    if (real) {
      x2 = Math.floor(x2 / tilewidth);
      y2 = Math.floor(y2 / tileheight);
    }
    const i2 = x2 + y2 * width;
    const tiledTile = this.layer.getTileByIndex(i2);
    if (!tiledTile || tiledTile && tiledTile.gid == 0)
      return;
    const tileset = TileLayer.findTileSet(tiledTile.gid, this.tileSets);
    if (!tileset)
      return;
    const tile = new Tile2(tiledTile, tileset);
    tile.x = x2 * tilewidth;
    tile.y = y2 * tileheight + (tileheight - tile.texture.height);
    tile._x = x2;
    tile._y = y2;
    if (tileset.tileoffset) {
      tile.x += tileset.tileoffset.x ?? 0;
      tile.y += tileset.tileoffset.y ?? 0;
    }
    if (filter3) {
      const ret = filter3(tile);
      if (!ret)
        return;
    }
    return tile;
  }
  /** @internal */
  changeTile(x2, y2) {
    const {
      tilewidth,
      tileheight
    } = this.map.getData();
    x2 = Math.floor(x2 / tilewidth);
    y2 = Math.floor(y2 / tileheight);
    const oldTile = this._tiles[x2 + ";" + y2];
    const newTile = this.createTile(x2, y2);
    if (!oldTile && newTile) {
      this.addFrame(newTile, x2, y2);
    } else {
      if (newTile) {
        const bufComposite = new Z$1();
        const frame = bufComposite.tile(newTile.texture, newTile.x, newTile.y);
        newTile.setAnimation(frame);
        this._tiles[x2 + ";" + y2] = newTile;
        const pointsBufComposite = bufComposite.children[0].pointsBuf;
        [0, 1, 4, 6, 7, 8].forEach((i2) => {
          if (this.pointsBuf)
            this.pointsBuf[oldTile.pointsBufIndex + i2] = pointsBufComposite[i2];
        });
        this.tilemap.children[0].modificationMarker = 0;
        this.addFrame(newTile, x2, y2);
        this["modificationMarker"] = 0;
      } else {
        delete this._tiles[x2 + ";" + y2];
        if (this.pointsBuf)
          this.pointsBuf.splice(oldTile.pointsBufIndex, L$1);
      }
    }
  }
  /** @internal */
  get pointsBuf() {
    const child = this.tilemap.children[0];
    if (!child)
      return null;
    return child["pointsBuf"];
  }
  addFrame(tile, x2, y2) {
    const frame = this.tilemap.tile(tile.texture, tile.x, tile.y, {
      rotate: tile.texture.rotate
    });
    const pb = this.pointsBuf;
    if (!pb)
      return null;
    tile.pointsBufIndex = pb.length - L$1;
    tile.setAnimation(frame);
    this._tiles[x2 + ";" + y2] = tile;
  }
  /** @internal */
  create() {
    this.tilemap = new Z$1();
    const {
      width,
      height
    } = this.map.getData();
    for (let y2 = 0; y2 < height; y2++) {
      for (let x2 = 0; x2 < width; x2++) {
        const tile = this.createTile(x2, y2);
        if (tile) {
          this.addFrame(tile, x2, y2);
        }
      }
    }
    this.addChild(this.tilemap);
  }
}
function _initResource(memory, _resources, prop, engine) {
  for (let resource of _resources) {
    const pluralProp = prop + "s";
    if (resource[pluralProp]) {
      for (let key in resource[pluralProp]) {
        const instance = new resource();
        instance[prop] = engine.getResourceUrl(resource[pluralProp][key]);
        memory.set(key, instance);
      }
    } else {
      const instance = new resource(engine);
      instance[prop] = engine.getResourceUrl(instance[prop]);
      memory.set(resource.id, instance);
    }
  }
}
const spritesheets = /* @__PURE__ */ new Map();
function _initSpritesheet(_spritesheets, engine) {
  return _initResource(spritesheets, _spritesheets, "image", engine);
}
function log(message) {
  return new Error(`[RPGJS] - ${message}`);
}
class TileSet extends Tileset {
  constructor(tileSet) {
    super(tileSet);
    this.textures = [];
  }
  /** @internal */
  load() {
    const spritesheet = spritesheets.get(this.name);
    if (!spritesheet) {
      throw log(`Impossible to find ${this.name} tileset`);
    }
    this.baseTexture = spritesheet.resource;
    for (let y2 = this.margin; y2 < this.image.height; y2 += this.tileheight + this.spacing) {
      for (let x2 = this.margin; x2 < this.image.width; x2 += this.tilewidth + this.spacing) {
        this.textures.push(new Texture(this.baseTexture, new Rectangle(+x2, +y2, +this.tilewidth, +this.tileheight)));
      }
    }
  }
}
const {
  intersection
} = Utils$2;
class TileMap extends Container {
  constructor(context2, data) {
    super();
    this.context = context2;
    this.data = data;
    this.background = new Graphics();
    this.tilewidth = 0;
    this.tileheight = 0;
    this.frameRateAnimation = 10;
    this.tilesets = [];
    this.layers = {};
    this.tilesLayer = new Container();
    this.frameTile = 0;
    this.renderer = this.context.inject(RpgRenderer);
    this.x = 0;
    this.y = 0;
    this.create(data);
  }
  /** @internal */
  drawAnimateTile(frame) {
    if (frame % this.frameRateAnimation == 0) {
      this.renderer["renderer"].plugins.tilemap.tileAnim[0] = this.frameTile;
      this.frameTile++;
    }
  }
  getData() {
    return this.data;
  }
  setBackgroundColor(color) {
    color = color.replace("#", "");
    this.background.beginFill(parseInt(color, 16));
    this.background.drawRect(0, 0, (this.width || 0) * (this.tilewidth || 0), (this.height || 0) * (this.tileheight || 0));
    this.background.endFill();
  }
  create(data) {
    this.data = data;
    Object.assign(this, data);
    if (this.data.backgroundcolor)
      this.setBackgroundColor(this.data.backgroundcolor);
    this.addChild(this.background);
    this.tilesets = this.data.tilesets.map((tileSet) => {
      return new TileSet(tileSet);
    });
  }
  /** @internal */
  createOverlayTiles(x2, y2, instance) {
    const tilesLayer = [];
    this.data.layers.forEach((layerData) => {
      switch (layerData.type) {
        case TiledLayerType.Tile: {
          const tileLayer = new TileLayer(layerData, this.tilesets, this);
          const tile = tileLayer.createTile(x2, y2, {
            real: true,
            filter: (tile2) => {
              const {
                data,
                y: yObject,
                z: zObject
              } = instance;
              const {
                hHitbox,
                height
              } = data;
              const zLayer = tileLayer.z;
              const tileHasZ = tile2.properties.z !== void 0;
              let {
                z: z2
              } = tile2.properties;
              if (zLayer !== void 0) {
                z2 = zLayer + (z2 !== void 0 ? z2 : 0);
              }
              if (z2 == void 0)
                return false;
              const realZ = z2 * tile2.height;
              if (zObject + height < realZ) {
                return true;
              }
              if (zObject > realZ + tile2.height) {
                return false;
              }
              if (!tileHasZ)
                return false;
              if (yObject + hHitbox > tile2.y + tile2.height) {
                const zIntersection = intersection([
                  zObject,
                  zObject + tile2.height
                  /** Old code: height */
                ], [realZ, realZ + tile2.height]);
                if (!zIntersection) {
                  return true;
                }
                return false;
              }
              return true;
            }
          });
          if (tile) {
            tileLayer.addChild(tile);
            const size2 = tile.animations.length;
            if (size2 > 0) {
              const ms = 1e3 / 60;
              tile.animationSpeed = ms / (ms * this.frameRateAnimation);
              let frameIndex = this.frameTile % size2;
              tile.gotoAndPlay(frameIndex);
            }
            tilesLayer.push(tileLayer);
          }
          break;
        }
      }
    });
    return tilesLayer;
  }
  /** @internal */
  changeTile(x2, y2, layerName) {
    const layer = this.layers[layerName];
    if (!layer)
      throw log(`${layerName} not exists`);
    if (layer instanceof TileLayer) {
      layer.changeTile(x2, y2);
    }
  }
  /** @internal */
  load(options2) {
    this.tilesLayer.removeChildren();
    this.tilesets.forEach((tileset) => tileset.load());
    this.data.layers.forEach((layerData) => {
      switch (layerData.type) {
        case TiledLayerType.Tile: {
          const tileLayer = new TileLayer(layerData, this.tilesets, this);
          if (options2 == null ? void 0 : options2.drawTiles)
            tileLayer.create();
          this.layers[layerData.name] = tileLayer;
          this.tilesLayer.addChild(tileLayer);
          break;
        }
        case TiledLayerType.Image: {
          const imageLayer = new ImageLayer(layerData, this);
          this.layers[layerData.name] = imageLayer;
          this.tilesLayer.addChild(imageLayer);
          break;
        }
      }
    });
    this.addChild(this.tilesLayer);
  }
}
var S = Object.defineProperty;
var M = (c3, r2, t2) => r2 in c3 ? S(c3, r2, { enumerable: true, configurable: true, writable: true, value: t2 }) : c3[r2] = t2;
var o = (c3, r2, t2) => (M(c3, typeof r2 != "symbol" ? r2 + "" : r2, t2), t2);
let f$1 = class f {
  constructor(r2) {
    o(this, "parent");
    o(this, "paused");
    this.parent = r2, this.paused = false;
  }
  destroy() {
  }
  down(r2) {
    return false;
  }
  move(r2) {
    return false;
  }
  up(r2) {
    return false;
  }
  wheel(r2) {
    return false;
  }
  update(r2) {
  }
  resize() {
  }
  reset() {
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
};
var C = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {}, H = { exports: {} };
(function(c3, r2) {
  (function() {
    var t2, i2;
    i2 = function(e3) {
      return c3.exports = e3;
    }, t2 = {
      linear: function(e3, n2, s2, h2) {
        return s2 * e3 / h2 + n2;
      },
      easeInQuad: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 + n2;
      },
      easeOutQuad: function(e3, n2, s2, h2) {
        return -s2 * (e3 /= h2) * (e3 - 2) + n2;
      },
      easeInOutQuad: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 + n2 : -s2 / 2 * (--e3 * (e3 - 2) - 1) + n2;
      },
      easeInCubic: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 + n2;
      },
      easeOutCubic: function(e3, n2, s2, h2) {
        return s2 * ((e3 = e3 / h2 - 1) * e3 * e3 + 1) + n2;
      },
      easeInOutCubic: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 + n2 : s2 / 2 * ((e3 -= 2) * e3 * e3 + 2) + n2;
      },
      easeInQuart: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 * e3 + n2;
      },
      easeOutQuart: function(e3, n2, s2, h2) {
        return -s2 * ((e3 = e3 / h2 - 1) * e3 * e3 * e3 - 1) + n2;
      },
      easeInOutQuart: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 * e3 + n2 : -s2 / 2 * ((e3 -= 2) * e3 * e3 * e3 - 2) + n2;
      },
      easeInQuint: function(e3, n2, s2, h2) {
        return s2 * (e3 /= h2) * e3 * e3 * e3 * e3 + n2;
      },
      easeOutQuint: function(e3, n2, s2, h2) {
        return s2 * ((e3 = e3 / h2 - 1) * e3 * e3 * e3 * e3 + 1) + n2;
      },
      easeInOutQuint: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * e3 * e3 * e3 * e3 * e3 + n2 : s2 / 2 * ((e3 -= 2) * e3 * e3 * e3 * e3 + 2) + n2;
      },
      easeInSine: function(e3, n2, s2, h2) {
        return -s2 * Math.cos(e3 / h2 * (Math.PI / 2)) + s2 + n2;
      },
      easeOutSine: function(e3, n2, s2, h2) {
        return s2 * Math.sin(e3 / h2 * (Math.PI / 2)) + n2;
      },
      easeInOutSine: function(e3, n2, s2, h2) {
        return -s2 / 2 * (Math.cos(Math.PI * e3 / h2) - 1) + n2;
      },
      easeInExpo: function(e3, n2, s2, h2) {
        return e3 === 0 ? n2 : s2 * Math.pow(2, 10 * (e3 / h2 - 1)) + n2;
      },
      easeOutExpo: function(e3, n2, s2, h2) {
        return e3 === h2 ? n2 + s2 : s2 * (-Math.pow(2, -10 * e3 / h2) + 1) + n2;
      },
      easeInOutExpo: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? s2 / 2 * Math.pow(2, 10 * (e3 - 1)) + n2 : s2 / 2 * (-Math.pow(2, -10 * --e3) + 2) + n2;
      },
      easeInCirc: function(e3, n2, s2, h2) {
        return -s2 * (Math.sqrt(1 - (e3 /= h2) * e3) - 1) + n2;
      },
      easeOutCirc: function(e3, n2, s2, h2) {
        return s2 * Math.sqrt(1 - (e3 = e3 / h2 - 1) * e3) + n2;
      },
      easeInOutCirc: function(e3, n2, s2, h2) {
        return (e3 /= h2 / 2) < 1 ? -s2 / 2 * (Math.sqrt(1 - e3 * e3) - 1) + n2 : s2 / 2 * (Math.sqrt(1 - (e3 -= 2) * e3) + 1) + n2;
      },
      easeInElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2), p2 || (p2 = h2 * 0.3), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), -(a8 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2)) + n2;
      },
      easeOutElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2), p2 || (p2 = h2 * 0.3), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), a8 * Math.pow(2, -10 * e3) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2) + s2 + n2;
      },
      easeInOutElastic: function(e3, n2, s2, h2) {
        var a8, p2, l2;
        return l2 = 1.70158, p2 = 0, a8 = s2, e3 === 0 || (e3 /= h2 / 2), p2 || (p2 = h2 * (0.3 * 1.5)), a8 < Math.abs(s2) ? (a8 = s2, l2 = p2 / 4) : l2 = p2 / (2 * Math.PI) * Math.asin(s2 / a8), e3 < 1 ? -0.5 * (a8 * Math.pow(2, 10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2)) + n2 : a8 * Math.pow(2, -10 * (e3 -= 1)) * Math.sin((e3 * h2 - l2) * (2 * Math.PI) / p2) * 0.5 + s2 + n2;
      },
      easeInBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), s2 * (e3 /= h2) * e3 * ((a8 + 1) * e3 - a8) + n2;
      },
      easeOutBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), s2 * ((e3 = e3 / h2 - 1) * e3 * ((a8 + 1) * e3 + a8) + 1) + n2;
      },
      easeInOutBack: function(e3, n2, s2, h2, a8) {
        return a8 === void 0 && (a8 = 1.70158), (e3 /= h2 / 2) < 1 ? s2 / 2 * (e3 * e3 * (((a8 *= 1.525) + 1) * e3 - a8)) + n2 : s2 / 2 * ((e3 -= 2) * e3 * (((a8 *= 1.525) + 1) * e3 + a8) + 2) + n2;
      },
      easeInBounce: function(e3, n2, s2, h2) {
        var a8;
        return a8 = t2.easeOutBounce(h2 - e3, 0, s2, h2), s2 - a8 + n2;
      },
      easeOutBounce: function(e3, n2, s2, h2) {
        return (e3 /= h2) < 1 / 2.75 ? s2 * (7.5625 * e3 * e3) + n2 : e3 < 2 / 2.75 ? s2 * (7.5625 * (e3 -= 1.5 / 2.75) * e3 + 0.75) + n2 : e3 < 2.5 / 2.75 ? s2 * (7.5625 * (e3 -= 2.25 / 2.75) * e3 + 0.9375) + n2 : s2 * (7.5625 * (e3 -= 2.625 / 2.75) * e3 + 0.984375) + n2;
      },
      easeInOutBounce: function(e3, n2, s2, h2) {
        var a8;
        return e3 < h2 / 2 ? (a8 = t2.easeInBounce(e3 * 2, 0, s2, h2), a8 * 0.5 + n2) : (a8 = t2.easeOutBounce(e3 * 2 - h2, 0, s2, h2), a8 * 0.5 + s2 * 0.5 + n2);
      }
    }, i2(t2);
  }).call(C);
})(H);
const b$1 = H.exports;
function W(c3, r2) {
  if (c3) {
    if (typeof c3 == "function")
      return c3;
    if (typeof c3 == "string")
      return b$1[c3];
  } else
    return b$1[r2];
}
const I = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
let k$1 = class k2 extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "startX");
    o(this, "startY");
    o(this, "deltaX");
    o(this, "deltaY");
    o(this, "keepCenter");
    o(this, "startWidth", null);
    o(this, "startHeight", null);
    o(this, "deltaWidth", null);
    o(this, "deltaHeight", null);
    o(this, "width", null);
    o(this, "height", null);
    o(this, "time", 0);
    this.options = Object.assign({}, I, i2), this.options.ease = W(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const i2 = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const e3 = this.parent.width, n2 = this.parent.height;
      this.complete(), (e3 !== this.parent.width || n2 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i2, type: "animate" });
    } else {
      const e3 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const n2 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(
          n2 + s2 * e3,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const n2 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(
          n2 + s2 * e3,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const n2 = this.startX, s2 = this.startY, h2 = this.deltaX, a8 = this.deltaY, p2 = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(n2 + h2 * e3, s2 + a8 * e3), this.parent.emit("moved", { viewport: this.parent, original: p2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: i2, type: "animate" });
    }
  }
};
const Y = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
class X extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "left");
    o(this, "top");
    o(this, "right");
    o(this, "bottom");
    o(this, "underflowX");
    o(this, "underflowY");
    o(this, "ease");
    o(this, "toX");
    o(this, "toY");
    this.options = Object.assign({}, Y, i2), this.ease = W(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const e3 = this.options.underflow.toLowerCase();
    e3 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = e3.indexOf("left") !== -1 ? -1 : e3.indexOf("right") !== -1 ? 1 : 0, this.underflowY = e3.indexOf("top") !== -1 ? -1 : e3.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const i2 = this.toX;
        i2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), i2.time >= this.options.time ? (this.parent.x = i2.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(i2.time, i2.start, i2.delta, this.options.time);
      }
      if (this.toY) {
        const i2 = this.toY;
        i2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), i2.time >= this.options.time ? (this.parent.y = i2.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(i2.time, i2.start, i2.delta, this.options.time);
      }
    }
  }
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const i2 = typeof t2.x > "u" ? 0 : t2.x, e3 = typeof t2.y > "u" ? 0 : t2.y, n2 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < i2,
        right: this.parent.right > n2,
        top: this.parent.top < e3,
        bottom: this.parent.bottom > s2,
        topLeft: new Point(
          i2 * this.parent.scale.x,
          e3 * this.parent.scale.y
        ),
        bottomRight: new Point(
          n2 * this.parent.scale.x - this.parent.screenWidth,
          s2 * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, i2 = this.parent.plugins.get("decelerate", true);
    i2 && (i2.x || i2.y) && (i2.x && i2.percentChangeX === ((s2 = i2.options) == null ? void 0 : s2.friction) || i2.y && i2.percentChangeY === ((h2 = i2.options) == null ? void 0 : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (i2.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (i2.percentChangeY = this.options.friction));
    const e3 = this.parent.plugins.get("drag", true) || {}, n2 = this.parent.plugins.get("pinch", true) || {};
    if (i2 = i2 || {}, !(e3 != null && e3.active) && !(n2 != null && n2.active) && (!this.toX || !this.toY) && (!i2.x || !i2.y)) {
      t2 = t2 || this.oob();
      const a8 = t2.topLeft, p2 = t2.bottomRight;
      if (!this.toX && !i2.x) {
        let l2 = null;
        t2.left && this.left ? l2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -a8.x : t2.right && this.right && (l2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -p2.x), l2 !== null && this.parent.x !== l2 && (this.toX = { time: 0, start: this.parent.x, delta: l2 - this.parent.x, end: l2 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !i2.y) {
        let l2 = null;
        t2.top && this.top ? l2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -a8.y : t2.bottom && this.bottom && (l2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -p2.y), l2 !== null && this.parent.y !== l2 && (this.toY = { time: 0, start: this.parent.y, delta: l2 - this.parent.y, end: l2 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
}
const z = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
class A extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "last");
    o(this, "noUnderflow");
    o(this, "underflowX");
    o(this, "underflowY");
    this.options = Object.assign({}, z, i2), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point(this.parent.x, this.parent.y), i2 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, e3 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, e3 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, e3 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, i2.x = 0, e3 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, i2.x = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let e3 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, e3 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, e3 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, e3 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, i2.y = 0, e3 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, i2.y = 0, e3 = true);
      e3 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
}
const _ = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
class T extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    this.options = Object.assign({}, _, i2), this.clamp();
  }
  resize() {
    this.clamp();
  }
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const e3 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && i2 < this.options.minHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && i2 > this.options.maxHeight) {
          const e3 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / e3, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, i2 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          i2.x = this.options.maxScale, i2.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          i2.x = typeof s2.x > "u" ? null : s2.x, i2.y = typeof s2.y > "u" ? null : s2.y;
        }
        let e3 = this.parent.scale.x, n2 = this.parent.scale.y;
        t2.x !== null && e3 < t2.x && (e3 = t2.x), i2.x !== null && e3 > i2.x && (e3 = i2.x), t2.y !== null && n2 < t2.y && (n2 = t2.y), i2.y !== null && n2 > i2.y && (n2 = i2.y), (e3 !== this.parent.scale.x || n2 !== this.parent.scale.y) && (this.parent.scale.set(e3, n2), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
}
const D = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
}, g = 16;
class E extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "x");
    o(this, "y");
    o(this, "percentChangeX");
    o(this, "percentChangeY");
    o(this, "saved");
    o(this, "timeSinceRelease");
    this.options = Object.assign({}, D, i2), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (e3) => this.handleMoved(e3));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  handleMoved(t2) {
    if (this.saved.length) {
      const i2 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? i2.x === t2.original.x && (i2.x = this.parent.x) : t2.type === "clamp-y" && t2.original && i2.y === t2.original.y && (i2.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const i2 of this.saved)
        if (i2.time >= t2 - 100) {
          const e3 = t2 - i2.time;
          this.x = (this.parent.x - i2.x) / e3, this.y = (this.parent.y - i2.y) / e3, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const i2 = this.x || this.y, e3 = this.timeSinceRelease, n2 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * g / h2 * (Math.pow(s2, n2 / g) - Math.pow(s2, e3 / g)), this.x *= Math.pow(this.percentChangeX, t2 / g);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * g / h2 * (Math.pow(s2, n2 / g) - Math.pow(s2, e3 / g)), this.y *= Math.pow(this.percentChangeY, t2 / g);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), i2 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
}
const L = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
class U extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "moved");
    o(this, "reverse");
    o(this, "xDirection");
    o(this, "yDirection");
    o(this, "keyIsPressed");
    o(this, "mouse");
    o(this, "underflowX");
    o(this, "underflowY");
    o(this, "last");
    o(this, "current");
    o(this, "windowEventHandlers", []);
    this.options = Object.assign({}, L, i2), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    const i2 = (n2) => {
      t2.includes(n2.code) && (this.keyIsPressed = true);
    }, e3 = (n2) => {
      t2.includes(n2.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", e3), this.addWindowEventHandler("keydown", i2);
  }
  addWindowEventHandler(t2, i2) {
    window.addEventListener(t2, i2), this.windowEventHandlers.push({ event: t2, handler: i2 });
  }
  destroy() {
    this.windowEventHandlers.forEach(({ event: t2, handler: i2 }) => {
      window.removeEventListener(t2, i2);
    });
  }
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  checkButtons(t2) {
    const i2 = t2.pointerType === "mouse", e3 = this.parent.input.count();
    return !!((e3 === 1 || e3 > 1 && !this.parent.plugins.get("pinch", true)) && (!i2 || this.mouse[t2.button]));
  }
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const i2 = t2.global.x, e3 = t2.global.y, n2 = this.parent.input.count();
      if (n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = i2 - this.last.x, h2 = e3 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s2) || this.yDirection && this.parent.input.checkThreshold(h2)) {
          const a8 = { x: i2, y: e3 };
          return this.xDirection && (this.parent.x += (a8.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (a8.y - this.last.y) * this.options.factor), this.last = a8, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const i2 = this.parent.input.touches;
    if (i2.length === 1) {
      const e3 = i2[0];
      return e3.last && (this.last = { x: e3.last.x, y: e3.last.y }, this.current = e3.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const e3 = new Point(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t2,
        screen: e3,
        world: this.parent.toWorld(e3),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const i2 = this.parent.plugins.get("wheel", true);
      if (!i2 || !i2.options.wheelZoom && !t2.ctrlKey) {
        const e3 = t2.deltaMode ? this.options.lineHeight : 1, n2 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? n2.reverse() : n2;
        return this.xDirection && (this.parent.x += s2 * e3 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * e3 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
}
const V = {
  speed: 0,
  acceleration: null,
  radius: null
};
class F extends f$1 {
  constructor(t2, i2, e3 = {}) {
    super(t2);
    o(this, "options");
    o(this, "target");
    o(this, "velocity");
    this.target = i2, this.options = Object.assign({}, V, e3), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const i2 = this.parent.center;
    let e3 = this.target.x, n2 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - i2.y, 2) + Math.pow(this.target.x - i2.x, 2)) > this.options.radius) {
        const p2 = Math.atan2(this.target.y - i2.y, this.target.x - i2.x);
        e3 = this.target.x - Math.cos(p2) * this.options.radius, n2 = this.target.y - Math.sin(p2) * this.options.radius;
      } else
        return;
    const s2 = e3 - i2.x, h2 = n2 - i2.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const a8 = Math.atan2(n2 - i2.y, e3 - i2.x), p2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (p2) {
            const l2 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            p2 > l2 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const d2 = Math.cos(a8) * this.velocity.x, m2 = Math.sin(a8) * this.velocity.y, y2 = Math.abs(d2) > Math.abs(s2) ? e3 : i2.x + d2, x2 = Math.abs(m2) > Math.abs(h2) ? n2 : i2.y + m2;
            this.parent.moveCenter(y2, x2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const a8 = Math.atan2(n2 - i2.y, e3 - i2.x), p2 = Math.cos(a8) * this.options.speed, l2 = Math.sin(a8) * this.options.speed, d2 = Math.abs(p2) > Math.abs(s2) ? e3 : i2.x + p2, m2 = Math.abs(l2) > Math.abs(h2) ? n2 : i2.y + l2;
          this.parent.moveCenter(d2, m2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(e3, n2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
}
const B2 = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
class N extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "reverse");
    o(this, "radiusSquared");
    o(this, "left");
    o(this, "top");
    o(this, "right");
    o(this, "bottom");
    o(this, "horizontal");
    o(this, "vertical");
    this.options = Object.assign({}, B2, i2), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const i2 = t2.global.x, e3 = t2.global.y;
    if (this.radiusSquared) {
      const n2 = this.parent.toScreen(this.parent.center);
      if (Math.pow(n2.x - i2, 2) + Math.pow(n2.y - e3, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(n2.y - e3, n2.x - i2);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && i2 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && i2 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && e3 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && e3 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
}
const Z2 = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
class R extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "active", false);
    o(this, "pinching", false);
    o(this, "moved", false);
    o(this, "lastCenter");
    this.options = Object.assign({}, Z2, i2);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const i2 = t2.global.x, e3 = t2.global.y, n2 = this.parent.input.touches;
    if (n2.length >= 2) {
      const s2 = n2[0], h2 = n2[1], a8 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: i2, y: e3, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: i2, y: e3, data: t2 }), a8) {
        let p2;
        const l2 = new Point(
          s2.last.x + (h2.last.x - s2.last.x) / 2,
          s2.last.y + (h2.last.y - s2.last.y) / 2
        );
        this.options.center || (p2 = this.parent.toLocal(l2));
        let d2 = Math.sqrt(Math.pow(
          h2.last.x - s2.last.x,
          2
        ) + Math.pow(h2.last.y - s2.last.y, 2));
        d2 = d2 === 0 ? d2 = 1e-10 : d2;
        const m2 = (1 - a8 / d2) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += m2), this.isAxisY() && (this.parent.scale.y += m2), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: l2 });
        const y2 = this.parent.plugins.get("clamp-zoom", true);
        if (y2 && y2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const x2 = this.parent.toGlobal(p2);
          this.parent.x += (l2.x - x2.x) * this.options.factor, this.parent.y += (l2.y - x2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (l2.x - this.lastCenter.x) * this.options.factor, this.parent.y += (l2.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = l2, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
}
const j$1 = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
class q extends f$1 {
  constructor(t2, i2, e3, n2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "ease");
    o(this, "x");
    o(this, "y");
    o(this, "percent");
    o(this, "snapping");
    o(this, "deltaX");
    o(this, "deltaY");
    o(this, "startX");
    o(this, "startY");
    this.options = Object.assign({}, j$1, n2), this.ease = W(n2.ease, "easeInOutSine"), this.x = i2, this.y = e3, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const i2 = this.snapping;
        i2.time += t2;
        let e3, n2, s2;
        const h2 = this.startX, a8 = this.startY, p2 = this.deltaX, l2 = this.deltaY;
        if (i2.time > this.options.time)
          e3 = true, n2 = h2 + p2, s2 = a8 + l2;
        else {
          const d2 = this.ease(i2.time, 0, 1, this.options.time);
          n2 = h2 + p2 * d2, s2 = a8 + l2 * d2;
        }
        this.options.topLeft ? this.parent.moveCorner(n2, s2) : this.parent.moveCenter(n2, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), e3 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const i2 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (i2.x !== this.x || i2.y !== this.y) && this.snapStart();
      }
  }
}
const K2 = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
class G extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "ease");
    o(this, "xScale");
    o(this, "yScale");
    o(this, "xIndependent");
    o(this, "yIndependent");
    o(this, "snapping");
    this.options = Object.assign({}, K2, i2), this.ease = W(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : i2.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, i2 = this.parent.worldScreenHeight, e3 = this.parent.screenWidth / this.xScale, n2 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: i2,
      deltaX: e3 - t2,
      deltaY: n2 - i2
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let i2;
    if (!this.options.center && !this.options.noMove && (i2 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const e3 = this.snapping;
      if (e3.time += t2, e3.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), a8 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / a8;
      }
      const n2 = this.parent.plugins.get("clamp-zoom", true);
      n2 && n2.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(i2));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
}
const Q2 = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
class J extends f$1 {
  constructor(t2, i2 = {}) {
    super(t2);
    o(this, "options");
    o(this, "smoothing");
    o(this, "smoothingCenter");
    o(this, "smoothingCount");
    o(this, "keyIsPressed");
    this.options = Object.assign({}, Q2, i2), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    window.addEventListener("keydown", (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = false);
    });
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, i2 = this.smoothing;
      let e3;
      this.options.center || (e3 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += i2.x), this.isAxisY() && (this.parent.scale.y += i2.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const n2 = this.parent.plugins.get("clamp-zoom", true);
      if (n2 && n2.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.toGlobal(e3);
        this.parent.x += t2.x - s2.x, this.parent.y += t2.y - s2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const i2 = this.parent.input.getPointerPosition(t2), e3 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, n2 = Math.pow(2, (1 + this.options.percent) * e3);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(i2)), this.isAxisX() && (this.parent.scale.x *= n2), this.isAxisY() && (this.parent.scale.y *= n2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const a8 = this.parent.toGlobal(s2);
      this.parent.x += i2.x - a8.x, this.parent.y += i2.y - a8.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t2, viewport: this.parent }
    );
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const i2 = this.parent.input.getPointerPosition(t2), n2 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * n2);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = i2;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(i2)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const a8 = this.parent.plugins.get("clamp-zoom", true);
        if (a8 && a8.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const p2 = this.parent.toGlobal(h2);
          this.parent.x += i2.x - p2.x, this.parent.y += i2.y - p2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t2, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
}
class $ {
  constructor(r2) {
    o(this, "viewport");
    o(this, "clickedAvailable");
    o(this, "isMouseDown");
    o(this, "last");
    o(this, "wheelFunction");
    o(this, "touches");
    this.viewport = r2, this.touches = [], this.addListeners();
  }
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (r2) => this.handleWheel(r2), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  down(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    if (r2.pointerType === "mouse" ? this.isMouseDown = true : this.get(r2.pointerId) || this.touches.push({ id: r2.pointerId, last: null }), this.count() === 1) {
      this.last = r2.global.clone();
      const i2 = this.viewport.plugins.get("decelerate", true), e3 = this.viewport.plugins.get("bounce", true);
      (!i2 || !i2.isActive()) && (!e3 || !e3.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(r2) && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  checkThreshold(r2) {
    return Math.abs(r2) >= this.viewport.threshold;
  }
  move(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t2 = this.viewport.plugins.move(r2);
    if (this.clickedAvailable && this.last) {
      const i2 = r2.global.x - this.last.x, e3 = r2.global.y - this.last.y;
      (this.checkThreshold(i2) || this.checkThreshold(e3)) && (this.clickedAvailable = false);
    }
    t2 && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  up(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    r2.pointerType === "mouse" && (this.isMouseDown = false), r2.pointerType !== "mouse" && this.remove(r2.pointerId);
    const t2 = this.viewport.plugins.up(r2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: r2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), t2 && this.viewport.options.stopPropagation && r2.stopPropagation();
  }
  getPointerPosition(r2) {
    const t2 = new Point();
    return this.viewport.options.events.mapPositionToPoint(t2, r2.clientX, r2.clientY), t2;
  }
  handleWheel(r2) {
    if (this.viewport.pause || !this.viewport.worldVisible)
      return;
    const t2 = this.viewport.toLocal(this.getPointerPosition(r2));
    this.viewport.left <= t2.x && t2.x <= this.viewport.right && this.viewport.top <= t2.y && t2.y <= this.viewport.bottom && this.viewport.plugins.wheel(r2) && !this.viewport.options.passiveWheel && r2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  get(r2) {
    for (const t2 of this.touches)
      if (t2.id === r2)
        return t2;
    return null;
  }
  remove(r2) {
    for (let t2 = 0; t2 < this.touches.length; t2++)
      if (this.touches[t2].id === r2) {
        this.touches.splice(t2, 1);
        return;
      }
  }
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
}
const w = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
class tt {
  constructor(r2) {
    o(this, "plugins");
    o(this, "list");
    o(this, "viewport");
    this.viewport = r2, this.list = [], this.plugins = {};
  }
  add(r2, t2, i2 = w.length) {
    const e3 = this.plugins[r2];
    e3 && e3.destroy(), this.plugins[r2] = t2;
    const n2 = w.indexOf(r2);
    n2 !== -1 && w.splice(n2, 1), w.splice(i2, 0, r2), this.sort();
  }
  get(r2, t2) {
    var i2;
    return t2 && (i2 = this.plugins[r2]) != null && i2.paused ? null : this.plugins[r2];
  }
  update(r2) {
    for (const t2 of this.list)
      t2.update(r2);
  }
  resize() {
    for (const r2 of this.list)
      r2.resize();
  }
  reset() {
    for (const r2 of this.list)
      r2.reset();
  }
  removeAll() {
    this.list.forEach((r2) => {
      r2.destroy();
    }), this.plugins = {}, this.sort();
  }
  remove(r2) {
    var t2;
    this.plugins[r2] && ((t2 = this.plugins[r2]) == null || t2.destroy(), delete this.plugins[r2], this.viewport.emit("plugin-remove", r2), this.sort());
  }
  pause(r2) {
    var t2;
    (t2 = this.plugins[r2]) == null || t2.pause();
  }
  resume(r2) {
    var t2;
    (t2 = this.plugins[r2]) == null || t2.resume();
  }
  sort() {
    this.list = [];
    for (const r2 of w)
      this.plugins[r2] && this.list.push(this.plugins[r2]);
  }
  down(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.down(r2) && (t2 = true);
    return t2;
  }
  move(r2) {
    let t2 = false;
    for (const i2 of this.viewport.plugins.list)
      i2.move(r2) && (t2 = true);
    return t2;
  }
  up(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.up(r2) && (t2 = true);
    return t2;
  }
  wheel(r2) {
    let t2 = false;
    for (const i2 of this.list)
      i2.wheel(r2) && (t2 = true);
    return t2;
  }
}
const et = {
  screenWidth: window.innerWidth,
  screenHeight: window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};
class ht extends Container {
  constructor(t2) {
    super();
    o(this, "moving");
    o(this, "screenWidth");
    o(this, "screenHeight");
    o(this, "threshold");
    o(this, "input");
    o(this, "plugins");
    o(this, "zooming");
    o(this, "lastViewport");
    o(this, "options");
    o(this, "_dirty");
    o(this, "_forceHitArea");
    o(this, "_hitAreaDefault");
    o(this, "_pause");
    o(this, "tickerFunction");
    o(this, "_worldWidth");
    o(this, "_worldHeight");
    o(this, "_disableOnContextMenu", (t3) => t3.preventDefault());
    this.options = {
      ...et,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new $(this), this.plugins = new tt(this);
  }
  destroy(t2) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t2);
  }
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  resize(t2 = window.innerWidth, i2 = window.innerHeight, e3, n2) {
    this.screenWidth = t2, this.screenHeight = i2, typeof e3 < "u" && (this._worldWidth = e3), typeof n2 < "u" && (this._worldHeight = n2), this.plugins.resize(), this.dirty = true;
  }
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  toWorld(t2, i2) {
    return arguments.length === 2 ? this.toLocal(new Point(t2, i2)) : this.toLocal(t2);
  }
  toScreen(t2, i2) {
    return arguments.length === 2 ? this.toGlobal(new Point(t2, i2)) : this.toGlobal(t2);
  }
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  moveCenter(...t2) {
    let i2, e3;
    typeof t2[0] == "number" ? (i2 = t2[0], e3 = t2[1]) : (i2 = t2[0].x, e3 = t2[0].y);
    const n2 = (this.worldScreenWidth / 2 - i2) * this.scale.x, s2 = (this.worldScreenHeight / 2 - e3) * this.scale.y;
    return (this.x !== n2 || this.y !== s2) && (this.position.set(n2, s2), this.plugins.reset(), this.dirty = true), this;
  }
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  moveCorner(...t2) {
    let i2, e3;
    return t2.length === 1 ? (i2 = -t2[0].x * this.scale.x, e3 = -t2[0].y * this.scale.y) : (i2 = -t2[0] * this.scale.x, e3 = -t2[1] * this.scale.y), (i2 !== this.x || e3 !== this.y) && (this.position.set(i2, e3), this.plugins.reset(), this.dirty = true), this;
  }
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  findFit(t2, i2) {
    const e3 = this.screenWidth / t2, n2 = this.screenHeight / i2;
    return Math.min(e3, n2);
  }
  findCover(t2, i2) {
    const e3 = this.screenWidth / t2, n2 = this.screenHeight / i2;
    return Math.max(e3, n2);
  }
  fitWidth(t2 = this.worldWidth, i2, e3 = true, n2) {
    let s2;
    i2 && (s2 = this.center), this.scale.x = this.screenWidth / t2, e3 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !n2 && h2 && h2.clamp(), i2 && s2 && this.moveCenter(s2), this;
  }
  fitHeight(t2 = this.worldHeight, i2, e3 = true, n2) {
    let s2;
    i2 && (s2 = this.center), this.scale.y = this.screenHeight / t2, e3 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !n2 && h2 && h2.clamp(), i2 && s2 && this.moveCenter(s2), this;
  }
  fitWorld(t2) {
    let i2;
    t2 && (i2 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const e3 = this.plugins.get("clamp-zoom", true);
    return e3 && e3.clamp(), t2 && i2 && this.moveCenter(i2), this;
  }
  fit(t2, i2 = this.worldWidth, e3 = this.worldHeight) {
    let n2;
    t2 && (n2 = this.center), this.scale.x = this.screenWidth / i2, this.scale.y = this.screenHeight / e3, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && n2 && this.moveCenter(n2), this;
  }
  setZoom(t2, i2) {
    let e3;
    i2 && (e3 = this.center), this.scale.set(t2);
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), i2 && e3 && this.moveCenter(e3), this;
  }
  zoomPercent(t2, i2) {
    return this.setZoom(this.scale.x + this.scale.x * t2, i2);
  }
  zoom(t2, i2) {
    return this.fitWidth(t2 + this.worldScreenWidth, i2), this;
  }
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new G(this, t2)), this;
  }
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  drag(t2) {
    return this.plugins.add("drag", new U(this, t2)), this;
  }
  clamp(t2) {
    return this.plugins.add("clamp", new A(this, t2)), this;
  }
  decelerate(t2) {
    return this.plugins.add("decelerate", new E(this, t2)), this;
  }
  bounce(t2) {
    return this.plugins.add("bounce", new X(this, t2)), this;
  }
  pinch(t2) {
    return this.plugins.add("pinch", new R(this, t2)), this;
  }
  snap(t2, i2, e3) {
    return this.plugins.add("snap", new q(this, t2, i2, e3)), this;
  }
  follow(t2, i2) {
    return this.plugins.add("follow", new F(this, t2, i2)), this;
  }
  wheel(t2) {
    return this.plugins.add("wheel", new J(this, t2)), this;
  }
  animate(t2) {
    return this.plugins.add("animate", new k$1(this, t2)), this;
  }
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new T(this, t2)), this;
  }
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new N(this, t2)), this;
  }
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  ensureVisible(t2, i2, e3, n2, s2) {
    s2 && (e3 > this.worldScreenWidth || n2 > this.worldScreenHeight) && (this.fit(true, e3, n2), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + e3 > this.right && (this.right = t2 + e3, h2 = true), i2 < this.top ? (this.top = i2, h2 = true) : i2 + n2 > this.bottom && (this.bottom = i2 + n2, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
}
const _PixiViewport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animate: k$1,
  Bounce: X,
  Clamp: A,
  ClampZoom: T,
  Decelerate: E,
  Drag: U,
  Follow: F,
  InputManager: $,
  MouseEdges: N,
  Pinch: R,
  Plugin: f$1,
  PluginManager: tt,
  Snap: q,
  SnapZoom: G,
  Viewport: ht,
  Wheel: J
}, Symbol.toStringTag, { value: "Module" }));
var howler = {};
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(exports) {
  (function() {
    var HowlerGlobal2 = function() {
      this.init();
    };
    HowlerGlobal2.prototype = {
      /**
       * Initialize the global Howler object.
       * @return {Howler}
       */
      init: function() {
        var self2 = this || Howler2;
        self2._counter = 1e3;
        self2._html5AudioPool = [];
        self2.html5PoolSize = 10;
        self2._codecs = {};
        self2._howls = [];
        self2._muted = false;
        self2._volume = 1;
        self2._canPlayEvent = "canplaythrough";
        self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
        self2.masterGain = null;
        self2.noAudio = false;
        self2.usingWebAudio = true;
        self2.autoSuspend = true;
        self2.ctx = null;
        self2.autoUnlock = true;
        self2._setup();
        return self2;
      },
      /**
       * Get/set the global volume for all sounds.
       * @param  {Float} vol Volume from 0.0 to 1.0.
       * @return {Howler/Float}     Returns self or current volume.
       */
      volume: function(vol) {
        var self2 = this || Howler2;
        vol = parseFloat(vol);
        if (!self2.ctx) {
          setupAudioContext();
        }
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          self2._volume = vol;
          if (self2._muted) {
            return self2;
          }
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
          }
          for (var i2 = 0; i2 < self2._howls.length; i2++) {
            if (!self2._howls[i2]._webAudio) {
              var ids = self2._howls[i2]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self2._howls[i2]._soundById(ids[j2]);
                if (sound && sound._node) {
                  sound._node.volume = sound._volume * vol;
                }
              }
            }
          }
          return self2;
        }
        return self2._volume;
      },
      /**
       * Handle muting and unmuting globally.
       * @param  {Boolean} muted Is muted or not.
       */
      mute: function(muted) {
        var self2 = this || Howler2;
        if (!self2.ctx) {
          setupAudioContext();
        }
        self2._muted = muted;
        if (self2.usingWebAudio) {
          self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler2.ctx.currentTime);
        }
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          if (!self2._howls[i2]._webAudio) {
            var ids = self2._howls[i2]._getSoundIds();
            for (var j2 = 0; j2 < ids.length; j2++) {
              var sound = self2._howls[i2]._soundById(ids[j2]);
              if (sound && sound._node) {
                sound._node.muted = muted ? true : sound._muted;
              }
            }
          }
        }
        return self2;
      },
      /**
       * Handle stopping all sounds globally.
       */
      stop: function() {
        var self2 = this || Howler2;
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          self2._howls[i2].stop();
        }
        return self2;
      },
      /**
       * Unload and destroy all currently loaded Howl objects.
       * @return {Howler}
       */
      unload: function() {
        var self2 = this || Howler2;
        for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
          self2._howls[i2].unload();
        }
        if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
          self2.ctx.close();
          self2.ctx = null;
          setupAudioContext();
        }
        return self2;
      },
      /**
       * Check for codec support of specific extension.
       * @param  {String} ext Audio file extention.
       * @return {Boolean}
       */
      codecs: function(ext2) {
        return (this || Howler2)._codecs[ext2.replace(/^x-/, "")];
      },
      /**
       * Setup various state values for global tracking.
       * @return {Howler}
       */
      _setup: function() {
        var self2 = this || Howler2;
        self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
        self2._autoSuspend();
        if (!self2.usingWebAudio) {
          if (typeof Audio !== "undefined") {
            try {
              var test = new Audio();
              if (typeof test.oncanplaythrough === "undefined") {
                self2._canPlayEvent = "canplay";
              }
            } catch (e3) {
              self2.noAudio = true;
            }
          } else {
            self2.noAudio = true;
          }
        }
        try {
          var test = new Audio();
          if (test.muted) {
            self2.noAudio = true;
          }
        } catch (e3) {
        }
        if (!self2.noAudio) {
          self2._setupCodecs();
        }
        return self2;
      },
      /**
       * Check for browser support for various codecs and cache the results.
       * @return {Howler}
       */
      _setupCodecs: function() {
        var self2 = this || Howler2;
        var audioTest = null;
        try {
          audioTest = typeof Audio !== "undefined" ? new Audio() : null;
        } catch (err) {
          return self2;
        }
        if (!audioTest || typeof audioTest.canPlayType !== "function") {
          return self2;
        }
        var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
        var ua = self2._navigator ? self2._navigator.userAgent : "";
        var checkOpera = ua.match(/OPR\/([0-6].)/g);
        var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
        var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
        var safariVersion = ua.match(/Version\/(.*?) /);
        var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
        self2._codecs = {
          mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
          mpeg: !!mpegTest,
          opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
          aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
          dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
        };
        return self2;
      },
      /**
       * Some browsers/devices will only allow audio to be played after a user interaction.
       * Attempt to automatically unlock audio on the first user interaction.
       * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
       * @return {Howler}
       */
      _unlockAudio: function() {
        var self2 = this || Howler2;
        if (self2._audioUnlocked || !self2.ctx) {
          return;
        }
        self2._audioUnlocked = false;
        self2.autoUnlock = false;
        if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
          self2._mobileUnloaded = true;
          self2.unload();
        }
        self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
        var unlock = function(e3) {
          while (self2._html5AudioPool.length < self2.html5PoolSize) {
            try {
              var audioNode = new Audio();
              audioNode._unlocked = true;
              self2._releaseHtml5Audio(audioNode);
            } catch (e4) {
              self2.noAudio = true;
              break;
            }
          }
          for (var i2 = 0; i2 < self2._howls.length; i2++) {
            if (!self2._howls[i2]._webAudio) {
              var ids = self2._howls[i2]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self2._howls[i2]._soundById(ids[j2]);
                if (sound && sound._node && !sound._node._unlocked) {
                  sound._node._unlocked = true;
                  sound._node.load();
                }
              }
            }
          }
          self2._autoResume();
          var source = self2.ctx.createBufferSource();
          source.buffer = self2._scratchBuffer;
          source.connect(self2.ctx.destination);
          if (typeof source.start === "undefined") {
            source.noteOn(0);
          } else {
            source.start(0);
          }
          if (typeof self2.ctx.resume === "function") {
            self2.ctx.resume();
          }
          source.onended = function() {
            source.disconnect(0);
            self2._audioUnlocked = true;
            document.removeEventListener("touchstart", unlock, true);
            document.removeEventListener("touchend", unlock, true);
            document.removeEventListener("click", unlock, true);
            document.removeEventListener("keydown", unlock, true);
            for (var i3 = 0; i3 < self2._howls.length; i3++) {
              self2._howls[i3]._emit("unlock");
            }
          };
        };
        document.addEventListener("touchstart", unlock, true);
        document.addEventListener("touchend", unlock, true);
        document.addEventListener("click", unlock, true);
        document.addEventListener("keydown", unlock, true);
        return self2;
      },
      /**
       * Get an unlocked HTML5 Audio object from the pool. If none are left,
       * return a new Audio object and throw a warning.
       * @return {Audio} HTML5 Audio object.
       */
      _obtainHtml5Audio: function() {
        var self2 = this || Howler2;
        if (self2._html5AudioPool.length) {
          return self2._html5AudioPool.pop();
        }
        var testPlay = new Audio().play();
        if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
          testPlay.catch(function() {
            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
          });
        }
        return new Audio();
      },
      /**
       * Return an activated HTML5 Audio object to the pool.
       * @return {Howler}
       */
      _releaseHtml5Audio: function(audio) {
        var self2 = this || Howler2;
        if (audio._unlocked) {
          self2._html5AudioPool.push(audio);
        }
        return self2;
      },
      /**
       * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
       * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
       * @return {Howler}
       */
      _autoSuspend: function() {
        var self2 = this;
        if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        for (var i2 = 0; i2 < self2._howls.length; i2++) {
          if (self2._howls[i2]._webAudio) {
            for (var j2 = 0; j2 < self2._howls[i2]._sounds.length; j2++) {
              if (!self2._howls[i2]._sounds[j2]._paused) {
                return self2;
              }
            }
          }
        }
        if (self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
        }
        self2._suspendTimer = setTimeout(function() {
          if (!self2.autoSuspend) {
            return;
          }
          self2._suspendTimer = null;
          self2.state = "suspending";
          var handleSuspension = function() {
            self2.state = "suspended";
            if (self2._resumeAfterSuspend) {
              delete self2._resumeAfterSuspend;
              self2._autoResume();
            }
          };
          self2.ctx.suspend().then(handleSuspension, handleSuspension);
        }, 3e4);
        return self2;
      },
      /**
       * Automatically resume the Web Audio AudioContext when a new sound is played.
       * @return {Howler}
       */
      _autoResume: function() {
        var self2 = this;
        if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
          return;
        }
        if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
          clearTimeout(self2._suspendTimer);
          self2._suspendTimer = null;
        } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
          self2.ctx.resume().then(function() {
            self2.state = "running";
            for (var i2 = 0; i2 < self2._howls.length; i2++) {
              self2._howls[i2]._emit("resume");
            }
          });
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          }
        } else if (self2.state === "suspending") {
          self2._resumeAfterSuspend = true;
        }
        return self2;
      }
    };
    var Howler2 = new HowlerGlobal2();
    var Howl2 = function(o2) {
      var self2 = this;
      if (!o2.src || o2.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      self2.init(o2);
    };
    Howl2.prototype = {
      /**
       * Initialize a new Howl group object.
       * @param  {Object} o Passed in properties for this group.
       * @return {Howl}
       */
      init: function(o2) {
        var self2 = this;
        if (!Howler2.ctx) {
          setupAudioContext();
        }
        self2._autoplay = o2.autoplay || false;
        self2._format = typeof o2.format !== "string" ? o2.format : [o2.format];
        self2._html5 = o2.html5 || false;
        self2._muted = o2.mute || false;
        self2._loop = o2.loop || false;
        self2._pool = o2.pool || 5;
        self2._preload = typeof o2.preload === "boolean" || o2.preload === "metadata" ? o2.preload : true;
        self2._rate = o2.rate || 1;
        self2._sprite = o2.sprite || {};
        self2._src = typeof o2.src !== "string" ? o2.src : [o2.src];
        self2._volume = o2.volume !== void 0 ? o2.volume : 1;
        self2._xhr = {
          method: o2.xhr && o2.xhr.method ? o2.xhr.method : "GET",
          headers: o2.xhr && o2.xhr.headers ? o2.xhr.headers : null,
          withCredentials: o2.xhr && o2.xhr.withCredentials ? o2.xhr.withCredentials : false
        };
        self2._duration = 0;
        self2._state = "unloaded";
        self2._sounds = [];
        self2._endTimers = {};
        self2._queue = [];
        self2._playLock = false;
        self2._onend = o2.onend ? [{ fn: o2.onend }] : [];
        self2._onfade = o2.onfade ? [{ fn: o2.onfade }] : [];
        self2._onload = o2.onload ? [{ fn: o2.onload }] : [];
        self2._onloaderror = o2.onloaderror ? [{ fn: o2.onloaderror }] : [];
        self2._onplayerror = o2.onplayerror ? [{ fn: o2.onplayerror }] : [];
        self2._onpause = o2.onpause ? [{ fn: o2.onpause }] : [];
        self2._onplay = o2.onplay ? [{ fn: o2.onplay }] : [];
        self2._onstop = o2.onstop ? [{ fn: o2.onstop }] : [];
        self2._onmute = o2.onmute ? [{ fn: o2.onmute }] : [];
        self2._onvolume = o2.onvolume ? [{ fn: o2.onvolume }] : [];
        self2._onrate = o2.onrate ? [{ fn: o2.onrate }] : [];
        self2._onseek = o2.onseek ? [{ fn: o2.onseek }] : [];
        self2._onunlock = o2.onunlock ? [{ fn: o2.onunlock }] : [];
        self2._onresume = [];
        self2._webAudio = Howler2.usingWebAudio && !self2._html5;
        if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
          Howler2._unlockAudio();
        }
        Howler2._howls.push(self2);
        if (self2._autoplay) {
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play();
            }
          });
        }
        if (self2._preload && self2._preload !== "none") {
          self2.load();
        }
        return self2;
      },
      /**
       * Load the audio file.
       * @return {Howler}
       */
      load: function() {
        var self2 = this;
        var url2 = null;
        if (Howler2.noAudio) {
          self2._emit("loaderror", null, "No audio support.");
          return;
        }
        if (typeof self2._src === "string") {
          self2._src = [self2._src];
        }
        for (var i2 = 0; i2 < self2._src.length; i2++) {
          var ext2, str2;
          if (self2._format && self2._format[i2]) {
            ext2 = self2._format[i2];
          } else {
            str2 = self2._src[i2];
            if (typeof str2 !== "string") {
              self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
              continue;
            }
            ext2 = /^data:audio\/([^;,]+);/i.exec(str2);
            if (!ext2) {
              ext2 = /\.([^.]+)$/.exec(str2.split("?", 1)[0]);
            }
            if (ext2) {
              ext2 = ext2[1].toLowerCase();
            }
          }
          if (!ext2) {
            console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
          }
          if (ext2 && Howler2.codecs(ext2)) {
            url2 = self2._src[i2];
            break;
          }
        }
        if (!url2) {
          self2._emit("loaderror", null, "No codec support for selected audio sources.");
          return;
        }
        self2._src = url2;
        self2._state = "loading";
        if (window.location.protocol === "https:" && url2.slice(0, 5) === "http:") {
          self2._html5 = true;
          self2._webAudio = false;
        }
        new Sound2(self2);
        if (self2._webAudio) {
          loadBuffer(self2);
        }
        return self2;
      },
      /**
       * Play a sound or resume previous playback.
       * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Number}          Sound ID.
       */
      play: function(sprite2, internal) {
        var self2 = this;
        var id = null;
        if (typeof sprite2 === "number") {
          id = sprite2;
          sprite2 = null;
        } else if (typeof sprite2 === "string" && self2._state === "loaded" && !self2._sprite[sprite2]) {
          return null;
        } else if (typeof sprite2 === "undefined") {
          sprite2 = "__default";
          if (!self2._playLock) {
            var num = 0;
            for (var i2 = 0; i2 < self2._sounds.length; i2++) {
              if (self2._sounds[i2]._paused && !self2._sounds[i2]._ended) {
                num++;
                id = self2._sounds[i2]._id;
              }
            }
            if (num === 1) {
              sprite2 = null;
            } else {
              id = null;
            }
          }
        }
        var sound = id ? self2._soundById(id) : self2._inactiveSound();
        if (!sound) {
          return null;
        }
        if (id && !sprite2) {
          sprite2 = sound._sprite || "__default";
        }
        if (self2._state !== "loaded") {
          sound._sprite = sprite2;
          sound._ended = false;
          var soundId = sound._id;
          self2._queue.push({
            event: "play",
            action: function() {
              self2.play(soundId);
            }
          });
          return soundId;
        }
        if (id && !sound._paused) {
          if (!internal) {
            self2._loadQueue("play");
          }
          return sound._id;
        }
        if (self2._webAudio) {
          Howler2._autoResume();
        }
        var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite2][0] / 1e3);
        var duration = Math.max(0, (self2._sprite[sprite2][0] + self2._sprite[sprite2][1]) / 1e3 - seek);
        var timeout = duration * 1e3 / Math.abs(sound._rate);
        var start = self2._sprite[sprite2][0] / 1e3;
        var stop = (self2._sprite[sprite2][0] + self2._sprite[sprite2][1]) / 1e3;
        sound._sprite = sprite2;
        sound._ended = false;
        var setParams = function() {
          sound._paused = false;
          sound._seek = seek;
          sound._start = start;
          sound._stop = stop;
          sound._loop = !!(sound._loop || self2._sprite[sprite2][2]);
        };
        if (seek >= stop) {
          self2._ended(sound);
          return;
        }
        var node = sound._node;
        if (self2._webAudio) {
          var playWebAudio = function() {
            self2._playLock = false;
            setParams();
            self2._refreshBuffer(sound);
            var vol = sound._muted || self2._muted ? 0 : sound._volume;
            node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            sound._playStart = Howler2.ctx.currentTime;
            if (typeof node.bufferSource.start === "undefined") {
              sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
            } else {
              sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
            }
            if (timeout !== Infinity) {
              self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
            }
            if (!internal) {
              setTimeout(function() {
                self2._emit("play", sound._id);
                self2._loadQueue();
              }, 0);
            }
          };
          if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
            playWebAudio();
          } else {
            self2._playLock = true;
            self2.once("resume", playWebAudio);
            self2._clearTimer(sound._id);
          }
        } else {
          var playHtml5 = function() {
            node.currentTime = seek;
            node.muted = sound._muted || self2._muted || Howler2._muted || node.muted;
            node.volume = sound._volume * Howler2.volume();
            node.playbackRate = sound._rate;
            try {
              var play = node.play();
              if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                self2._playLock = true;
                setParams();
                play.then(function() {
                  self2._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self2._emit("play", sound._id);
                  } else {
                    self2._loadQueue();
                  }
                }).catch(function() {
                  self2._playLock = false;
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  sound._ended = true;
                  sound._paused = true;
                });
              } else if (!internal) {
                self2._playLock = false;
                setParams();
                self2._emit("play", sound._id);
              }
              node.playbackRate = sound._rate;
              if (node.paused) {
                self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                return;
              }
              if (sprite2 !== "__default" || sound._loop) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
              } else {
                self2._endTimers[sound._id] = function() {
                  self2._ended(sound);
                  node.removeEventListener("ended", self2._endTimers[sound._id], false);
                };
                node.addEventListener("ended", self2._endTimers[sound._id], false);
              }
            } catch (err) {
              self2._emit("playerror", sound._id, err);
            }
          };
          if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
            node.src = self2._src;
            node.load();
          }
          var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
          if (node.readyState >= 3 || loadedNoReadyState) {
            playHtml5();
          } else {
            self2._playLock = true;
            self2._state = "loading";
            var listener = function() {
              self2._state = "loaded";
              playHtml5();
              node.removeEventListener(Howler2._canPlayEvent, listener, false);
            };
            node.addEventListener(Howler2._canPlayEvent, listener, false);
            self2._clearTimer(sound._id);
          }
        }
        return sound._id;
      },
      /**
       * Pause playback and save current position.
       * @param  {Number} id The sound ID (empty to pause all in group).
       * @return {Howl}
       */
      pause: function(id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "pause",
            action: function() {
              self2.pause(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          self2._clearTimer(ids[i2]);
          var sound = self2._soundById(ids[i2]);
          if (sound && !sound._paused) {
            sound._seek = self2.seek(ids[i2]);
            sound._rateSeek = 0;
            sound._paused = true;
            self2._stopFade(ids[i2]);
            if (sound._node) {
              if (self2._webAudio) {
                if (!sound._node.bufferSource) {
                  continue;
                }
                if (typeof sound._node.bufferSource.stop === "undefined") {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }
                self2._cleanBuffer(sound._node);
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.pause();
              }
            }
          }
          if (!arguments[1]) {
            self2._emit("pause", sound ? sound._id : null);
          }
        }
        return self2;
      },
      /**
       * Stop playback and reset to start.
       * @param  {Number} id The sound ID (empty to stop all in group).
       * @param  {Boolean} internal Internal Use: true prevents event firing.
       * @return {Howl}
       */
      stop: function(id, internal) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "stop",
            action: function() {
              self2.stop(id);
            }
          });
          return self2;
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          self2._clearTimer(ids[i2]);
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._paused = true;
            sound._ended = true;
            self2._stopFade(ids[i2]);
            if (sound._node) {
              if (self2._webAudio) {
                if (sound._node.bufferSource) {
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                }
              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                sound._node.currentTime = sound._start || 0;
                sound._node.pause();
                if (sound._node.duration === Infinity) {
                  self2._clearSound(sound._node);
                }
              }
            }
            if (!internal) {
              self2._emit("stop", sound._id);
            }
          }
        }
        return self2;
      },
      /**
       * Mute/unmute a single sound or all sounds in this Howl group.
       * @param  {Boolean} muted Set to true to mute and false to unmute.
       * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
       * @return {Howl}
       */
      mute: function(muted, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "mute",
            action: function() {
              self2.mute(muted, id);
            }
          });
          return self2;
        }
        if (typeof id === "undefined") {
          if (typeof muted === "boolean") {
            self2._muted = muted;
          } else {
            return self2._muted;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._muted = muted;
            if (sound._interval) {
              self2._stopFade(sound._id);
            }
            if (self2._webAudio && sound._node) {
              sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
            } else if (sound._node) {
              sound._node.muted = Howler2._muted ? true : muted;
            }
            self2._emit("mute", sound._id);
          }
        }
        return self2;
      },
      /**
       * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
       *   volume() -> Returns the group's volume value.
       *   volume(id) -> Returns the sound id's current volume.
       *   volume(vol) -> Sets the volume of all sounds in this Howl group.
       *   volume(vol, id) -> Sets the volume of passed sound id.
       * @return {Howl/Number} Returns self or current volume.
       */
      volume: function() {
        var self2 = this;
        var args = arguments;
        var vol, id;
        if (args.length === 0) {
          return self2._volume;
        } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            vol = parseFloat(args[0]);
          }
        } else if (args.length >= 2) {
          vol = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "volume",
              action: function() {
                self2.volume.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._volume = vol;
          }
          id = self2._getSoundIds(id);
          for (var i2 = 0; i2 < id.length; i2++) {
            sound = self2._soundById(id[i2]);
            if (sound) {
              sound._volume = vol;
              if (!args[2]) {
                self2._stopFade(id[i2]);
              }
              if (self2._webAudio && sound._node && !sound._muted) {
                sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              } else if (sound._node && !sound._muted) {
                sound._node.volume = vol * Howler2.volume();
              }
              self2._emit("volume", sound._id);
            }
          }
        } else {
          sound = id ? self2._soundById(id) : self2._sounds[0];
          return sound ? sound._volume : 0;
        }
        return self2;
      },
      /**
       * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id (omit to fade all sounds).
       * @return {Howl}
       */
      fade: function(from2, to, len, id) {
        var self2 = this;
        if (self2._state !== "loaded" || self2._playLock) {
          self2._queue.push({
            event: "fade",
            action: function() {
              self2.fade(from2, to, len, id);
            }
          });
          return self2;
        }
        from2 = Math.min(Math.max(0, parseFloat(from2)), 1);
        to = Math.min(Math.max(0, parseFloat(to)), 1);
        len = parseFloat(len);
        self2.volume(from2, id);
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          var sound = self2._soundById(ids[i2]);
          if (sound) {
            if (!id) {
              self2._stopFade(ids[i2]);
            }
            if (self2._webAudio && !sound._muted) {
              var currentTime = Howler2.ctx.currentTime;
              var end = currentTime + len / 1e3;
              sound._volume = from2;
              sound._node.gain.setValueAtTime(from2, currentTime);
              sound._node.gain.linearRampToValueAtTime(to, end);
            }
            self2._startFadeInterval(sound, from2, to, len, ids[i2], typeof id === "undefined");
          }
        }
        return self2;
      },
      /**
       * Starts the internal interval to fade a sound.
       * @param  {Object} sound Reference to sound to fade.
       * @param  {Number} from The value to fade from (0.0 to 1.0).
       * @param  {Number} to   The volume to fade to (0.0 to 1.0).
       * @param  {Number} len  Time in milliseconds to fade.
       * @param  {Number} id   The sound id to fade.
       * @param  {Boolean} isGroup   If true, set the volume on the group.
       */
      _startFadeInterval: function(sound, from2, to, len, id, isGroup) {
        var self2 = this;
        var vol = from2;
        var diff = to - from2;
        var steps = Math.abs(diff / 0.01);
        var stepLen = Math.max(4, steps > 0 ? len / steps : len);
        var lastTick = Date.now();
        sound._fadeTo = to;
        sound._interval = setInterval(function() {
          var tick = (Date.now() - lastTick) / len;
          lastTick = Date.now();
          vol += diff * tick;
          vol = Math.round(vol * 100) / 100;
          if (diff < 0) {
            vol = Math.max(to, vol);
          } else {
            vol = Math.min(to, vol);
          }
          if (self2._webAudio) {
            sound._volume = vol;
          } else {
            self2.volume(vol, sound._id, true);
          }
          if (isGroup) {
            self2._volume = vol;
          }
          if (to < from2 && vol <= to || to > from2 && vol >= to) {
            clearInterval(sound._interval);
            sound._interval = null;
            sound._fadeTo = null;
            self2.volume(to, sound._id);
            self2._emit("fade", sound._id);
          }
        }, stepLen);
      },
      /**
       * Internal method that stops the currently playing fade when
       * a new fade starts, volume is changed or the sound is stopped.
       * @param  {Number} id The sound id.
       * @return {Howl}
       */
      _stopFade: function(id) {
        var self2 = this;
        var sound = self2._soundById(id);
        if (sound && sound._interval) {
          if (self2._webAudio) {
            sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
          }
          clearInterval(sound._interval);
          sound._interval = null;
          self2.volume(sound._fadeTo, id);
          sound._fadeTo = null;
          self2._emit("fade", id);
        }
        return self2;
      },
      /**
       * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
       *   loop() -> Returns the group's loop value.
       *   loop(id) -> Returns the sound id's loop value.
       *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
       *   loop(loop, id) -> Sets the loop value of passed sound id.
       * @return {Howl/Boolean} Returns self or current loop value.
       */
      loop: function() {
        var self2 = this;
        var args = arguments;
        var loop, id, sound;
        if (args.length === 0) {
          return self2._loop;
        } else if (args.length === 1) {
          if (typeof args[0] === "boolean") {
            loop = args[0];
            self2._loop = loop;
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._loop : false;
          }
        } else if (args.length === 2) {
          loop = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i2 = 0; i2 < ids.length; i2++) {
          sound = self2._soundById(ids[i2]);
          if (sound) {
            sound._loop = loop;
            if (self2._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.loop = loop;
              if (loop) {
                sound._node.bufferSource.loopStart = sound._start || 0;
                sound._node.bufferSource.loopEnd = sound._stop;
                if (self2.playing(ids[i2])) {
                  self2.pause(ids[i2], true);
                  self2.play(ids[i2], true);
                }
              }
            }
          }
        }
        return self2;
      },
      /**
       * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   rate() -> Returns the first sound node's current playback rate.
       *   rate(id) -> Returns the sound id's current playback rate.
       *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
       *   rate(rate, id) -> Sets the playback rate of passed sound id.
       * @return {Howl/Number} Returns self or the current playback rate.
       */
      rate: function() {
        var self2 = this;
        var args = arguments;
        var rate, id;
        if (args.length === 0) {
          id = self2._sounds[0]._id;
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else {
            rate = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          rate = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        var sound;
        if (typeof rate === "number") {
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "rate",
              action: function() {
                self2.rate.apply(self2, args);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            self2._rate = rate;
          }
          id = self2._getSoundIds(id);
          for (var i2 = 0; i2 < id.length; i2++) {
            sound = self2._soundById(id[i2]);
            if (sound) {
              if (self2.playing(id[i2])) {
                sound._rateSeek = self2.seek(id[i2]);
                sound._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound._playStart;
              }
              sound._rate = rate;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.playbackRate = rate;
              }
              var seek = self2.seek(id[i2]);
              var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
              var timeout = duration * 1e3 / Math.abs(sound._rate);
              if (self2._endTimers[id[i2]] || !sound._paused) {
                self2._clearTimer(id[i2]);
                self2._endTimers[id[i2]] = setTimeout(self2._ended.bind(self2, sound), timeout);
              }
              self2._emit("rate", sound._id);
            }
          }
        } else {
          sound = self2._soundById(id);
          return sound ? sound._rate : self2._rate;
        }
        return self2;
      },
      /**
       * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
       *   seek() -> Returns the first sound node's current seek position.
       *   seek(id) -> Returns the sound id's current seek position.
       *   seek(seek) -> Sets the seek position of the first sound node.
       *   seek(seek, id) -> Sets the seek position of passed sound id.
       * @return {Howl/Number} Returns self or the current seek position.
       */
      seek: function() {
        var self2 = this;
        var args = arguments;
        var seek, id;
        if (args.length === 0) {
          if (self2._sounds.length) {
            id = self2._sounds[0]._id;
          }
        } else if (args.length === 1) {
          var ids = self2._getSoundIds();
          var index2 = ids.indexOf(args[0]);
          if (index2 >= 0) {
            id = parseInt(args[0], 10);
          } else if (self2._sounds.length) {
            id = self2._sounds[0]._id;
            seek = parseFloat(args[0]);
          }
        } else if (args.length === 2) {
          seek = parseFloat(args[0]);
          id = parseInt(args[1], 10);
        }
        if (typeof id === "undefined") {
          return 0;
        }
        if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
          self2._queue.push({
            event: "seek",
            action: function() {
              self2.seek.apply(self2, args);
            }
          });
          return self2;
        }
        var sound = self2._soundById(id);
        if (sound) {
          if (typeof seek === "number" && seek >= 0) {
            var playing = self2.playing(id);
            if (playing) {
              self2.pause(id, true);
            }
            sound._seek = seek;
            sound._ended = false;
            self2._clearTimer(id);
            if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
              sound._node.currentTime = seek;
            }
            var seekAndEmit = function() {
              if (playing) {
                self2.play(id, true);
              }
              self2._emit("seek", id);
            };
            if (playing && !self2._webAudio) {
              var emitSeek = function() {
                if (!self2._playLock) {
                  seekAndEmit();
                } else {
                  setTimeout(emitSeek, 0);
                }
              };
              setTimeout(emitSeek, 0);
            } else {
              seekAndEmit();
            }
          } else {
            if (self2._webAudio) {
              var realTime = self2.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
              var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
              return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
            } else {
              return sound._node.currentTime;
            }
          }
        }
        return self2;
      },
      /**
       * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
       * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
       * @return {Boolean} True if playing and false if not.
       */
      playing: function(id) {
        var self2 = this;
        if (typeof id === "number") {
          var sound = self2._soundById(id);
          return sound ? !sound._paused : false;
        }
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (!self2._sounds[i2]._paused) {
            return true;
          }
        }
        return false;
      },
      /**
       * Get the duration of this sound. Passing a sound id will return the sprite duration.
       * @param  {Number} id The sound id to check. If none is passed, return full source duration.
       * @return {Number} Audio duration in seconds.
       */
      duration: function(id) {
        var self2 = this;
        var duration = self2._duration;
        var sound = self2._soundById(id);
        if (sound) {
          duration = self2._sprite[sound._sprite][1] / 1e3;
        }
        return duration;
      },
      /**
       * Returns the current loaded state of this Howl.
       * @return {String} 'unloaded', 'loading', 'loaded'
       */
      state: function() {
        return this._state;
      },
      /**
       * Unload and destroy the current Howl object.
       * This will immediately stop all sound instances attached to this group.
       */
      unload: function() {
        var self2 = this;
        var sounds2 = self2._sounds;
        for (var i2 = 0; i2 < sounds2.length; i2++) {
          if (!sounds2[i2]._paused) {
            self2.stop(sounds2[i2]._id);
          }
          if (!self2._webAudio) {
            self2._clearSound(sounds2[i2]._node);
            sounds2[i2]._node.removeEventListener("error", sounds2[i2]._errorFn, false);
            sounds2[i2]._node.removeEventListener(Howler2._canPlayEvent, sounds2[i2]._loadFn, false);
            sounds2[i2]._node.removeEventListener("ended", sounds2[i2]._endFn, false);
            Howler2._releaseHtml5Audio(sounds2[i2]._node);
          }
          delete sounds2[i2]._node;
          self2._clearTimer(sounds2[i2]._id);
        }
        var index2 = Howler2._howls.indexOf(self2);
        if (index2 >= 0) {
          Howler2._howls.splice(index2, 1);
        }
        var remCache = true;
        for (i2 = 0; i2 < Howler2._howls.length; i2++) {
          if (Howler2._howls[i2]._src === self2._src || self2._src.indexOf(Howler2._howls[i2]._src) >= 0) {
            remCache = false;
            break;
          }
        }
        if (cache && remCache) {
          delete cache[self2._src];
        }
        Howler2.noAudio = false;
        self2._state = "unloaded";
        self2._sounds = [];
        self2 = null;
        return null;
      },
      /**
       * Listen to a custom event.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
       * @return {Howl}
       */
      on: function(event, fn, id, once3) {
        var self2 = this;
        var events2 = self2["_on" + event];
        if (typeof fn === "function") {
          events2.push(once3 ? { id, fn, once: once3 } : { id, fn });
        }
        return self2;
      },
      /**
       * Remove a custom event. Call without parameters to remove all events.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to remove. Leave empty to remove all.
       * @param  {Number}   id    (optional) Only remove events for this sound.
       * @return {Howl}
       */
      off: function(event, fn, id) {
        var self2 = this;
        var events2 = self2["_on" + event];
        var i2 = 0;
        if (typeof fn === "number") {
          id = fn;
          fn = null;
        }
        if (fn || id) {
          for (i2 = 0; i2 < events2.length; i2++) {
            var isId = id === events2[i2].id;
            if (fn === events2[i2].fn && isId || !fn && isId) {
              events2.splice(i2, 1);
              break;
            }
          }
        } else if (event) {
          self2["_on" + event] = [];
        } else {
          var keys2 = Object.keys(self2);
          for (i2 = 0; i2 < keys2.length; i2++) {
            if (keys2[i2].indexOf("_on") === 0 && Array.isArray(self2[keys2[i2]])) {
              self2[keys2[i2]] = [];
            }
          }
        }
        return self2;
      },
      /**
       * Listen to a custom event and remove it once fired.
       * @param  {String}   event Event name.
       * @param  {Function} fn    Listener to call.
       * @param  {Number}   id    (optional) Only listen to events for this sound.
       * @return {Howl}
       */
      once: function(event, fn, id) {
        var self2 = this;
        self2.on(event, fn, id, 1);
        return self2;
      },
      /**
       * Emit all events of a specific type and pass the sound id.
       * @param  {String} event Event name.
       * @param  {Number} id    Sound ID.
       * @param  {Number} msg   Message to go with event.
       * @return {Howl}
       */
      _emit: function(event, id, msg) {
        var self2 = this;
        var events2 = self2["_on" + event];
        for (var i2 = events2.length - 1; i2 >= 0; i2--) {
          if (!events2[i2].id || events2[i2].id === id || event === "load") {
            setTimeout(function(fn) {
              fn.call(this, id, msg);
            }.bind(self2, events2[i2].fn), 0);
            if (events2[i2].once) {
              self2.off(event, events2[i2].fn, events2[i2].id);
            }
          }
        }
        self2._loadQueue(event);
        return self2;
      },
      /**
       * Queue of actions initiated before the sound has loaded.
       * These will be called in sequence, with the next only firing
       * after the previous has finished executing (even if async like play).
       * @return {Howl}
       */
      _loadQueue: function(event) {
        var self2 = this;
        if (self2._queue.length > 0) {
          var task = self2._queue[0];
          if (task.event === event) {
            self2._queue.shift();
            self2._loadQueue();
          }
          if (!event) {
            task.action();
          }
        }
        return self2;
      },
      /**
       * Fired when playback ends at the end of the duration.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _ended: function(sound) {
        var self2 = this;
        var sprite2 = sound._sprite;
        if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
          setTimeout(self2._ended.bind(self2, sound), 100);
          return self2;
        }
        var loop = !!(sound._loop || self2._sprite[sprite2][2]);
        self2._emit("end", sound._id);
        if (!self2._webAudio && loop) {
          self2.stop(sound._id, true).play(sound._id);
        }
        if (self2._webAudio && loop) {
          self2._emit("play", sound._id);
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._playStart = Howler2.ctx.currentTime;
          var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
          self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
        }
        if (self2._webAudio && !loop) {
          sound._paused = true;
          sound._ended = true;
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          self2._clearTimer(sound._id);
          self2._cleanBuffer(sound._node);
          Howler2._autoSuspend();
        }
        if (!self2._webAudio && !loop) {
          self2.stop(sound._id, true);
        }
        return self2;
      },
      /**
       * Clear the end timer for a sound playback.
       * @param  {Number} id The sound ID.
       * @return {Howl}
       */
      _clearTimer: function(id) {
        var self2 = this;
        if (self2._endTimers[id]) {
          if (typeof self2._endTimers[id] !== "function") {
            clearTimeout(self2._endTimers[id]);
          } else {
            var sound = self2._soundById(id);
            if (sound && sound._node) {
              sound._node.removeEventListener("ended", self2._endTimers[id], false);
            }
          }
          delete self2._endTimers[id];
        }
        return self2;
      },
      /**
       * Return the sound identified by this ID, or return null.
       * @param  {Number} id Sound ID
       * @return {Object}    Sound object or null.
       */
      _soundById: function(id) {
        var self2 = this;
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (id === self2._sounds[i2]._id) {
            return self2._sounds[i2];
          }
        }
        return null;
      },
      /**
       * Return an inactive sound from the pool or create a new one.
       * @return {Sound} Sound playback object.
       */
      _inactiveSound: function() {
        var self2 = this;
        self2._drain();
        for (var i2 = 0; i2 < self2._sounds.length; i2++) {
          if (self2._sounds[i2]._ended) {
            return self2._sounds[i2].reset();
          }
        }
        return new Sound2(self2);
      },
      /**
       * Drain excess inactive sounds from the pool.
       */
      _drain: function() {
        var self2 = this;
        var limit = self2._pool;
        var cnt = 0;
        var i2 = 0;
        if (self2._sounds.length < limit) {
          return;
        }
        for (i2 = 0; i2 < self2._sounds.length; i2++) {
          if (self2._sounds[i2]._ended) {
            cnt++;
          }
        }
        for (i2 = self2._sounds.length - 1; i2 >= 0; i2--) {
          if (cnt <= limit) {
            return;
          }
          if (self2._sounds[i2]._ended) {
            if (self2._webAudio && self2._sounds[i2]._node) {
              self2._sounds[i2]._node.disconnect(0);
            }
            self2._sounds.splice(i2, 1);
            cnt--;
          }
        }
      },
      /**
       * Get all ID's from the sounds pool.
       * @param  {Number} id Only return one ID if one is passed.
       * @return {Array}    Array of IDs.
       */
      _getSoundIds: function(id) {
        var self2 = this;
        if (typeof id === "undefined") {
          var ids = [];
          for (var i2 = 0; i2 < self2._sounds.length; i2++) {
            ids.push(self2._sounds[i2]._id);
          }
          return ids;
        } else {
          return [id];
        }
      },
      /**
       * Load the sound back into the buffer source.
       * @param  {Sound} sound The sound object to work with.
       * @return {Howl}
       */
      _refreshBuffer: function(sound) {
        var self2 = this;
        sound._node.bufferSource = Howler2.ctx.createBufferSource();
        sound._node.bufferSource.buffer = cache[self2._src];
        if (sound._panner) {
          sound._node.bufferSource.connect(sound._panner);
        } else {
          sound._node.bufferSource.connect(sound._node);
        }
        sound._node.bufferSource.loop = sound._loop;
        if (sound._loop) {
          sound._node.bufferSource.loopStart = sound._start || 0;
          sound._node.bufferSource.loopEnd = sound._stop || 0;
        }
        sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
        return self2;
      },
      /**
       * Prevent memory leaks by cleaning up the buffer source after playback.
       * @param  {Object} node Sound's audio node containing the buffer source.
       * @return {Howl}
       */
      _cleanBuffer: function(node) {
        var self2 = this;
        var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
        if (Howler2._scratchBuffer && node.bufferSource) {
          node.bufferSource.onended = null;
          node.bufferSource.disconnect(0);
          if (isIOS) {
            try {
              node.bufferSource.buffer = Howler2._scratchBuffer;
            } catch (e3) {
            }
          }
        }
        node.bufferSource = null;
        return self2;
      },
      /**
       * Set the source to a 0-second silence to stop any downloading (except in IE).
       * @param  {Object} node Audio node to clear.
       */
      _clearSound: function(node) {
        var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
        if (!checkIE) {
          node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        }
      }
    };
    var Sound2 = function(howl) {
      this._parent = howl;
      this.init();
    };
    Sound2.prototype = {
      /**
       * Initialize a new Sound object.
       * @return {Sound}
       */
      init: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        parent._sounds.push(self2);
        self2.create();
        return self2;
      },
      /**
       * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
       * @return {Sound}
       */
      create: function() {
        var self2 = this;
        var parent = self2._parent;
        var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
        if (parent._webAudio) {
          self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
          self2._node.paused = true;
          self2._node.connect(Howler2.masterGain);
        } else if (!Howler2.noAudio) {
          self2._node = Howler2._obtainHtml5Audio();
          self2._errorFn = self2._errorListener.bind(self2);
          self2._node.addEventListener("error", self2._errorFn, false);
          self2._loadFn = self2._loadListener.bind(self2);
          self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
          self2._endFn = self2._endListener.bind(self2);
          self2._node.addEventListener("ended", self2._endFn, false);
          self2._node.src = parent._src;
          self2._node.preload = parent._preload === true ? "auto" : parent._preload;
          self2._node.volume = volume * Howler2.volume();
          self2._node.load();
        }
        return self2;
      },
      /**
       * Reset the parameters of this sound to the original state (for recycle).
       * @return {Sound}
       */
      reset: function() {
        var self2 = this;
        var parent = self2._parent;
        self2._muted = parent._muted;
        self2._loop = parent._loop;
        self2._volume = parent._volume;
        self2._rate = parent._rate;
        self2._seek = 0;
        self2._rateSeek = 0;
        self2._paused = true;
        self2._ended = true;
        self2._sprite = "__default";
        self2._id = ++Howler2._counter;
        return self2;
      },
      /**
       * HTML5 Audio error listener callback.
       */
      _errorListener: function() {
        var self2 = this;
        self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
        self2._node.removeEventListener("error", self2._errorFn, false);
      },
      /**
       * HTML5 Audio canplaythrough listener callback.
       */
      _loadListener: function() {
        var self2 = this;
        var parent = self2._parent;
        parent._duration = Math.ceil(self2._node.duration * 10) / 10;
        if (Object.keys(parent._sprite).length === 0) {
          parent._sprite = { __default: [0, parent._duration * 1e3] };
        }
        if (parent._state !== "loaded") {
          parent._state = "loaded";
          parent._emit("load");
          parent._loadQueue();
        }
        self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
      },
      /**
       * HTML5 Audio ended listener callback.
       */
      _endListener: function() {
        var self2 = this;
        var parent = self2._parent;
        if (parent._duration === Infinity) {
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (parent._sprite.__default[1] === Infinity) {
            parent._sprite.__default[1] = parent._duration * 1e3;
          }
          parent._ended(self2);
        }
        self2._node.removeEventListener("ended", self2._endFn, false);
      }
    };
    var cache = {};
    var loadBuffer = function(self2) {
      var url2 = self2._src;
      if (cache[url2]) {
        self2._duration = cache[url2].duration;
        loadSound(self2);
        return;
      }
      if (/^data:[^;]+;base64,/.test(url2)) {
        var data = atob(url2.split(",")[1]);
        var dataView = new Uint8Array(data.length);
        for (var i2 = 0; i2 < data.length; ++i2) {
          dataView[i2] = data.charCodeAt(i2);
        }
        decodeAudioData(dataView.buffer, self2);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open(self2._xhr.method, url2, true);
        xhr.withCredentials = self2._xhr.withCredentials;
        xhr.responseType = "arraybuffer";
        if (self2._xhr.headers) {
          Object.keys(self2._xhr.headers).forEach(function(key) {
            xhr.setRequestHeader(key, self2._xhr.headers[key]);
          });
        }
        xhr.onload = function() {
          var code = (xhr.status + "")[0];
          if (code !== "0" && code !== "2" && code !== "3") {
            self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
            return;
          }
          decodeAudioData(xhr.response, self2);
        };
        xhr.onerror = function() {
          if (self2._webAudio) {
            self2._html5 = true;
            self2._webAudio = false;
            self2._sounds = [];
            delete cache[url2];
            self2.load();
          }
        };
        safeXhrSend(xhr);
      }
    };
    var safeXhrSend = function(xhr) {
      try {
        xhr.send();
      } catch (e3) {
        xhr.onerror();
      }
    };
    var decodeAudioData = function(arraybuffer, self2) {
      var error2 = function() {
        self2._emit("loaderror", null, "Decoding audio data failed.");
      };
      var success = function(buffer2) {
        if (buffer2 && self2._sounds.length > 0) {
          cache[self2._src] = buffer2;
          loadSound(self2, buffer2);
        } else {
          error2();
        }
      };
      if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
        Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error2);
      } else {
        Howler2.ctx.decodeAudioData(arraybuffer, success, error2);
      }
    };
    var loadSound = function(self2, buffer2) {
      if (buffer2 && !self2._duration) {
        self2._duration = buffer2.duration;
      }
      if (Object.keys(self2._sprite).length === 0) {
        self2._sprite = { __default: [0, self2._duration * 1e3] };
      }
      if (self2._state !== "loaded") {
        self2._state = "loaded";
        self2._emit("load");
        self2._loadQueue();
      }
    };
    var setupAudioContext = function() {
      if (!Howler2.usingWebAudio) {
        return;
      }
      try {
        if (typeof AudioContext !== "undefined") {
          Howler2.ctx = new AudioContext();
        } else if (typeof webkitAudioContext !== "undefined") {
          Howler2.ctx = new webkitAudioContext();
        } else {
          Howler2.usingWebAudio = false;
        }
      } catch (e3) {
        Howler2.usingWebAudio = false;
      }
      if (!Howler2.ctx) {
        Howler2.usingWebAudio = false;
      }
      var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
      var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      var version2 = appVersion ? parseInt(appVersion[1], 10) : null;
      if (iOS && version2 && version2 < 9) {
        var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
        if (Howler2._navigator && !safari) {
          Howler2.usingWebAudio = false;
        }
      }
      if (Howler2.usingWebAudio) {
        Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
        Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
        Howler2.masterGain.connect(Howler2.ctx.destination);
      }
      Howler2._setup();
    };
    {
      exports.Howler = Howler2;
      exports.Howl = Howl2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.HowlerGlobal = HowlerGlobal2;
      commonjsGlobal.Howler = Howler2;
      commonjsGlobal.Howl = Howl2;
      commonjsGlobal.Sound = Sound2;
    } else if (typeof window !== "undefined") {
      window.HowlerGlobal = HowlerGlobal2;
      window.Howler = Howler2;
      window.Howl = Howl2;
      window.Sound = Sound2;
    }
  })();
  /*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   */
  (function() {
    HowlerGlobal.prototype._pos = [0, 0, 0];
    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
    HowlerGlobal.prototype.stereo = function(pan) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      for (var i2 = self2._howls.length - 1; i2 >= 0; i2--) {
        self2._howls[i2].stereo(pan);
      }
      return self2;
    };
    HowlerGlobal.prototype.pos = function(x2, y2, z2) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      y2 = typeof y2 !== "number" ? self2._pos[1] : y2;
      z2 = typeof z2 !== "number" ? self2._pos[2] : z2;
      if (typeof x2 === "number") {
        self2._pos = [x2, y2, z2];
        if (typeof self2.ctx.listener.positionX !== "undefined") {
          self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
        }
      } else {
        return self2._pos;
      }
      return self2;
    };
    HowlerGlobal.prototype.orientation = function(x2, y2, z2, xUp, yUp, zUp) {
      var self2 = this;
      if (!self2.ctx || !self2.ctx.listener) {
        return self2;
      }
      var or = self2._orientation;
      y2 = typeof y2 !== "number" ? or[1] : y2;
      z2 = typeof z2 !== "number" ? or[2] : z2;
      xUp = typeof xUp !== "number" ? or[3] : xUp;
      yUp = typeof yUp !== "number" ? or[4] : yUp;
      zUp = typeof zUp !== "number" ? or[5] : zUp;
      if (typeof x2 === "number") {
        self2._orientation = [x2, y2, z2, xUp, yUp, zUp];
        if (typeof self2.ctx.listener.forwardX !== "undefined") {
          self2.ctx.listener.forwardX.setTargetAtTime(x2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardY.setTargetAtTime(y2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.forwardZ.setTargetAtTime(z2, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
          self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
        } else {
          self2.ctx.listener.setOrientation(x2, y2, z2, xUp, yUp, zUp);
        }
      } else {
        return or;
      }
      return self2;
    };
    Howl.prototype.init = function(_super) {
      return function(o2) {
        var self2 = this;
        self2._orientation = o2.orientation || [1, 0, 0];
        self2._stereo = o2.stereo || null;
        self2._pos = o2.pos || null;
        self2._pannerAttr = {
          coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : 360,
          coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : 360,
          coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : 0,
          distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : "inverse",
          maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : 1e4,
          panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : "HRTF",
          refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : 1,
          rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : 1
        };
        self2._onstereo = o2.onstereo ? [{ fn: o2.onstereo }] : [];
        self2._onpos = o2.onpos ? [{ fn: o2.onpos }] : [];
        self2._onorientation = o2.onorientation ? [{ fn: o2.onorientation }] : [];
        return _super.call(this, o2);
      };
    }(Howl.prototype.init);
    Howl.prototype.stereo = function(pan, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "stereo",
          action: function() {
            self2.stereo(pan, id);
          }
        });
        return self2;
      }
      var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
      if (typeof id === "undefined") {
        if (typeof pan === "number") {
          self2._stereo = pan;
          self2._pos = [pan, 0, 0];
        } else {
          return self2._stereo;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof pan === "number") {
            sound._stereo = pan;
            sound._pos = [pan, 0, 0];
            if (sound._node) {
              sound._pannerAttr.panningModel = "equalpower";
              if (!sound._panner || !sound._panner.pan) {
                setupPanner(sound, pannerType);
              }
              if (pannerType === "spatial") {
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(pan, 0, 0);
                }
              } else {
                sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
              }
            }
            self2._emit("stereo", sound._id);
          } else {
            return sound._stereo;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pos = function(x2, y2, z2, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "pos",
          action: function() {
            self2.pos(x2, y2, z2, id);
          }
        });
        return self2;
      }
      y2 = typeof y2 !== "number" ? 0 : y2;
      z2 = typeof z2 !== "number" ? -0.5 : z2;
      if (typeof id === "undefined") {
        if (typeof x2 === "number") {
          self2._pos = [x2, y2, z2];
        } else {
          return self2._pos;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof x2 === "number") {
            sound._pos = [x2, y2, z2];
            if (sound._node) {
              if (!sound._panner || sound._panner.pan) {
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.positionX !== "undefined") {
                sound._panner.positionX.setValueAtTime(x2, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(y2, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(z2, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(x2, y2, z2);
              }
            }
            self2._emit("pos", sound._id);
          } else {
            return sound._pos;
          }
        }
      }
      return self2;
    };
    Howl.prototype.orientation = function(x2, y2, z2, id) {
      var self2 = this;
      if (!self2._webAudio) {
        return self2;
      }
      if (self2._state !== "loaded") {
        self2._queue.push({
          event: "orientation",
          action: function() {
            self2.orientation(x2, y2, z2, id);
          }
        });
        return self2;
      }
      y2 = typeof y2 !== "number" ? self2._orientation[1] : y2;
      z2 = typeof z2 !== "number" ? self2._orientation[2] : z2;
      if (typeof id === "undefined") {
        if (typeof x2 === "number") {
          self2._orientation = [x2, y2, z2];
        } else {
          return self2._orientation;
        }
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        var sound = self2._soundById(ids[i2]);
        if (sound) {
          if (typeof x2 === "number") {
            sound._orientation = [x2, y2, z2];
            if (sound._node) {
              if (!sound._panner) {
                if (!sound._pos) {
                  sound._pos = self2._pos || [0, 0, -0.5];
                }
                setupPanner(sound, "spatial");
              }
              if (typeof sound._panner.orientationX !== "undefined") {
                sound._panner.orientationX.setValueAtTime(x2, Howler.ctx.currentTime);
                sound._panner.orientationY.setValueAtTime(y2, Howler.ctx.currentTime);
                sound._panner.orientationZ.setValueAtTime(z2, Howler.ctx.currentTime);
              } else {
                sound._panner.setOrientation(x2, y2, z2);
              }
            }
            self2._emit("orientation", sound._id);
          } else {
            return sound._orientation;
          }
        }
      }
      return self2;
    };
    Howl.prototype.pannerAttr = function() {
      var self2 = this;
      var args = arguments;
      var o2, id, sound;
      if (!self2._webAudio) {
        return self2;
      }
      if (args.length === 0) {
        return self2._pannerAttr;
      } else if (args.length === 1) {
        if (typeof args[0] === "object") {
          o2 = args[0];
          if (typeof id === "undefined") {
            if (!o2.pannerAttr) {
              o2.pannerAttr = {
                coneInnerAngle: o2.coneInnerAngle,
                coneOuterAngle: o2.coneOuterAngle,
                coneOuterGain: o2.coneOuterGain,
                distanceModel: o2.distanceModel,
                maxDistance: o2.maxDistance,
                refDistance: o2.refDistance,
                rolloffFactor: o2.rolloffFactor,
                panningModel: o2.panningModel
              };
            }
            self2._pannerAttr = {
              coneInnerAngle: typeof o2.pannerAttr.coneInnerAngle !== "undefined" ? o2.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
              coneOuterAngle: typeof o2.pannerAttr.coneOuterAngle !== "undefined" ? o2.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
              coneOuterGain: typeof o2.pannerAttr.coneOuterGain !== "undefined" ? o2.pannerAttr.coneOuterGain : self2._coneOuterGain,
              distanceModel: typeof o2.pannerAttr.distanceModel !== "undefined" ? o2.pannerAttr.distanceModel : self2._distanceModel,
              maxDistance: typeof o2.pannerAttr.maxDistance !== "undefined" ? o2.pannerAttr.maxDistance : self2._maxDistance,
              refDistance: typeof o2.pannerAttr.refDistance !== "undefined" ? o2.pannerAttr.refDistance : self2._refDistance,
              rolloffFactor: typeof o2.pannerAttr.rolloffFactor !== "undefined" ? o2.pannerAttr.rolloffFactor : self2._rolloffFactor,
              panningModel: typeof o2.pannerAttr.panningModel !== "undefined" ? o2.pannerAttr.panningModel : self2._panningModel
            };
          }
        } else {
          sound = self2._soundById(parseInt(args[0], 10));
          return sound ? sound._pannerAttr : self2._pannerAttr;
        }
      } else if (args.length === 2) {
        o2 = args[0];
        id = parseInt(args[1], 10);
      }
      var ids = self2._getSoundIds(id);
      for (var i2 = 0; i2 < ids.length; i2++) {
        sound = self2._soundById(ids[i2]);
        if (sound) {
          var pa = sound._pannerAttr;
          pa = {
            coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : pa.coneInnerAngle,
            coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : pa.coneOuterAngle,
            coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : pa.coneOuterGain,
            distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : pa.distanceModel,
            maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : pa.maxDistance,
            refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : pa.refDistance,
            rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : pa.rolloffFactor,
            panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : pa.panningModel
          };
          var panner = sound._panner;
          if (panner) {
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          } else {
            if (!sound._pos) {
              sound._pos = self2._pos || [0, 0, -0.5];
            }
            setupPanner(sound, "spatial");
          }
        }
      }
      return self2;
    };
    Sound.prototype.init = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        _super.call(this);
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        }
      };
    }(Sound.prototype.init);
    Sound.prototype.reset = function(_super) {
      return function() {
        var self2 = this;
        var parent = self2._parent;
        self2._orientation = parent._orientation;
        self2._stereo = parent._stereo;
        self2._pos = parent._pos;
        self2._pannerAttr = parent._pannerAttr;
        if (self2._stereo) {
          parent.stereo(self2._stereo);
        } else if (self2._pos) {
          parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
        } else if (self2._panner) {
          self2._panner.disconnect(0);
          self2._panner = void 0;
          parent._refreshBuffer(self2);
        }
        return _super.call(this);
      };
    }(Sound.prototype.reset);
    var setupPanner = function(sound, type) {
      type = type || "spatial";
      if (type === "spatial") {
        sound._panner = Howler.ctx.createPanner();
        sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
        sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
        sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
        sound._panner.distanceModel = sound._pannerAttr.distanceModel;
        sound._panner.maxDistance = sound._pannerAttr.maxDistance;
        sound._panner.refDistance = sound._pannerAttr.refDistance;
        sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
        sound._panner.panningModel = sound._pannerAttr.panningModel;
        if (typeof sound._panner.positionX !== "undefined") {
          sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
          sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
          sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
        }
        if (typeof sound._panner.orientationX !== "undefined") {
          sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
          sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
          sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
        } else {
          sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
        }
      } else {
        sound._panner = Howler.ctx.createStereoPanner();
        sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
      }
      sound._panner.connect(sound._node);
      if (!sound._paused) {
        sound._parent.pause(sound._id, true).play(sound._id, true);
      }
    };
  })();
})(howler);
const sounds = /* @__PURE__ */ new Map();
function _initSound(_sounds, engine) {
  return _initResource(sounds, _sounds, "sound", engine);
}
class RpgSoundClass {
  constructor() {
    this.sounds = /* @__PURE__ */ new Map();
  }
  get(id) {
    if (this.sounds.has(id)) {
      return this.sounds.get(id);
    }
    const resource = sounds.get(id);
    if (!resource) {
      throw log(`Impossible to find the ${id} sound. Did you put the right name or create the sound?`);
    }
    const howl = new howler.Howl({
      src: [resource.sound],
      loop: resource.loop,
      autoplay: resource.autoplay,
      volume: resource.volume,
      sprite: resource.sprite
    });
    this.sounds.set(id, howl);
    return howl;
  }
  stop(id) {
    this.get(id).stop();
  }
  play(id) {
    const sound = this.get(id);
    if (!sound.playing()) {
      sound.play();
      return true;
    }
    return false;
  }
  clear() {
    this.sounds.clear();
    this.global.stop();
  }
  get global() {
    return howler.Howler;
  }
}
const RpgSound = new RpgSoundClass();
var Animation$1;
(function(Animation2) {
  Animation2["Stand"] = "stand";
  Animation2["Walk"] = "walk";
  Animation2["Attack"] = "attack";
  Animation2["Defense"] = "defense";
  Animation2["Skill"] = "skill";
})(Animation$1 || (Animation$1 = {}));
const {
  isFunction: isFunction$2,
  arrayEquals
} = Utils$2;
class Animation extends Sprite {
  get attachTo() {
    return this._attachTo;
  }
  set attachTo(component) {
    if (!component)
      return;
    component.animationIsPlaying = true;
    this._attachTo = component;
  }
  constructor(id) {
    super();
    this.id = id;
    this.currentAnimation = null;
    this.time = 0;
    this.frameIndex = 0;
    this.animations = /* @__PURE__ */ new Map();
    this._animation$ = new BehaviorSubject$1(null);
    this.animation$ = this._animation$.asObservable();
    this.spritesheet = spritesheets.get(this.id);
    if (!this.spritesheet) {
      throw log(`Impossible to find the ${this.id} spritesheet. Did you put the right name or create the spritesheet?`);
    }
    this.createAnimations();
  }
  createTextures(options2) {
    const {
      width,
      height,
      framesHeight,
      framesWidth,
      image,
      offset
    } = options2;
    const {
      baseTexture
    } = Texture.from(image);
    const spriteWidth = options2.spriteWidth;
    const spriteHeight = options2.spriteHeight;
    const frames = [];
    const offsetX = offset && offset.x || 0;
    const offsetY = offset && offset.y || 0;
    for (let i2 = 0; i2 < framesHeight; i2++) {
      frames[i2] = [];
      for (let j2 = 0; j2 < framesWidth; j2++) {
        const rectX = j2 * spriteWidth + offsetX;
        const rectY = i2 * spriteHeight + offsetY;
        if (rectY > height) {
          throw log(`Warning, there is a problem with the height of the "${this.id}" spritesheet. When cutting into frames, the frame exceeds the height of the image.`);
        }
        if (rectX > width) {
          throw log(`Warning, there is a problem with the width of the "${this.id}" spritesheet. When cutting into frames, the frame exceeds the width of the image.`);
        }
        frames[i2].push(new Texture(baseTexture, new Rectangle(rectX, rectY, spriteWidth, spriteHeight)));
      }
    }
    return frames;
  }
  createAnimations() {
    const {
      textures
    } = this.spritesheet;
    if (!textures) {
      return;
    }
    for (let animationName in textures) {
      const props = ["width", "height", "framesHeight", "framesWidth", "rectWidth", "rectHeight", "offset", "image", "sound"];
      const parentObj = props.reduce((prev, val) => ({
        ...prev,
        [val]: this.spritesheet[val]
      }), {});
      const optionsTextures = {
        ...parentObj,
        ...textures[animationName]
      };
      const {
        rectWidth,
        width = 0,
        framesWidth = 1,
        rectHeight,
        height = 0,
        framesHeight = 1
      } = optionsTextures;
      optionsTextures.spriteWidth = rectWidth ? rectWidth : width / framesWidth;
      optionsTextures.spriteHeight = rectHeight ? rectHeight : height / framesHeight;
      this.animations.set(animationName, {
        container: new Sprite(),
        frames: this.createTextures(optionsTextures),
        name: animationName,
        animations: textures[animationName].animations,
        params: [],
        data: optionsTextures,
        sprites: []
      });
    }
  }
  getSpriteSize(name2) {
    var _a, _b;
    return ((_b = this.animations.get(((_a = this.currentAnimation) == null ? void 0 : _a.name) || Animation$1.Stand)) == null ? void 0 : _b.data[name2]) || 0;
  }
  getSpriteHeight() {
    return this.getSpriteSize("spriteHeight");
  }
  getSpriteWidth() {
    return this.getSpriteSize("spriteWidth");
  }
  has(name2) {
    return this.animations.has(name2);
  }
  get(name2) {
    return this.animations.get(name2);
  }
  isPlaying(name2) {
    if (!name2)
      return !!this.currentAnimation;
    if (this.currentAnimation == null)
      return false;
    return this.currentAnimation.name == name2;
  }
  stop() {
    var _a;
    this.currentAnimation = null;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  play(name2, params = []) {
    var _a;
    const animParams = (_a = this.currentAnimation) == null ? void 0 : _a.params;
    if (this.isPlaying(name2) && arrayEquals(params, animParams || []))
      return;
    const animation = this.get(name2);
    if (!animation) {
      throw new Error(`Impossible to play the ${name2} animation because it doesn't exist on the ${this.id} spritesheet`);
    }
    this.removeChildren();
    animation.sprites = [];
    this.currentAnimation = animation;
    this.currentAnimation.params = params;
    this.time = 0;
    this.frameIndex = 0;
    let animations = animation.animations;
    animations = isFunction$2(animations) ? animations(...params) : animations;
    this.currentAnimation.container = new Container();
    for (let container of animations) {
      const sprite2 = new Sprite();
      for (let frame of container) {
        this.currentAnimation.sprites.push(frame);
      }
      this.currentAnimation.container.addChild(sprite2);
    }
    const sound = this.currentAnimation.data.sound;
    if (sound) {
      RpgSound.get(sound).play();
    }
    this.addChild(this.currentAnimation.container);
    this.update(1);
  }
  update(deltaRatio) {
    if (!this.isPlaying() || !this.currentAnimation)
      return;
    const {
      frames,
      container,
      sprites,
      data
    } = this.currentAnimation;
    let frame = sprites[this.frameIndex];
    const nextFrame2 = sprites[this.frameIndex + 1];
    if (this.attachTo) {
      const sprite2 = this.attachTo;
      const pos = sprite2 == null ? void 0 : sprite2.getPositionsOfGraphic("middle");
      if (pos) {
        container.x = pos.x;
        container.y = pos.y;
      }
    }
    for (let _sprite of container.children) {
      let applyTransformValue = function(prop, alias) {
        const optionProp = alias || prop;
        const val = getVal(optionProp);
        if (val !== void 0) {
          sprite2[prop] = val;
        }
      };
      const sprite2 = _sprite;
      if (!frame || frame.frameY == void 0 || frame.frameX == void 0) {
        continue;
      }
      sprite2.texture = frames[frame.frameY][frame.frameX];
      const getVal = (prop) => frame[prop] || data[prop] || this.spritesheet[prop];
      const applyTransform = (prop) => {
        const val = getVal(prop);
        if (val) {
          sprite2[prop].set(...val);
        }
      };
      if (this.applyTransform) {
        frame = {
          ...frame,
          ...this.applyTransform(frame, data, this.spritesheet)
        };
      }
      const realSize = getVal("spriteRealSize");
      const heightOfSprite = typeof realSize == "number" ? realSize : realSize == null ? void 0 : realSize.height;
      const widthOfSprite = typeof realSize == "number" ? realSize : realSize == null ? void 0 : realSize.width;
      const applyAnchorBySize = () => {
        if (heightOfSprite && this.hitbox) {
          const {
            spriteWidth,
            spriteHeight
          } = data;
          const w2 = (spriteWidth - this.hitbox.w) / 2 / spriteWidth;
          const gap = (spriteHeight - heightOfSprite) / 2;
          const h2 = (spriteHeight - this.hitbox.h - gap) / spriteHeight;
          sprite2.anchor.set(w2, h2);
        }
      };
      if (frame.sound) {
        RpgSound.get(frame.sound).play();
      }
      applyAnchorBySize();
      applyTransform("anchor");
      applyTransform("scale");
      applyTransform("skew");
      applyTransform("pivot");
      applyTransformValue("alpha", "opacity");
      applyTransformValue("x");
      applyTransformValue("y");
      applyTransformValue("angle");
      applyTransformValue("rotation");
      applyTransformValue("visible");
      this._animation$.next({
        spriteWidth: widthOfSprite || sprite2.width,
        spriteHeight: heightOfSprite || sprite2.height,
        anchor: sprite2.anchor,
        width: getVal("spriteWidth"),
        height: getVal("spriteHeight")
      });
    }
    if (!nextFrame2) {
      this.time = 0;
      this.frameIndex = 0;
      if (this.attachTo) {
        this.attachTo.animationIsPlaying = false;
      }
      if (this.onFinish)
        this.onFinish();
      return;
    }
    this.time += deltaRatio;
    if (this.time >= nextFrame2.time) {
      this.frameIndex++;
    }
  }
}
class GameEngineClient extends RpgCommonGame {
  constructor() {
    super(...arguments);
    this._objects = new BehaviorSubject$1({});
    this._obsObjects = {};
    this._obsObjectsDeleteNotifier$ = {};
    this._shapes = new BehaviorSubject$1({});
    this._objectsChanged = new BehaviorSubject$1({});
    this.world = {
      getObjects: this.getObjects.bind(this),
      getObject: (id) => {
        const obj = this.getObject(id);
        if (!obj)
          return null;
        return obj.object;
      },
      getShape: (id) => {
        const obj = this.getShape(id);
        if (!obj)
          return null;
        return obj.object;
      },
      getAll: (id) => {
        const obj = this.getObjectAndShape(id);
        if (!obj)
          return null;
        return obj.object;
      },
      removeObject: this.removeObject.bind(this),
      getObjectsOfGroup: () => {
        return {
          ...this.getObjects(),
          ...this.events
        };
      },
      getShapesOfGroup: () => {
        return this.getShapes();
      }
    };
  }
  initialize() {
    super.initialize(GameSide.Client);
  }
  _get(prop, id) {
    const objects = this[prop].value;
    const val = objects[id];
    if (!val)
      return null;
    return val;
  }
  get objectsChanged() {
    return this._objectsChanged.asObservable();
  }
  setObjectsChanged(val) {
    this._objectsChanged.next(val);
  }
  listenObject(id) {
    return this._obsObjects[id].asObservable();
  }
  get objects() {
    return this._objects.asObservable();
  }
  get shapes() {
    return this._shapes.asObservable();
  }
  get all() {
    return combineLatest([this.objects, this.shapes]).pipe(map$6(([objects, shapes]) => {
      return {
        ...objects,
        ...shapes
      };
    }));
  }
  getShapes() {
    return this._shapes.value;
  }
  getObjects() {
    return this._objects.value;
  }
  getObject(id) {
    return this._get("_objects", id);
  }
  getShape(id) {
    return this._get("_shapes", id);
  }
  getObjectAndShape(id) {
    let obj = this.getObject(id);
    if (!obj)
      obj = this.getShape(id);
    return obj;
  }
  resetObjects() {
    for (let id in this._obsObjectsDeleteNotifier$) {
      this._obsObjectsDeleteNotifier$[id].next();
      this._obsObjectsDeleteNotifier$[id].complete();
      this._obsObjects[id].complete();
    }
    this._obsObjectsDeleteNotifier$ = {};
    this._obsObjects = {};
    this._objects.next({});
    this._shapes.next({});
  }
  getDeleteNotifier(id) {
    return this._obsObjectsDeleteNotifier$[id].asObservable();
  }
  _remove(prop, id) {
    const logic = prop == "_objects" ? this.getObject(id) : this.getShape(id);
    if (logic) {
      const objects = {
        ...this[prop].value
      };
      delete objects[id];
      this._obsObjectsDeleteNotifier$[id].next();
      this._obsObjectsDeleteNotifier$[id].complete();
      this._obsObjects[id].complete();
      delete this._obsObjects[id];
      delete this._obsObjectsDeleteNotifier$[id];
      this[prop].next(objects);
      return true;
    }
    return false;
  }
  removeObject(id) {
    if (this.events[id]) {
      delete this.events[id];
    }
    return this._remove("_objects", id);
  }
  removeShape(id) {
    return this._remove("_shapes", id);
  }
  removeObjectAndShape(id) {
    let bool = this.removeObject(id);
    if (!bool)
      bool = this.removeShape(id);
    return bool;
  }
  static toArray(obj, prop) {
    if (obj[prop])
      obj[prop] = Object.values(obj[prop]);
  }
  updateObject(obj) {
    const {
      playerId: id,
      params,
      localEvent,
      paramsChanged,
      isShape
    } = obj;
    if (paramsChanged.components) {
      paramsChanged.layout = {
        center: {
          lines: [{
            col: paramsChanged.components
          }]
        }
      };
    }
    const layoutToArray = (params2) => {
      const layout = params2.layout;
      if (layout) {
        ["center", "top", "right", "bottom", "left"].forEach((key) => {
          if (!layout[key])
            return;
          GameEngineClient.toArray(layout[key], "lines");
          if (!layout[key].lines)
            return;
          layout[key].lines.map((layout2) => {
            GameEngineClient.toArray(layout2, "col");
          });
        });
      }
    };
    layoutToArray(params);
    GameEngineClient.toArray(params, "polygon");
    const isMe = () => id == this.playerId;
    let logic;
    const createObsForObject = (data) => {
      this._obsObjectsDeleteNotifier$[id] = new Subject$1();
      this._obsObjects[id] = new BehaviorSubject$1(data);
    };
    if (isShape) {
      logic = this.world.getShape(id);
      if (!logic) {
        logic = this.addShape(params);
        createObsForObject({
          logic
        });
      }
    } else {
      if (localEvent) {
        logic = this.events[id];
        if (!logic) {
          logic = this.addEvent(RpgCommonPlayer, id);
          createObsForObject({
            logic
          });
          this.events[id] = {
            object: logic
          };
        } else {
          logic = logic.object;
        }
      } else {
        logic = this.world.getObject(id);
      }
      if (!logic) {
        logic = this.addPlayer(RpgCommonPlayer, id);
        createObsForObject({
          logic
        });
      }
    }
    logic.prevParamsChanged = Object.assign({}, logic);
    for (let key in params) {
      if (!localEvent && (key == "position" || key == "direction" && paramsChanged && paramsChanged.position)) {
        if (isMe() && logic.canMove)
          continue;
      }
      logic[key] = params[key];
    }
    if (paramsChanged) {
      layoutToArray(paramsChanged);
      if (paramsChanged.layout)
        logic.componentChanged = paramsChanged.layout;
      if (paramsChanged.teleported) {
        logic.position = {
          ...params.position
        };
        logic.direction = params.direction;
      }
      if (!logic.paramsChanged)
        logic.paramsChanged = {};
      logic.paramsChanged = paramsChanged;
    }
    const newObject = {
      object: logic,
      paramsChanged
    };
    this.setObject(id, newObject);
    return newObject;
  }
  setObject(id, newObject) {
    const propName = newObject.object instanceof RpgShape ? "_shapes" : "_objects";
    this[propName].next({
      ...this[propName].value,
      ...{
        [id]: newObject
      }
    });
    this._obsObjects[id].next(newObject);
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
function makeMap(str2, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str2.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map2[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str2) => {
    const hit = cache[str2];
    return hit || (cache[str2] = fn(str2));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str2) => {
  return str2.replace(camelizeRE, (_2, c3) => c3 ? c3.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction(
  (str2) => str2.charAt(0).toUpperCase() + str2.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str2) => str2 ? `on${capitalize$1(str2)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString$1(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global$1 !== "undefined" ? global$1 : {});
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const get$1$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$1(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done: done2 } = innerIterator.next();
        return done2 ? { value, done: done2 } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done2
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a8, b3) => getId(a8) - getId(b3));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a8, b3) => {
  const diff = getId(a8) - getId(b3);
  if (diff === 0) {
    if (a8.pre && !b3.pre)
      return -1;
    if (b3.pre && !a8.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit2(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a8) => isString$1(a8) ? a8.trim() : a8);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options2, key) {
  if (!options2 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options2, key[0].toLowerCase() + key.slice(1)) || hasOwn(options2, hyphenate(key)) || hasOwn(options2, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit3,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit3
          } : { attrs, slots, emit: emit3 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options2) {
  return doWatch(source, cb, options2);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$1(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v2, i2) => hasChanged(v2, oldValue[i2])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options2) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options2 = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options2);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding2 = bindings[i2];
    if (oldBindings) {
      binding2.oldValue = oldBindings[i2].value;
    }
    let hook = binding2.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding2,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c3 of children) {
          if (c3.type !== Comment) {
            child = c3;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done2 = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done2();
    } else if (hook.length <= 1) {
      done2();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done2 = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done2]);
      } else {
        done2();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done2 = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done2]);
      } else {
        done2();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize$1(camelize(name2)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name2) || // global registration
      resolve(instance.appContext[type], name2)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize$1(camelize(name2))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$1(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props.name = name2;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name2}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$1(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options2 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options2.beforeCreate) {
    callHook$1(options2.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters: filters2
  } = options2;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c3 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c3.value,
        set: (v2) => c3.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  if (isObject$1(base2)) {
    cache.set(base2, resolved);
  }
  return resolved;
}
function mergeOptions(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from2[key]) : from2[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from2) ? from2.call(this, this) : from2
    );
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from2) : from2;
}
function mergeEmitsOrPropsOptions(to, from2) {
  if (to) {
    if (isArray$1(to) && isArray$1(from2)) {
      return [.../* @__PURE__ */ new Set([...to, ...from2])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from2 != null ? from2 : {})
    );
  } else {
    return from2;
  }
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from2) {
    merged[key] = mergeAsArray(to[key], from2[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context2 = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context2.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context2,
      _instance: null,
      version,
      get config() {
        return context2.config;
      },
      set config(v2) {
      },
      use(plugin, ...options2) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options2);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options2);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context2.mixins.includes(mixin)) {
            context2.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name2, component) {
        if (!component) {
          return context2.components[name2];
        }
        context2.components[name2] = component;
        return app;
      },
      directive(name2, directive) {
        if (!directive) {
          return context2.directives[name2];
        }
        context2.directives[name2] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context2;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context2.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject$1(key, defaultValue2, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue2) ? defaultValue2.call(instance && instance.proxy) : defaultValue2;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options2] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options2) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options2,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options2) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options2,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options2, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options2 && hasOwn(options2, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options2,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options2, props, key, value, instance, isAbsent) {
  const opt = options2[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue2 = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue2)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue2.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue2;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a8, b3) {
  return getType(a8) === getType(b3);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r2, i2) => setRef(
        r2,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options2) {
  return baseCreateRenderer(options2);
}
function baseCreateRenderer(options2, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options2;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c12 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c22 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c12, parentComponent, parentSuspense);
      }
      if (c22 !== c12) {
        hostSetElementText(container, c22);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c12,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c12, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c12 = c12 || EMPTY_ARR;
    c22 = c22 || EMPTY_ARR;
    const oldLength = c12.length;
    const newLength = c22.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
      patch(
        c12[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c12,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c12, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c22.length;
    let e12 = c12.length - 1;
    let e22 = l2 - 1;
    while (i2 <= e12 && i2 <= e22) {
      const n1 = c12[i2];
      const n2 = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e12 && i2 <= e22) {
      const n1 = c12[e12];
      const n2 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e12--;
      e22--;
    }
    if (i2 > e12) {
      if (i2 <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l2 ? c22[nextPos].el : parentAnchor;
        while (i2 <= e22) {
          patch(
            null,
            c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e22) {
      while (i2 <= e12) {
        unmount(c12[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e22; i2++) {
        const nextChild = c22[i2] = optimized ? cloneIfMounted(c22[i2]) : normalizeVNode(c22[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e22 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e12; i2++) {
        const prevChild = c12[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e22; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c22[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c22[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c22[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c22[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options2
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c12 = ch1[i2];
      let c22 = ch2[i2];
      if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
        if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
          c22 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c22.el = c12.el;
        }
        if (!shallow)
          traverseStaticChildren(c12, c22);
      }
      if (c22.type === Text) {
        c22.el = c12.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c3;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c3 = u2 + v2 >> 1;
        if (arr[result[c3]] < arrI) {
          u2 = c3 + 1;
        } else {
          v2 = c3;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString$1(ref) || isRef(ref) || isFunction$1(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray$1(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit2.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s2) => s2(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e3) => {
          handleError(e3, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    if (prev && !isString$1(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style, name2, v2));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize$1(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e3) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options2) {
  el.addEventListener(event, handler, options2);
}
function removeEventListener(el, event, handler, options2) {
  el.removeEventListener(event, handler, options2);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options2] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name2, invoker, options2);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options2);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options2;
  if (optionsModifierRE.test(name2)) {
    options2 = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options2[m2[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options2];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e3) => {
    if (!e3._vts) {
      e3._vts = Date.now();
    } else if (e3._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e3, invoker.value),
      instance,
      5,
      [e3]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e3, value) {
  if (isArray$1(value)) {
    const originalStop = e3.stopImmediatePropagation;
    e3.stopImmediatePropagation = () => {
      originalStop.call(e3);
      e3._stopped = true;
    };
    return value.map((fn) => (e22) => !e22._stopped && fn && fn(e22));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name: name2 = "v",
    type,
    duration,
    enterFromClass = `${name2}-enter-from`,
    enterActiveClass = `${name2}-enter-active`,
    enterToClass = `${name2}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name2}-leave-from`,
    leaveActiveClass = `${name2}-leave-active`,
    leaveToClass = `${name2}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done2) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done2 && done2();
  };
  const finishLeave = (el, done2) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done2 && done2();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done2) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done2);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done2) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done2);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c3) => c3 && el.classList.add(c3));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c3) => c3 && el.classList.remove(c3));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e3) => {
    if (e3.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e3) {
  e3.target.composing = true;
}
function onCompositionEnd(e3) {
  const target = e3.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e3) => {
      if (e3.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e3) => e3.stopPropagation(),
  prevent: (e3) => e3.preventDefault(),
  self: (e3) => e3.target !== e3.currentTarget,
  ctrl: (e3) => !e3.ctrlKey,
  shift: (e3) => !e3.shiftKey,
  alt: (e3) => !e3.altKey,
  meta: (e3) => !e3.metaKey,
  left: (e3) => "button" in e3 && e3.button !== 0,
  middle: (e3) => "button" in e3 && e3.button !== 1,
  right: (e3) => "button" in e3 && e3.button !== 2,
  exact: (e3, modifiers) => systemModifiers.some((m2) => e3[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const _hoisted_1$g = {
  id: "tooltips",
  style: {
    "position": "absolute",
    "top": "0",
    "left": "0"
  }
};
function render(_ctx, _cache) {
  return openBlock(), createElementBlock(
    "div",
    {},
    [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.fixedGui, (ui) => {
        return openBlock(), createElementBlock(
          Fragment,
          null,
          [ui.display ? (openBlock(), createBlock(
            resolveDynamicComponent(ui.name),
            normalizeProps(mergeProps({
              key: 0,
              style: {
                pointerEvents: "auto"
              }
            }, ui.data)),
            null,
            16
            /* FULL_PROPS */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        );
      }),
      256
      /* UNKEYED_FRAGMENT */
    )), createBaseVNode("div", _hoisted_1$g, [(openBlock(true), createElementBlock(
      Fragment,
      null,
      renderList(_ctx.attachedGui, (ui) => {
        return openBlock(), createElementBlock(
          Fragment,
          null,
          [ui.display ? (openBlock(true), createElementBlock(
            Fragment,
            {
              key: 0
            },
            renderList(_ctx.tooltipFilter(_ctx.tooltips, ui), (tooltip) => {
              return openBlock(), createElementBlock(
                "div",
                {
                  style: normalizeStyle(_ctx.tooltipPosition(tooltip.position))
                },
                [(openBlock(), createBlock(
                  resolveDynamicComponent(ui.name),
                  mergeProps({
                    ...ui.data,
                    spriteData: tooltip,
                    style: {
                      pointerEvents: "auto"
                    }
                  }, {
                    ref_for: true,
                    ref: ui.name
                  }),
                  null,
                  16
                  /* FULL_PROPS */
                ))],
                4
                /* STYLE */
              );
            }),
            256
            /* UNKEYED_FRAGMENT */
          )) : createCommentVNode("v-if", true)],
          64
          /* STABLE_FRAGMENT */
        );
      }),
      256
      /* UNKEYED_FRAGMENT */
    ))])],
    32
    /* HYDRATE_EVENTS */
  );
}
class VueGui {
  constructor(rootEl, parentGui) {
    this.parentGui = parentGui;
    this.clientEngine = parentGui.clientEngine;
    this.renderer = this.clientEngine.renderer;
    this.gameEngine = this.clientEngine.gameEngine;
    const {
      gui
    } = parentGui;
    const obj = {
      render,
      data() {
        return {
          gui: {},
          tooltips: []
        };
      },
      provide: () => {
        return parentGui.getInjectObject();
      },
      computed: {
        fixedGui() {
          return Object.values(this.gui).filter((gui2) => !gui2.attachToSprite);
        },
        attachedGui() {
          return Object.values(this.gui).filter((gui2) => gui2.attachToSprite);
        }
      },
      methods: {
        tooltipPosition: parentGui.tooltipPosition.bind(parentGui),
        tooltipFilter: parentGui.tooltipFilter.bind(parentGui)
      }
    };
    this.app = createApp(obj);
    const guiVue = Object.values(gui).filter((ui) => !isFunction$8(ui));
    for (let ui of guiVue) {
      this.app.component(ui.name, ui.gui);
    }
    this.app.directive("propagate", {
      mounted: (el, binding2) => {
        el.eventListeners = {};
        EVENTS_MAP.MouseEvent.forEach((eventType) => {
          const callback = (ev) => {
            this.renderer.propagateEvent(ev);
          };
          el.eventListeners[eventType] = callback;
          el.addEventListener(eventType, callback);
        });
      },
      unmounted(el, binding2) {
        EVENTS_MAP.MouseEvent.forEach((eventType) => {
          const callback = el.eventListeners[eventType];
          if (callback) {
            el.removeEventListener(eventType, callback);
          }
        });
      }
    });
    this.vm = this.app.mount(rootEl);
    this.renderer.app = this.app;
    this.renderer.vm = this.vm;
  }
  _setSceneReady() {
    var _a;
    this.parentGui.listenTooltipObjects.subscribe((tooltips) => {
      this.vm.tooltips = [...tooltips];
    });
    (_a = this.parentGui.currentScene) == null ? void 0 : _a.objectsMoving.next({});
  }
  set gui(val) {
    for (let key in val) {
      if (val[key].isFunction)
        continue;
      this.vm.gui[key] = val[key];
    }
    this.vm.gui = Object.assign({}, this.vm.gui);
  }
}
const {
  elementToPositionAbsolute: elementToPositionAbsolute$1
} = Utils$2;
const COMPONENT_LIBRARIES = [VueGui];
class Gui2 {
  constructor() {
    this.gui = {};
    this.currentScene = null;
    this.librariesInstances = [];
  }
  async _initialize(context2, guiEl) {
    var _a;
    this.clientEngine = context2.inject(RpgClientEngine$4);
    this.renderer = context2.inject(RpgRenderer);
    this.gameEngine = context2.inject(GameEngineClient);
    const {
      gui
    } = this.renderer.options;
    for (let ui of gui) {
      let name2 = ui.name;
      if (isFunction$8(ui)) {
        name2 = camelToKebab(name2);
      }
      this.gui[name2] = {
        data: ui.data,
        attachToSprite: ui.rpgAttachToSprite,
        display: false,
        name: name2,
        isFunction: isFunction$8(ui),
        gui: ui
      };
    }
    if ((_a = this.clientEngine.envs) == null ? void 0 : _a["VITE_REACT"]) {
      COMPONENT_LIBRARIES.push(await __vitePreload(() => import("./React-d2bc2358.js"), true ? [] : void 0).then((m2) => m2.ReactGui));
    }
    for (let componentClass of COMPONENT_LIBRARIES) {
      const el = document.createElement("div");
      elementToPositionAbsolute$1(el);
      el.style["pointer-events"] = "none";
      guiEl.appendChild(el);
      this.librariesInstances.push(new componentClass(el, this));
    }
    guiEl.style["pointer-events"] = "none";
  }
  _setSceneReady(scene) {
    this.currentScene = scene;
    this.librariesInstances.forEach((instance) => {
      if (instance._setSceneReady)
        instance._setSceneReady(scene);
    });
  }
  getInjectObject() {
    const self2 = this;
    return {
      /**
       * Recovery of the current scene
       *
       * ```js
       * export default {
       *      inject: ['rpgScene'],
       *      mounted() {
       *          const scene = this.rpgScene()
       *          scene.stopInputs()
       *      }
       * }
       * ```
       *
       * @prop {Function returns RpgScene} [rpgScene]
       * @memberof VueInject
       * */
      rpgScene: this.renderer.getScene.bind(this.renderer),
      /**
      * Retrieve the main container of the game
      *
      * ```js
      * export default {
      *      inject: ['rpgStage'],
      *      mounted() {
      *          const blur = new PIXI.BlurFilter()
                 this.rpgStage.filters = [blur]
      *      }
      * }
      * ```
      *
      * @prop {PIXI.Container} [rpgStage]
      * @memberof VueInject
      * */
      rpgStage: this.renderer.stage,
      /**
       * Listen to all the objects present in the room (events and players)
       *
       * ```js
       * export default {
       *      inject: ['rpgObjects'],
       *      mounted() {
       *          this.obs = this.rpgObjects.subscribe((objects) => {
       *              for (let id in objects) {
       *                  const obj = objects[id]
       *                  console.log(obj.object, obj.paramsChanged)
       *              }
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * > remember to unsubscribe for memory leaks
       *
       * It is an observable that returns an object:
       *
       * * the key is the object identifier
       * * The value is an object comprising:
       *      * `object`: The entire object
       *      * `paramsChanged`: Only the representation of the properties that have been changed on this object
       *
       * @prop {Observable<{ [objectId]: { object: object, paramsChanged: object } }>} [rpgObjects]
       * @memberof VueInject
       * */
      rpgObjects: this.clientEngine.objects,
      /**
       * Recovers and listens to the current player
       *
       * ```js
       * export default {
       *      inject: ['rpgCurrentPlayer'],
       *      mounted() {
       *          this.obs = this.rpgCurrentPlayer.subscribe((obj) => {
       *              console.log(obj.object, obj.paramsChanged)
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * * `object`: The whole player
       * * `paramsChanged`: Only the representation of the properties that have been changed on this player
       *
       * @prop {Observable<{ object: object, paramsChanged: object }>} [rpgCurrentPlayer]
       * @memberof VueInject
       * */
      rpgCurrentPlayer: this.clientEngine.objects.pipe(map$6((objects) => objects[this.gameEngine.playerId]), filter$1((player2) => !!player2)),
      rpgGameEngine: this.gameEngine,
      /**
       * Tell the server to close the GUI.
       *
       * It is a function with 2 parameters:
       * * `name`: The name of the component
       * * `data`: The data you want to pass to the server
       *
       * ```js
       * export default {
       *      inject: ['rpgGuiClose'],
       *      methods: {
       *          close() {
       *              this.rpgGuiClose('gui-name', {
       *                  amount: 1000
       *              })
       *          }
       *      }
       * }
       * ```
       *
       * @prop {Function(name, data)} [rpgGuiClose]
       * @memberof VueInject
       * */
      rpgGuiClose(name2, data) {
        var _a;
        const guiId = name2 || ((_a = this.$options) == null ? void 0 : _a.name);
        self2.socket.emit("gui.exit", {
          guiId,
          data
        });
      },
      /**
       * Perform an interaction with the open GUI
       *
       * It is a function with 2 parameters:
       * * `guiId`: The name of the component/Gui
       * * `name`: The name of the interaction (defined on the server side)
       * * `data`: Data to be sent
       *
       * ```js
       * export default {
       *      inject: ['rpgGuiInteraction'],
       *      methods: {
       *          changeGold() {
       *              this.rpgGuiInteraction('gui-name', 'change-gold', {
       *                  amount: 100
       *              })
       *          }
       *      }
       * }
       * ```
       *
       * @prop {Function(guiId, name, data = {})} [rpgGuiInteraction]
       * @memberof VueInject
       * */
      rpgGuiInteraction: (guiId, name2, data = {}) => {
        this.socket.emit("gui.interaction", {
          guiId,
          name: name2,
          data
        });
      },
      /**
       * Listen to the keys that are pressed on the keyboard
       *
       * ```js
       * export default {
       *      inject: ['rpgKeypress'],
       *      mounted() {
       *          this.obs = this.rpgKeypress.subscribe(({ inputName, control }) => {
       *              console.log(inputName) // "escape"
       *              console.log(control.actionName) // "back"
       *          })
       *      },
       *      unmounted() {
       *          this.obs.unsubscribe()
       *      }
       * }
       * ```
       *
       * @prop {Observable<{ inputName: string, control: { actionName: string, options: any } }>} [rpgKeypress]
       * @memberof VueInject
       * */
      rpgKeypress: this.clientEngine.keyChange.pipe(map$6((name2) => {
        const control = this.clientEngine.controls.getControl(name2);
        return {
          inputName: name2,
          control
        };
      })),
      /**
       * Recovers the socket.
       *
       * ```js
       * export default {
       *      inject: ['rpgSocket'],
       *      mounted() {
       *          const socket = this.rpgSocket()
       *          socket.emit('foo', 'bar')
       *      }
       * }
       * ```
       *
       * @prop {Function returns RpgScene} [rpgSocket]
       * @memberof VueInject
       * */
      rpgSocket: () => this.socket,
      /**
       * The RpgGui object to control GUIs
       *
       * ```js
       * export default {
       *      inject: ['rpgGui'],
       *      mounted() {
       *         const guis = this.rpgGui.getAll()
       *      }
       * }
       * ```
       *
       * @prop {RpgGui} [rpgGui]
       * @memberof VueInject
       * */
      rpgGui: this,
      /**
       * Equivalent to RpgSound
       *
       * ```js
       * export default {
       *      inject: ['rpgSound'],
       *      mounted() {
       *         this.rpgSound.get('my-sound-id').play()
       *      }
       * }
       * ```
       *
       * @prop {RpgSound} [rpgSound]
       * @memberof VueInject
       * */
      rpgSound: RpgSound,
      /**
       * Find the game's image and sound library
       *
       * ```js
       * export default {
       *      inject: ['rpgResource'],
       *      mounted() {
       *         const resourceImage = this.rpgResource.spritesheets.get('image_id')
       *         const resourceSound = this.rpgResource.sounds.get('sound_id')
       *      }
       * }
       * ```
       *
       * @prop { { spritesheets: Map, sounds: Map } } [rpgResource]
       * @memberof VueInject
       * */
      rpgResource: RpgResource,
      /**
       * Get RpgClientEngine instance
       *
       * ```js
       * export default {
       *      inject: ['rpgEngine'],
       *      mounted() {
       *         const vueInstance = this.rpgEngine.vueInstance
       *      }
       * }
       * ```
       *
       * @prop {RpgClientEngine} [rpgEngine]
       * @memberof VueInject
       * */
      rpgEngine: this.clientEngine
    };
  }
  /** @internal */
  _setSocket(socket) {
    this.socket = socket;
    this.socket.on("gui.open", ({
      guiId,
      data
    }) => {
      this.display(guiId, data);
    });
    this.socket.on("gui.tooltip", ({
      players,
      display
    }) => {
      var _a;
      for (let playerId of players) {
        const sprite2 = (_a = this.renderer.getScene()) == null ? void 0 : _a.getSprite(playerId);
        if (sprite2)
          sprite2.guiDisplay = display;
      }
    });
    this.socket.on("gui.exit", (guiId) => {
      this.hide(guiId);
    });
  }
  /** @internal */
  _setGui(id, obj) {
    const guiObj = this.get(id);
    if (!guiObj) {
      throw `The GUI named ${id} is non-existent. Please add the component in the gui property of the decorator @RpgClient`;
    }
    for (let key in obj) {
      guiObj[key] = obj[key];
    }
    this.librariesInstances.forEach((instance) => {
      instance.gui = Object.assign({}, this.gui);
    });
  }
  /**
  * Get a GUI. You retrieve GUI data and information whether it is displayed or not
  *
  * ```ts
  * import { RpgGui } from '@rpgjs/client'
  *
  * const gui = RpgGui.get('my-gui')
  * console.log(gui.display) // false
  * ```
  *
  * @title Get a GUI
  * @method RpgGui.get(id)
  * @param {string} id
  * @returns { { data: any, display: boolean } }
  * @memberof RpgGui
  */
  get(id) {
    if (typeof id != "string") {
      id = id.name;
    }
    return this.gui[id];
  }
  /**
   * Get all GUI. You retrieve GUI data and information whether it is displayed or not
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * const gui = RpgGui.getAll()
   * console.log(gui) // { 'rpg-dialog': { data: {}, display: true } }
   * ```
   *
   * @title Get all GUI
   * @method RpgGui.getAll()
   * @returns { { [guiName]: { data: any, display: boolean }  }}
   * @memberof RpgGui
   */
  getAll() {
    return this.gui;
  }
  /**
   * Checks if the GUI exists RpgClient's gui array
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.exists('my-gui') // true
   * ```
   *
   * @title GUI Exists ?
   * @method RpgGui.exists(id)
   * @param {string} id
   * @returns {boolean}
   * @memberof RpgGui
   */
  exists(id) {
    return !!this.get(id);
  }
  /**
   * Calls a GUI according to identifier. You can send retrievable data in the component
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.display('my-gui')
   * ```
   *
   * @title Display GUI
   * @method RpgGui.display(id,data)
   * @param {string} id
   * @param {object} [data]
   * @returns {void}
   * @memberof RpgGui
   */
  display(id, data = {}) {
    this._setGui(id, {
      display: true,
      data
    });
  }
  /**
   * Hide a GUI according to its identifier
   *
   * ```ts
   * import { RpgGui } from '@rpgjs/client'
   *
   * RpgGui.hide('my-gui')
   * ```
   *
   * @title Hide GUI
   * @method RpgGui.hide(id)
   * @param {string} id
   * @returns {void}
   * @memberof RpgGui
   */
  hide(id) {
    this._setGui(id, {
      display: false
    });
  }
  /** @internal */
  clear() {
    this.gui = {};
  }
  /** @internal */
  tooltipPosition(position) {
    const scene = this.renderer.getScene();
    const viewport = scene == null ? void 0 : scene.viewport;
    if (viewport) {
      const currentZoom = viewport.scale.x;
      const left = (position.x - viewport.left) * currentZoom;
      const top = (position.y - viewport.top) * currentZoom;
      return {
        transform: `translate(${left}px,${top}px)`
      };
    }
    return {};
  }
  /** @internal */
  tooltipFilter(sprites) {
    return sprites.filter((tooltip) => tooltip.guiDisplay);
  }
  /** @internal */
  get listenTooltipObjects() {
    var _a;
    return combineLatest([this.clientEngine.gameEngine.all, (_a = this.currentScene) == null ? void 0 : _a.objectsMoving]).pipe(map$6(([objects]) => {
      return Object.values(objects).map((obj) => obj.object);
    }));
  }
}
const RpgGui = new Gui2();
let Scene$1 = class Scene {
  constructor(context2) {
    this.context = context2;
    this.objects = /* @__PURE__ */ new Map();
    this.animationLayer = new Container();
    this.controls = this.context.inject(KeyboardControls);
    this.animations = [];
    this._data = new BehaviorSubject$1({
      data: {},
      partial: {}
    });
    this.game = this.context.inject(GameEngineClient);
    this.objectsMoving = new Subject$1();
    const {
      globalConfig
    } = this.game.clientEngine;
    const mergeInputs = {
      ...DefaultInput,
      ...globalConfig.inputs || {}
    };
    this.controls.setInputs(this.inputs || mergeInputs);
    RpgGui._setSceneReady(this);
  }
  /**
   * Listen to all the synchronized values of the scene with the server
   *
   * ```ts
   * import { RpgClient, RpgModule, RpgSceneMap } from '@rpgjs/client'
   *
   *  @RpgModule<RpgClient>({
          scenes: {
              map: {
                  onAfterLoading(scene: RpgSceneMap) {
                    scene.valuesChange.subscribe((obj) => {
                       console.log(obj.data, obj.partial)
                    })
                  }
              }
          }
      })
      export default class RpgClientModuleEngine {}
   * ```
   *
   * - `data` represents all the current data of the scene (`users`, `events` and others)
   * - `partial` represents only the data that has changed on the scene
   *
   * > In the class, you can also use the onChanges hook
   *
   *
   * @prop {Observable<{ data: object, partial: object }>} [valuesChange]
   * @readonly
   * @memberof RpgScene
   */
  get valuesChange() {
    return this._data.asObservable();
  }
  triggerSpriteChanges(logic, sprite2, moving2) {
    if (this.onUpdateObject)
      this.onUpdateObject(logic, sprite2, moving2);
    RpgPlugin.emit(HookClient.UpdateSprite, [sprite2, logic], true);
  }
  /** @internal */
  update(obj) {
    if (!obj) {
      this.updateScene(this._data.value);
      return;
    }
    this.updateScene(obj);
    RpgPlugin.emit(HookClient.SceneOnChanges, [this, obj], true);
    this._data.next(obj);
  }
  /** @internal */
  draw(time, deltaTime, deltaRatio, frame) {
    const logicObjects = {
      ...this.game.world.getObjects(),
      ...this.game.events,
      ...this.game.getShapes()
    };
    const renderObjects = this.objects;
    const sizeLogic = Object.values(logicObjects).length;
    const objectMoving = {};
    for (let key in logicObjects) {
      const val = logicObjects[key].object;
      const valueChanged = logicObjects[key].paramsChanged;
      if (!renderObjects.has(key)) {
        const sprite2 = this.addObject(val, key);
        this.triggerSpriteChanges(val, sprite2, true);
      } else {
        const object = renderObjects.get(key);
        if (!(object == null ? void 0 : object.update))
          return;
        const ret = object.update(val, valueChanged, time, deltaRatio);
        this.triggerSpriteChanges(val, object, ret.moving);
        if (ret.moving)
          objectMoving[val.id] = val;
      }
    }
    if (sizeLogic < renderObjects.size) {
      renderObjects.forEach((val, key) => {
        if (!logicObjects[key]) {
          this.removeObject(key);
        }
      });
    }
    for (let animation of this.animations) {
      animation.update(deltaRatio);
    }
    this.onDraw(time);
    if (Object.values(objectMoving).length) {
      this.objectsMoving.next(objectMoving);
    }
    RpgPlugin.emit(HookClient.SceneDraw, this);
  }
  /**
   * Display an animation on the scene
   *
   * The object is the following:
   * * `graphic`: Spritesheet id
   * * `animationName`: The name of the animation
   * * `attachTo`: Define a sprite. The animation will follow this sprite (optional)
   * * `x`: Position X (0 by default)
   * * `y`: Position Y (0 by default)
   * * `loop`: Display the animation in a loop (false by default)
   *
   * ```ts
   * import { RpgClient, RpgModule, RpgSceneMap } from '@rpgjs/client'
   *
    * @RpgModule<RpgClient>({
          scenes: {
              map: {
                  onAfterLoading(scene: RpgSceneMap) {
                      const animation = scene.showAnimation({
                          graphic: 'my-spritesheet',
                          animationName: 'my-anim'
                      })
                  }
              }
          }
      })
      export default class RpgClientModuleEngine {}
   * ```
   *
   * The return is an animation containing two methods:
   * * `play()`: Play the animation (Already the case when calling the method)
   * * `stop()`: Stop the animation
   *
   * They have a hook:
   *
   * `onFinish`: Triggered when the animation is finished
   *
   * ```ts
   * animation.onFinish = () => {
   *      console.log('finish !')
   * }
   * ```
   *
   * @title Show Animation
   * @method scene.showAnimation(object)
   * @param {object} object
   * @returns {Animation}
   * @memberof RpgScene
   */
  showAnimation({
    graphic,
    animationName,
    attachTo,
    x: x2 = 0,
    y: y2 = 0,
    loop = false,
    replaceGraphic = false
  }) {
    if (replaceGraphic && attachTo) {
      attachTo.showAnimation(graphic, animationName);
      return;
    }
    const animation = new Animation(graphic);
    this.animationLayer.addChild(animation);
    if (!loop) {
      animation.onFinish = () => {
        animation.stop();
      };
    }
    if (attachTo) {
      animation.attachTo = attachTo;
    } else {
      animation.x = x2;
      animation.y = y2;
    }
    animation.play(animationName);
    this.animations.push(animation);
    return animation;
  }
  /**
  * Retrieve a sprite according to its identifier
  *
  * @title Get Sprite
  * @method scene.getSprite(id)
  * @param {string} id
  * @returns {RpgSprite | undefined}
  * @memberof RpgScene
  */
  getSprite(id) {
    return this.getPlayer(id);
  }
  getPlayer(id) {
    return this.objects.get(id);
  }
  /**
  * Retrieve a sprite that the player controls
  *
  * @title Get Current Player
  * @method scene.getCurrentPlayer()
  * @returns {RpgSprite | undefined}
  * @memberof RpgScene
  */
  getCurrentPlayer() {
    return this.objects.get(this.game.playerId);
  }
  // Hooks
  onInit() {
  }
  onLoad() {
  }
  onChanges(obj) {
  }
  onDraw(t2) {
  }
  onAddSprite(sprite2) {
  }
  onRemoveSprite(sprite2) {
  }
};
const {
  capitalize
} = Utils$2;
class Character extends Sprite {
  constructor(component, graphic) {
    super();
    this.component = component;
    this.graphic = graphic;
    this.playStandardAnimation = true;
    this.objSaved = {};
    this.data = {};
    this.h = 1;
    this.w = 1;
    this.data = component.logic;
    this.setGraphic(graphic);
  }
  /** @internal */
  showAnimation(graphic, animationName) {
    const refreshAnimation = (graphic2) => {
      this.removeChild(this.animation);
      this.animation = new Animation(graphic2);
      this.addChild(this.animation);
      this.setAnimationAnchor();
    };
    const memoryGraphic = this.graphic;
    let graphicId = "";
    if (isArray$d(graphic)) {
      graphicId = graphic.find((id) => id == this.graphic);
    } else {
      graphicId = graphic;
    }
    if (!graphicId) {
      return null;
    }
    refreshAnimation(graphicId);
    this.component.animationIsPlaying = true;
    this.animation.onFinish = () => {
      this.playStandardAnimation = true;
      this.component.animationIsPlaying = false;
      refreshAnimation(memoryGraphic);
      this.update(this.objSaved);
    };
    this.playStandardAnimation = false;
    this.playAnimation(animationName);
    return this.animation;
  }
  /** @internal */
  setGraphic(graphic) {
    this.children.forEach((graphic2, index2) => {
      if (graphic2.id == this.graphic) {
        this.removeChildAt(index2);
      }
    });
    this.graphic = graphic;
    this.spritesheet = spritesheets.get(this.graphic);
    this.animation = new Animation(this.graphic);
    this.addChild(this.animation);
    this.setAnimationAnchor();
  }
  getGraphicHeight() {
    return this.animation.getSpriteHeight();
  }
  getGraphicWidth() {
    return this.animation.getSpriteWidth();
  }
  animationSprite() {
    return this.animation.animation$;
  }
  setAnimationAnchor() {
    this.animation.hitbox = {
      h: this.data.hHitbox,
      w: this.data.wHitbox
    };
    this.animation.applyTransform = (frame, animation, spritesheet) => {
      const {
        spriteWidth,
        spriteHeight
      } = animation;
      const prop = "spriteRealSize";
      const currentAnchor = frame[prop] || animation[prop] || spritesheet[prop];
      if (currentAnchor) {
        return {};
      }
      return {
        spriteRealSize: {
          width: spriteWidth,
          height: spriteHeight
        }
      };
    };
  }
  /** @internal */
  update(obj, options2 = {}, deltaRatio = 1) {
    const {
      moving: moving2
    } = options2;
    this.data = obj;
    if (this.anim)
      this.anim.update(deltaRatio);
    if (this.animation)
      this.animation.update(deltaRatio);
    if (this.playStandardAnimation) {
      if (moving2) {
        RpgPlugin.emit(HookClient.SpriteMove, this);
        this.playAnimation(Animation$1.Walk);
      } else {
        this.playAnimation(Animation$1.Stand);
      }
    }
    this.objSaved = obj;
    return {
      moving: moving2,
      instance: this
    };
  }
  /** @internal */
  playAnimation(name2) {
    const hook = `onCharacter${capitalize(name2)}`;
    if (!this.spritesheet)
      return;
    if (this.spritesheet[hook]) {
      this.spritesheet[hook](this);
    } else if (this.animation.has(name2)) {
      this.animation.play(name2, [this.data.direction]);
    }
  }
}
Character.id = "graphic";
class RpgSprite extends Character {
}
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e3) {
    }
  }
  return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$1 = root.Symbol, splice = arrayProto.splice;
var Map$1 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGet(object, path2) {
  path2 = isKey(path2, object) ? [path2] : castPath(path2);
  var index2 = 0, length = path2.length;
  while (object != null && index2 < length) {
    object = object[toKey(path2[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var stringToPath = memoize(function(string) {
  string = toString3(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction(value) {
  var tag = isObject(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString3(value) {
  return value == null ? "" : baseToString(value);
}
function get(object, path2, defaultValue2) {
  var result = object == null ? void 0 : baseGet(object, path2);
  return result === void 0 ? defaultValue2 : result;
}
var lodash_get = get;
const get$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_get);
const REGEXP_VAR = /{([^\}]+)}/g;
class AbstractComponent extends Container {
  constructor(component, value) {
    var _a;
    super();
    this.component = component;
    this.value = value;
    this._onRender$ = new Subject$1();
    this._onDestroy$ = new Subject$1();
    this.onRender$ = this._onRender$.asObservable();
    this.game = this.component.game;
    this.firstRender = true;
    this.style = (_a = this.value) == null ? void 0 : _a.style;
    this.cacheText = {};
  }
  getStyle() {
    return this.style || {};
  }
  parseTextAndCache(text) {
    const matches = text.matchAll(REGEXP_VAR);
    this.cacheParams = [...this.cacheParams, ...Array.from(matches).map((match) => match[1])];
    return this.cacheParams;
  }
  replaceText(object, text) {
    return text.replace(REGEXP_VAR, (match, key) => {
      const value = get$1(object, key);
      if (value !== void 0) {
        this.cacheText[key] = value;
        return value ?? "";
      }
      return value ?? this.cacheText[key] ?? "";
    });
  }
  getValue(object, expression) {
    if (typeof expression === "string") {
      const value = get$1(object, expression);
      if (value !== void 0) {
        if (this.cacheParams.indexOf(expression) === -1)
          this.cacheParams.push(expression);
        return value;
      }
    }
    return expression;
  }
  verifyParams() {
    var _a;
    const params = this.component.logic;
    for (const param of this.cacheParams) {
      if (get$1(params, param) === void 0) {
        throw new Error(`Param ${param} not found in object ${(_a = this.component.logic) == null ? void 0 : _a.id}`);
      }
    }
  }
  onInit(cell) {
    var _a;
    this.cell = cell;
    this.verifyParams();
    const render2 = (object) => {
      const opacity = this.getValue(object, this.getStyle().opacity || this.value.opacity);
      if (opacity !== void 0) {
        this.alpha = Math.min(opacity, 1);
      }
    };
    render2(this.component.logic);
    const objectId = (_a = this.component.logic) == null ? void 0 : _a.id;
    this.game.listenObject(objectId).pipe(takeUntil(this._onDestroy$), filter$1((object) => {
      const params = object == null ? void 0 : object.paramsChanged;
      if (!params)
        return false;
      for (const param of this.cacheParams) {
        if (get$1(params, param))
          return true;
      }
      return false;
    })).subscribe(({
      object
    }) => {
      this.updateRender(object, this.firstRender);
      render2(object);
      this.firstRender = false;
      this._onRender$.next(this);
    });
  }
  onRemove() {
    this._onDestroy$.next();
    this._onDestroy$.complete();
  }
}
const DEFAULT_COLOR = "#000000";
class BarComponent extends AbstractComponent {
  constructor() {
    var _a;
    super(...arguments);
    this.barContainer = new Graphics();
    this.barFill = new Graphics();
    this.textContainer = new Text$1("");
    this.barHeight = ((_a = this.value.style) == null ? void 0 : _a.height) || 7;
    this.text = this.value.text || "";
    this.barStyle = this.getStyle();
    this.currentValue = 0;
    this.maxValue = 0;
    this.nextValue = 0;
    this.notifier = new Subject$1();
    this.cacheParams = [];
  }
  get barWidth() {
    var _a, _b;
    return ((_a = this.barStyle) == null ? void 0 : _a.width) || ((_b = this.cell) == null ? void 0 : _b.width) || 0;
  }
  onInit(cell) {
    if (!this.value.style) {
      this.value.style = {
        fillColor: "#ffffff"
      };
    }
    const {
      bgColor = DEFAULT_COLOR,
      borderColor = DEFAULT_COLOR,
      borderWidth = 1,
      borderRadius = 0
    } = this.barStyle || {};
    this.cell = cell;
    const {
      value: color,
      alpha
    } = hexaToNumber(bgColor);
    this.barContainer.beginFill(color, alpha);
    const paramsRect = [0, 0, this.barWidth, this.barHeight];
    if (borderWidth) {
      const {
        value: color2,
        alpha: alpha2
      } = hexaToNumber(borderColor);
      this.barContainer.lineStyle(borderWidth, color2, alpha2);
    }
    if (borderRadius) {
      this.barContainer.drawRoundedRect(...paramsRect, borderRadius);
    } else {
      this.barContainer.drawRect(...paramsRect);
    }
    this.barContainer.endFill();
    this.textContainer.style = {
      fontSize: 10,
      fill: "#ffffff",
      fontWeight: "bold"
    };
    this.textContainer.y -= this.barHeight + this.textContainer.height - 5;
    if (this.text)
      this.addChild(this.textContainer);
    this.addChild(this.barContainer);
    this.barContainer.addChild(this.barFill);
    this.cacheParams = [this.value.current, this.value.max];
    this.updateRender(this.component.logic, true);
    this.firstRender = false;
    super.onInit(cell);
  }
  updateRender(object, firstRender) {
    this.currentValue = this.nextValue;
    this.nextValue = get$1(object, this.value.current) ?? this.nextValue ?? 0;
    this.maxValue = get$1(object, this.value.max) ?? this.maxValue;
    const style = this.barStyle;
    const borderRadius = (style == null ? void 0 : style.borderRadius) ?? 0;
    const borderWidth = (style == null ? void 0 : style.borderWidth) ?? 0;
    if (firstRender) {
      this.currentValue = this.nextValue;
    }
    const getColor2 = (value) => {
      let determineLastColor = DEFAULT_COLOR;
      const percent = Math.max(0, value / this.maxValue * 100);
      const perPercent = style.perPercent;
      if (perPercent) {
        for (const p2 in perPercent) {
          if (percent <= +p2) {
            determineLastColor = perPercent[p2].fillColor;
            break;
          }
        }
      } else {
        determineLastColor = this.value.style.fillColor;
      }
      return determineLastColor;
    };
    let colors = [];
    if (style) {
      colors = transitionColor(getColor2(this.currentValue), getColor2(this.nextValue), 1);
    } else {
      colors = transitionColor(DEFAULT_COLOR, DEFAULT_COLOR, 1);
    }
    const render2 = (up = false) => {
      let currentValue = ~~this.currentValue;
      if (currentValue < 0)
        currentValue = 0;
      if (currentValue > this.maxValue)
        currentValue = this.maxValue;
      const percentBetween = ~~Math.max(0, (currentValue - this.nextValue) * 100 / this.nextValue);
      const colorIndex = Math.max(Math.floor((100 - percentBetween) / (100 / (colors.length - 1))), 0);
      let fillColor = colors[colorIndex];
      this.barFill.clear();
      const {
        value: color,
        alpha
      } = hexaToNumber(fillColor ?? DEFAULT_COLOR);
      this.barFill.beginFill(color, alpha);
      const percent = Math.max(0, currentValue / this.maxValue);
      const bWidth = borderWidth / 4;
      const paramsRect = [bWidth, bWidth, percent * this.barWidth - bWidth, this.barHeight - bWidth];
      if (percent > 0) {
        if (borderRadius) {
          this.barFill.drawRoundedRect(...paramsRect, borderRadius);
        } else {
          this.barFill.drawRect(...paramsRect);
        }
      }
      this.textContainer.text = this.replaceText({
        ...object,
        $current: currentValue,
        $percent: Math.round(percent * 100),
        $max: this.maxValue
      }, this.text);
      this.barFill.endFill();
    };
    if (firstRender) {
      render2();
      return;
    }
    this.notifier.next();
    this.game.clientEngine.tick.pipe(takeUntil(this.notifier)).subscribe(() => {
      const speed = Math.abs(this.currentValue - this.nextValue) / 10;
      let up = false;
      if (this.currentValue < this.nextValue) {
        this.currentValue += speed;
        up = true;
      } else if (this.currentValue > this.nextValue) {
        this.currentValue -= speed;
        up = false;
      }
      render2(up);
      const currentValue = Math.round(this.currentValue);
      if (!up && (~~currentValue <= ~~this.nextValue || currentValue <= 0)) {
        this.notifier.next();
      } else if (up && (~~currentValue >= ~~this.nextValue || currentValue >= this.maxValue)) {
        this.notifier.next();
      }
    });
  }
  onRemove() {
    this.notifier.next();
    this.notifier.complete();
    super.onRemove();
  }
}
BarComponent.id = "bar";
class ShapeComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.type = this.value.type;
    this.container = new Graphics();
    this.cacheParams = [];
  }
  onInit(cell) {
    this.cell = cell;
    this.updateRender(this.component.logic);
    this.addChild(this.container);
    super.onInit(cell);
  }
  updateRender(object) {
    var _a, _b;
    const value = this.value;
    const height = this.getValue(object, value.height) ?? ((_a = this.cell) == null ? void 0 : _a.height) ?? 0;
    const width = this.getValue(object, value.width) ?? ((_b = this.cell) == null ? void 0 : _b.width) ?? 0;
    this.container.clear();
    const {
      value: color,
      alpha
    } = hexaToNumber(this.value.fill);
    this.container.beginFill(color, alpha);
    if (value.line) {
      const {
        value: color2,
        alpha: alpha2
      } = hexaToNumber(value.line.color ?? this.value.fill);
      this.container.lineStyle(this.getValue(object, value.line.width) ?? 1, color2, this.getValue(object, value.line.alpha) ?? alpha2);
    }
    switch (this.type) {
      case "circle":
        this.container.drawCircle(0, 0, this.getValue(object, value.radius));
        break;
      case "ellipse":
        this.container.drawEllipse(0, 0, width, height);
        break;
      case "line":
        if (!value.line) {
          this.container.lineStyle(1, color, alpha);
        }
        this.container.moveTo(this.getValue(object, value.x1), this.getValue(object, value.y1));
        this.container.lineTo(this.getValue(object, value.x2), this.getValue(object, value.y2));
        break;
      case "polygon":
        this.container.drawPolygon(value.points);
        break;
      case "rounded-rect":
        this.container.drawRoundedRect(0, 0, width, height, value.radius);
        break;
      default:
        this.container.drawRect(0, 0, width, height);
        break;
    }
    this.container.endFill();
  }
}
ShapeComponent.id = "shape";
class DebugComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.color = "#ff0000";
    this.cacheParams = ["map", "position.x", "position.y"];
    this.container = new Graphics();
  }
  onInit(cell) {
    this.addChild(this.container);
    this.updateRender(this.component.logic);
    this.eventMode = "static";
    this.on("pointerdown", () => {
      console.log(this.component.logic);
    });
    super.onInit(cell);
  }
  updateRender(object) {
    const hitbox = object.hitbox;
    const {
      pos,
      w: w2,
      h: h2
    } = hitbox;
    this.container.clear();
    const {
      value: color,
      alpha
    } = hexaToNumber(this.color);
    this.container.beginFill(color, alpha);
    this.container.drawRect(0, 0, w2, h2);
    this.container.endFill();
  }
}
DebugComponent.id = "debug";
class ImageComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.source = "";
  }
  onInit(cell) {
    super.onInit(cell);
    this.setImage();
  }
  setImage() {
    if (typeof this.value == "string") {
      this.source = this.value;
    } else {
      this.source = this.value.source;
    }
    this.updateRender({});
  }
  updateRender(object) {
    this.removeChildren();
    const engine = this.component.getScene().game.clientEngine;
    this.addChild(Sprite.from(engine.getResourceUrl(this.source)));
  }
}
ImageComponent.id = "image";
class TextComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.container = new Text$1("");
    this.originValue = "";
  }
  onInit(cell) {
    if (typeof this.value == "string") {
      this.container.text = this.value;
    } else if (this.value.style) {
      this.container.style = this.value.style;
      this.container.text = this.value.text;
    }
    this.container.style = {
      ...this.container.style,
      wordWrapWidth: cell.width
    };
    this.parseTextAndCache(this.container.text);
    this.originValue = this.container.text;
    this.updateRender(this.component.logic);
    this.addChild(this.container);
    super.onInit(cell);
  }
  updateRender(object) {
    this.container.text = this.replaceText(object, this.originValue);
  }
}
TextComponent.id = "text";
class TileComponent extends AbstractComponent {
  constructor() {
    super(...arguments);
    this.cacheParams = [];
    this.gid = 0;
  }
  onInit(cell) {
    this.cell = cell;
    if (typeof this.value == "number") {
      this.gid = this.value;
    } else {
      this.gid = this.value.gid;
    }
    this.updateRender({});
    super.onInit(cell);
  }
  updateRender(object) {
    var _a, _b;
    this.removeChildren();
    const height = typeof this.value != "number" ? this.getValue(object, this.value.height) : ((_a = this.cell) == null ? void 0 : _a.height) ?? 0;
    const width = typeof this.value != "number" ? this.getValue(object, this.value.width) : ((_b = this.cell) == null ? void 0 : _b.width) ?? 0;
    const scene = this.component.getScene();
    const tilemap = scene.tilemap;
    const tileset = TileLayer.findTileSet(this.gid, tilemap.tilesets);
    if (tileset) {
      const tile = new Tile2({
        gid: this.gid
      }, tileset);
      tile.width = width ?? 0;
      tile.height = height ?? 0;
      this.addChild(tile);
    }
  }
}
TileComponent.id = "tile";
const layoutObject = {
  lines: []
};
const layoutTypes = ["top", "bottom", "left", "right"];
class RpgComponent extends Container {
  constructor(data, scene) {
    super();
    this.data = data;
    this.scene = scene;
    this.h = 1;
    this.w = 1;
    this.animationIsPlaying = false;
    this._x = 0;
    this._y = 0;
    this._rotation = 0;
    this.teleported = 0;
    this.map = "";
    this.z = 0;
    this.fixed = false;
    this.components = {
      top: layoutObject,
      bottom: layoutObject,
      left: layoutObject,
      right: layoutObject,
      center: layoutObject
    };
    this.direction = 0;
    this.container = new Container();
    this.containersLayout = {};
    this.layoutNotifierClear = {
      top: new Subject$1(),
      bottom: new Subject$1(),
      left: new Subject$1(),
      right: new Subject$1(),
      center: new Subject$1()
    };
    this.registerComponents = /* @__PURE__ */ new Map();
    this.game = this.scene.game;
    this.id = this.data.id;
    this.setPosition(false);
    this.registerComponents.set(RpgSprite.id, RpgSprite);
    this.registerComponents.set(TextComponent.id, TextComponent);
    this.registerComponents.set(ShapeComponent.id, ShapeComponent);
    this.registerComponents.set(TileComponent.id, TileComponent);
    this.registerComponents.set(ImageComponent.id, ImageComponent);
    this.registerComponents.set(BarComponent.id, BarComponent);
    this.registerComponents.set(DebugComponent.id, DebugComponent);
    this.addChild(this.container);
    for (let layout of [...layoutTypes, "center"]) {
      this.containersLayout[layout] = new Container();
      this.container.addChild(this.containersLayout[layout]);
    }
    RpgPlugin.emit(HookClient.AddSprite, this);
    RpgPlugin.emit(HookClient.SceneAddSprite, [this.scene, this], true);
    this.game.listenObject(data.id).pipe(takeUntil(this.game.getDeleteNotifier(data.id)), map$6((object) => object == null ? void 0 : object.paramsChanged), tap(() => {
      var _a, _b;
      RpgPlugin.emit(HookClient.ChangesSprite, [this, (_a = this.logic) == null ? void 0 : _a["paramsChanged"], (_b = this.logic) == null ? void 0 : _b["prevParamsChanged"]], true);
    }), filter$1((object) => {
      var _a;
      return (_a = this.logic) == null ? void 0 : _a["componentChanged"];
    })).subscribe((val) => {
      var _a;
      if (this.logic) {
        this.updateComponents((_a = this.logic) == null ? void 0 : _a["componentChanged"]);
        this.logic["componentChanged"] = void 0;
      }
    });
  }
  /**
   * the direction of the sprite
   *
   * @prop {Direction} dir
   * @readonly
   * @memberof RpgSprite
   * */
  get dir() {
    return this.direction;
  }
  /**
  * To know if the sprite is a player
  *
  * @prop {boolean} isPlayer
  * @readonly
  * @memberof RpgSprite
  * */
  get isPlayer() {
    return this.data.type == PlayerType.Player;
  }
  /**
   * To know if the sprite is an event
   *
   * @prop {boolean} isEvent
   * @readonly
   * @memberof RpgSprite
   * */
  get isEvent() {
    return this.data.type == PlayerType.Event;
  }
  /**
   * To know if the sprite is a shape
   *
   * @prop {boolean} isShape
   * @since 3.0.0-rc
   * @readonly
   * @memberof RpgSprite
   * */
  get isShape() {
    return isInstanceOf$3(this.data, RpgShape);
  }
  /**
   * To know if the sprite is the sprite controlled by the player
   *
   * @prop {boolean} isCurrentPlayer
   * @readonly
   * @memberof RpgSprite
   * */
  get isCurrentPlayer() {
    return this.data.id === this.scene.game.playerId;
  }
  /**
   * Retrieves the logic of the sprite
   *
   * @prop {RpgSpriteLogic} logic
   * @readonly
   * @since 3.0.0-beta.4
   * @memberof RpgSprite
   * */
  get logic() {
    return this.scene.game.world.getAll(this.data.id);
  }
  get guiDisplay() {
    return this.logic.guiDisplay;
  }
  set guiDisplay(val) {
    var _a;
    this.logic.guiDisplay = val;
    this.game.setObject((_a = this.logic) == null ? void 0 : _a.id, {
      object: this.logic,
      paramsChanged: {
        guiDisplay: val
      }
    });
  }
  setPosition(smooth = true) {
    if (this.isShape) {
      const {
        width,
        height,
        x: x2,
        y: y2
      } = this.data;
      this.w = width;
      this.h = height;
      this._x = Math.floor(x2);
      this._y = Math.floor(y2);
    } else {
      const {
        position,
        direction
      } = this.data;
      this._x = (position == null ? void 0 : position.x) ?? 0;
      this._y = (position == null ? void 0 : position.y) ?? 0;
      this.z = (position == null ? void 0 : position.z) ?? 0;
      this.direction = direction;
    }
    this._rotation = this.data["rotation"] ?? 0;
    if (!smooth) {
      this.x = this._x;
      this.y = this._y;
      this.angle = this._rotation;
    }
  }
  // TODO
  /*drag() {
      this.interactive = true
      const filter = new filters.ColorMatrixFilter();
       const onDragEnd = () => {
          if (!this.dragMode) return
          this.dragMode.dragging = false
          this.dragMode.data = null
      }
       this
          .on('pointerdown', (event) => {
              this.dragMode = {
                  data: event.data,
                  dragging: true
              }
          })
          .on('pointerup', onDragEnd)
          .on('pointerupoutside', onDragEnd)
          .on('pointermove', () => {
              if (!this.dragMode) return
              const { dragging, data } = this.dragMode
              if (dragging) {
                  const newPosition = data.getLocalPosition(this.parent)
                  this.x = newPosition.x
                  this.y = newPosition.y
              }
          })
  }*/
  update(obj, objChanged, time, deltaRatio) {
    var _a;
    if ((_a = this.dragMode) == null ? void 0 : _a.dragging)
      return {
        moving: true
      };
    const {
      speed,
      teleported,
      map: map2,
      fixed
    } = obj;
    this.data = obj;
    this.setPosition();
    const renderSpeed = speed * deltaRatio;
    if (this._rotation != this.angle) {
      this.angle += Math.min(renderSpeed, this._rotation - this.angle);
    }
    let moving2 = obj.moving ?? false;
    if (!fixed) {
      if (teleported != this.teleported || map2 != this.map) {
        this.x = this._x;
        this.y = this._y;
        this.teleported = teleported;
        this.map = map2;
      }
      this.parent.parent.zIndex = this._y;
      obj.posX = this._x;
      obj.posY = this._y;
      if (this._x > this.x) {
        this.x += Math.min(renderSpeed, this._x - this.x);
        moving2 = true;
      }
      if (this._x < this.x) {
        this.x -= Math.min(renderSpeed, this.x - this._x);
        moving2 = true;
      }
      if (this._y > this.y) {
        this.y += Math.min(renderSpeed, this._y - this.y);
        moving2 = true;
      }
      if (this._y < this.y) {
        this.y -= Math.min(renderSpeed, this.y - this._y);
        moving2 = true;
      }
    }
    this.callMethodInComponents("update", [obj, {
      moving: moving2
    }, deltaRatio]);
    this.onUpdate(obj);
    return {
      moving: moving2
    };
  }
  showAnimation(graphic, animationName) {
    return this.callMethodInComponents("showAnimation", [graphic, animationName]);
  }
  /**
  * Recover the position according to the graphic
  * Normally, the position is that of the hitbox but, we retrieve the top left corner of the graphic
  *
  * You can also pass the `middle` value as first parameter to retrieve the positions from the middle of the sprite
  *
  * @title Get Positions of Graphic
  * @method sprite.getPositionsOfGraphic(align)
  * @param {string} [align] middle
  * @returns { x: number, y: number }
  * @memberof RpgSprite
  */
  getPositionsOfGraphic(align) {
    var _a;
    let sprite2;
    if (((_a = this.components.center) == null ? void 0 : _a.lines.length) !== 0) {
      sprite2 = this.containersLayout.center.getChildAt(0);
    }
    const isMiddle = align == "middle";
    return {
      x: this.x - this.w * ((sprite2 == null ? void 0 : sprite2.anchor.x) ?? 1) + (isMiddle ? this.w / 2 : 0),
      y: this.y - this.h * ((sprite2 == null ? void 0 : sprite2.anchor.y) ?? 1) + (isMiddle ? this.h / 2 : 0)
    };
  }
  /**
   * Get the container by position (center, left, right, top, bottom)
   *
   * @param {LayoutPositionEnum} [position=center]
   * @returns {PIXI.Container}
   *
   * */
  getLayoutContainer(position = "center") {
    return this.containersLayout[position];
  }
  /**
   * Get Current Scene. Scene is a map, battle, menu, etc.
   * @returns {T}
   */
  getScene() {
    return this.scene;
  }
  // Hooks
  onInit() {
  }
  onUpdate(obj) {
  }
  onMove() {
  }
  onChanges(data, old) {
  }
  callMethodInComponents(name2, params) {
    for (let component of this.getLayoutContainer().children) {
      if (component[name2])
        component[name2](...params);
    }
  }
  createGrid(position, gridArray, options2, sprite2) {
    var _a, _b;
    const gridContainer = new Sprite();
    const {
      height,
      spriteWidth,
      spriteHeight
    } = sprite2;
    const width = options2.width ?? spriteWidth ?? sprite2.width;
    const gridHeight = options2.height ?? 20;
    const hitBoxWidth = ((_a = this.logic) == null ? void 0 : _a.hitbox.w) ?? 0;
    const middleWidth = hitBoxWidth / 2 - width / 2;
    const posX = gridContainer.x + (options2.marginLeft ?? 0) - (options2.marginRight ?? 0);
    const posY = gridContainer.y + (((_b = this.logic) == null ? void 0 : _b.hitbox.h) ?? 0) + (options2.marginTop ?? 0) - (options2.marginBottom ?? 0);
    switch (position) {
      case "top":
        gridContainer.x = posX + middleWidth;
        gridContainer.y = posY - spriteHeight;
        gridContainer.y -= gridArray.length * gridHeight;
        break;
      case "bottom":
        gridContainer.x = posX + middleWidth;
        gridContainer.y = posY;
        break;
      case "left":
        gridContainer.x = posX - width - (hitBoxWidth < spriteWidth ? hitBoxWidth / 2 : 0);
        gridContainer.y = posY - spriteHeight;
        break;
      case "right":
        gridContainer.x = posX + width + (hitBoxWidth > spriteWidth ? hitBoxWidth / 2 : 0);
        gridContainer.y = posY - spriteHeight;
    }
    for (let y2 = 0; y2 < gridArray.length; y2++) {
      const columns = gridArray[y2].col.length;
      const cellWidth = width / columns;
      for (let x2 = 0; x2 < columns; x2++) {
        const params = gridArray[y2].col[x2];
        const component = this.applyComponent(params);
        component.onRender$.pipe(takeUntil(this.layoutNotifierClear[position]), finalize(() => {
          component.onRemove();
        })).subscribe(() => {
          component.x = Math.round(x2 * cellWidth + cellWidth / 2 - component.width / 2);
          component.y = Math.round(y2 * gridHeight + gridHeight / 2 - component.height / 2);
        });
        component.onInit({
          width: cellWidth,
          height: gridHeight
        });
        gridContainer.addChild(component);
      }
    }
    return gridContainer;
  }
  applyComponent(component) {
    const compClass = this.registerComponents.get(component.id);
    if (!compClass) {
      throw log(`Impossible to find ${component.id} component`);
    }
    return new compClass(this, component.value);
  }
  createComponentCenter(components) {
    var _a, _b, _c;
    const lines = ((_a = components.center) == null ? void 0 : _a.lines) || [];
    this.getLayoutContainer().removeChildren();
    for (let {
      col
    } of lines) {
      for (let component of col) {
        const instance = this.applyComponent(component);
        if (instance.onInit)
          instance.onInit({
            width: ((_b = this.logic) == null ? void 0 : _b.width) ?? this.width,
            height: ((_c = this.logic) == null ? void 0 : _c.height) ?? this.height
          });
        this.getLayoutContainer().addChild(instance);
      }
    }
    this.components = components;
  }
  refreshComponents(components, sprite2) {
    for (let type of layoutTypes) {
      const layout = components[type];
      if (layout == null ? void 0 : layout.lines) {
        const layoutContainer = this.getLayoutContainer(type);
        layoutContainer.removeChildren();
        this.layoutNotifierClear[type].next();
        layoutContainer.addChild(this.createGrid(type, layout.lines, layout, sprite2));
      }
    }
  }
  updateComponents(components) {
    var _a;
    const graphicChanged = !!((_a = components.center) == null ? void 0 : _a.lines);
    if (graphicChanged) {
      this.createComponentCenter(components);
    }
    if (this.subscriptionGraphic)
      this.subscriptionGraphic.unsubscribe();
    const child = this.getLayoutContainer().children[0];
    if (child instanceof RpgSprite) {
      this.subscriptionGraphic = child.animationSprite().pipe(takeUntil(this.game.getDeleteNotifier(this.id)), filter$1((sprite2) => sprite2), distinctUntilChanged((p2, q2) => p2.width === q2.width && p2.height === q2.height && p2.anchor.x === q2.anchor.x && p2.anchor.y === q2.anchor.y)).subscribe((sprite2) => {
        this.refreshComponents(components, sprite2);
      });
    } else {
      this.refreshComponents(components, {
        width: this.data.width,
        height: this.data.height,
        anchor: {
          x: 0,
          y: 0
        },
        x: 0,
        y: 0,
        spriteHeight: this.data.height,
        spriteWidth: this.data.width
      });
    }
  }
}
class EventLayer extends Container {
  constructor() {
    super();
    this.sortableChildren = true;
  }
}
const {
  Viewport: PixiViewport
} = _PixiViewport;
class SceneMap2 extends Scene$1 {
  constructor(context2, renderer2, options2 = {}) {
    super(context2);
    this.context = context2;
    this.renderer = renderer2;
    this.options = options2;
    this.players = {};
    this.isLoaded = false;
    this.eventsLayers = {};
    this.shapes = {};
    if (options2.drawMap === void 0)
      this.options.drawMap = true;
    this.onInit();
  }
  constructMethods() {
    ["getTileIndex", "getTileByIndex", "getTileOriginPosition", "getTileByPosition", "getLayerByName"].forEach((method) => this[method] = this.gameMap[method].bind(this.gameMap));
    ["heightPx", "widthPx", "zTileHeight", "tileHeight", "tileWidth", "data", "layers"].forEach((prop) => this[prop] = this.gameMap[prop]);
  }
  /** @internal */
  async load(obj, prevObj, isUpdate = false) {
    let {
      sounds: sounds2
    } = obj;
    const {
      clientEngine
    } = this.game;
    if (sounds2) {
      if (!isArray$d(sounds2))
        sounds2 = obj.sounds = [sounds2];
    }
    this.gameMap = new RpgCommonMap();
    this.gameMap.load(obj);
    this.gameMap.clearCacheTilesets();
    this.constructMethods();
    RpgCommonMap.bufferClient.set(obj.id, this.gameMap);
    this.tilemap = new TileMap(this.context, this.gameMap.getData());
    Assets.reset();
    let nbLoad = 0;
    const objects = this.game.world.getObjectsOfGroup();
    for (let {
      object
    } of Object.values(objects)) {
      if (isInstanceOf$3(object, RpgCommonPlayer) && object) {
        object.updateInVirtualGrid();
      }
    }
    const assets = [];
    for (let tileset of this.tilemap.tilesets) {
      let spritesheet = spritesheets.get(tileset.name);
      if (!spritesheet) {
        clientEngine.addSpriteSheet(tileset.image.source, tileset.name);
        spritesheet = spritesheets.get(tileset.name);
      }
      if (spritesheet == null ? void 0 : spritesheet.resource) {
        continue;
      }
      Assets.add(tileset.name, spritesheet.image);
      assets.push(tileset.name);
      nbLoad++;
    }
    if (nbLoad > 0) {
      const assetsLoaded = await Assets.load(assets);
      for (let assetName in assetsLoaded) {
        const spritesheet = spritesheets.get(assetName);
        if (spritesheet)
          spritesheet.resource = assetsLoaded[assetName];
      }
    }
    RpgPlugin.emit(HookClient.SceneMapLoading, Assets);
    this.tilemap.load({
      drawTiles: this.options.drawMap,
      isUpdate
    });
    this.viewport = new PixiViewport({
      screenWidth: this.options.screenWidth,
      screenHeight: this.options.screenHeight,
      worldWidth: obj.width * obj.tilewidth,
      worldHeight: obj.height * obj.tileheight,
      noTicker: true,
      events: this.renderer.events
    });
    this.tilemap.addChild(this.animationLayer);
    this.viewport.clamp({
      direction: "all"
    });
    this.viewport.addChild(this.tilemap, ...this.createEventLayers(obj));
    this.isLoaded = true;
    if (prevObj.sounds && prevObj.sounds instanceof Array) {
      prevObj.sounds.forEach((soundId) => {
        const continueSound = (obj.sounds || []).find((id) => id == soundId);
        if (!continueSound)
          RpgSound.stop(soundId);
      });
    }
    if (sounds2)
      sounds2.forEach((soundId) => RpgSound.play(soundId));
    if (this.onLoad)
      this.onLoad();
    return this.viewport;
  }
  createEventLayers(map2) {
    const containers = [];
    map2.layers.forEach((layerData) => {
      if (layerData.type !== TiledLayerType.ObjectGroup)
        return;
      if (this.eventsLayers[layerData.name]) {
        containers.push(this.eventsLayers[layerData.name]);
        return;
      }
      const layer = new EventLayer();
      this.defaultLayer = this.eventsLayers[layerData.name] = layer;
      containers.push(layer);
    });
    if (containers.length == 0) {
      if (!this.defaultLayer) {
        this.defaultLayer = new EventLayer();
      }
      containers.push(this.defaultLayer);
    }
    this.cameraFollowSprite(this.game.playerId);
    return containers;
  }
  getEventLayer(objectName) {
    for (let layerData of this.data.layers) {
      if (layerData.type != TiledLayerType.ObjectGroup) {
        continue;
      }
      if (!layerData.objects) {
        continue;
      }
      for (let object of layerData.objects) {
        if (object.name == objectName) {
          return this.eventsLayers[layerData.name];
        }
      }
    }
    return this.defaultLayer;
  }
  /** @internal */
  changeTile(x2, y2, layers) {
    var _a;
    for (let layerName in layers) {
      const layerInfo = layers[layerName];
      (_a = this.gameMap) == null ? void 0 : _a.setTile(x2, y2, layerName, layerInfo);
      this.tilemap.changeTile(x2, y2, layerName);
    }
  }
  /** @internal */
  draw(t2, deltaTime, deltaRatio, frame) {
    var _a;
    if (!this.isLoaded) {
      return;
    }
    super.draw(t2, deltaTime, deltaRatio, frame);
    this.tilemap.drawAnimateTile(frame);
    (_a = this.viewport) == null ? void 0 : _a.update(deltaTime);
  }
  // @internal
  updateTilesOverlayAllSprites() {
    const objects = this.objects;
    for (let [id, sprite2] of objects) {
      this.updateTilesOverlay(sprite2);
    }
  }
  updateTilesOverlay(sprite2) {
    if (!this.gameMap)
      return sprite2;
    const {
      tileWidth,
      tileHeight
    } = this.gameMap;
    const {
      tilesOverlay
    } = sprite2;
    const bounds = sprite2.parent.getLocalBounds();
    const width = Math.ceil(bounds.width / tileWidth) * tileWidth;
    const height = Math.ceil(bounds.height / tileHeight) * tileHeight;
    const _x = bounds.x;
    const _y = bounds.y;
    const addTile = (x2, y2) => {
      const tiles = this.tilemap.createOverlayTiles(x2, y2, sprite2);
      if (tiles.length)
        tilesOverlay.addChild(...tiles);
    };
    tilesOverlay.removeChildren();
    for (let i2 = _x; i2 <= _x + width; i2 += tileWidth) {
      for (let j2 = _y; j2 <= _y + height; j2 += tileHeight) {
        addTile(i2, j2);
      }
    }
    return sprite2;
  }
  onUpdateObject(logic, sprite2, moving2) {
    const {
      paramsChanged
    } = logic;
    if (!this.gameMap)
      return sprite2;
    if (moving2 || paramsChanged && (paramsChanged.width || paramsChanged.height)) {
      this.updateTilesOverlay(sprite2);
    }
    return sprite2;
  }
  /** @internal */
  setPlayerPosition(id, {
    x: x2,
    y: y2
  }) {
    this.players[id].x = x2;
    this.players[id].y = y2;
  }
  /** @internal */
  updateScene(obj) {
  }
  addObject(obj, id) {
    var _a;
    const wrapper = new Container();
    const inner = new Container();
    const tilesOverlay = new Container();
    const component = new RpgComponent(obj, this);
    component.tilesOverlay = tilesOverlay;
    inner.addChild(component);
    wrapper.addChild(inner, tilesOverlay);
    this.objects.set(id, component);
    (_a = this.getEventLayer(obj.id)) == null ? void 0 : _a.addChild(wrapper);
    if (component.isCurrentPlayer)
      this.cameraFollowSprite(id);
    component.onInit();
    return component;
  }
  removeObject(id) {
    let sprite2 = this.objects.get(id);
    if (sprite2) {
      if (!sprite2.animationIsPlaying) {
        this.objects.delete(id);
        RpgPlugin.emit(HookClient.SceneRemoveSprite, [this, sprite2], true);
        RpgPlugin.emit(HookClient.RemoveSprite, sprite2);
        sprite2.destroy();
      } else {
        sprite2.visible = false;
      }
    }
  }
  getShape(name2) {
    var _a;
    return (_a = this.game.getShape(name2)) == null ? void 0 : _a.object;
  }
  getShapes() {
    const shapes = Object.values(this.game.getShapes());
    return shapes.map((shape) => shape.object);
  }
  cameraFollowSprite(id, options2 = {}) {
    var _a, _b;
    const sprite2 = this.getSprite(id);
    const follow = () => {
      var _a2;
      if (sprite2)
        (_a2 = this.viewport) == null ? void 0 : _a2.follow(sprite2);
    };
    if (options2.smoothMove) {
      (_a = this.viewport) == null ? void 0 : _a.plugins.remove("follow");
      let moreOptions = {};
      if (typeof options2.smoothMove != "boolean") {
        moreOptions = options2.smoothMove;
      }
      (_b = this.viewport) == null ? void 0 : _b.animate({
        position: new Point(sprite2 == null ? void 0 : sprite2.x, sprite2 == null ? void 0 : sprite2.y),
        ...moreOptions,
        callbackOnComplete: follow
      });
    } else {
      follow();
    }
  }
  /**
   * Listen to the events of the smile on the stage
   *
   * @title Listen mouse event
   * @method on(eventName,callback)
   * @since 3.0.0-beta.4
   * @param {string} eventName  Name of the event (see PIXI documentation). Name often used in the codes
   * - click
   * - mousedown
   * - mouseup
   * - mousemove
   * - pointerdown
   * - pointermove
   * - pointerup
   * - (etc...)
   * @param {(position: { x: number, y: number }, ev?: PIXI.InteractionEvent ) => any} callback
   * @example
   * ```ts
   * sceneMap.on('pointerdown', (position) => {
   *      console.log(position)
   * })
   * ```
   * @returns {void}
   * @memberof RpgSceneMap
   */
  on(eventName, cb) {
    if (!this.viewport)
      return;
    this.viewport.eventMode = "static";
    this.viewport.on(eventName, (...args) => {
      const ev = args[0];
      const pos = ev.getLocalPosition(this.viewport);
      if (ev.defaultPrevented)
        return;
      cb(pos, ev);
    });
  }
}
SceneMap2.EVENTS_LAYER_DEFAULT = "events-layer-default";
var Scene2;
(function(Scene3) {
  Scene3["Map"] = "map";
})(Scene2 || (Scene2 = {}));
const Ease = {
  linear: (time, _from, to, duration) => {
    return _from + (to - _from) * time / duration;
  },
  easeInQuad: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time + _from;
  },
  easeOutQuad: (time, _from, to, duration) => {
    time /= duration;
    return -(to - _from) * time * (time - 2) + _from;
  },
  easeInOutQuad: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time + _from;
    time--;
    return -((to - _from) / 2) * (time * (time - 2) - 1) + _from;
  },
  easeInCubic: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time + _from;
  },
  easeOutCubic: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * (time * time * time + 1) + _from;
  },
  easeInOutCubic: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * time + 2) + _from;
  },
  easeInQuart: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time * time + _from;
  },
  easeOutQuart: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return -(to - _from) * (time * time * time * time - 1) + _from;
  },
  easeInOutQuart: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time * time + _from;
    time -= 2;
    return -(to - _from) / 2 * (time * time * time * time - 2) + _from;
  },
  easeInQuint: (time, _from, to, duration) => {
    time /= duration;
    return (to - _from) * time * time * time * time * time + _from;
  },
  easeOutQuint: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * (time * time * time * time * time + 1) + _from;
  },
  easeInOutQuint: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * time * time * time * time * time + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * time * time * time + 2) + _from;
  },
  easeInSine: (time, _from, to, duration) => {
    return -(to - _from) * Math.cos(time / duration * (Math.PI / 2)) + (to - _from) + _from;
  },
  easeOutSine: (time, _from, to, duration) => {
    return (to - _from) * Math.sin(time / duration * (Math.PI / 2)) + _from;
  },
  easeInOutSine: (time, _from, to, duration) => {
    return -(to - _from) / 2 * (Math.cos(Math.PI * time / duration) - 1) + _from;
  },
  easeInExpo: (time, _from, to, duration) => {
    return time === 0 ? _from : (to - _from) * Math.pow(2, 10 * (time / duration - 1)) + _from;
  },
  easeOutExpo: (time, _from, to, duration) => {
    return time === duration ? to : (to - _from) * (-Math.pow(2, -10 * time / duration) + 1) + _from;
  },
  easeInOutExpo: (time, _from, to, duration) => {
    if (time === 0)
      return _from;
    if (time === duration)
      return to;
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * Math.pow(2, 10 * (time - 1)) + _from;
    return (to - _from) / 2 * (-Math.pow(2, -10 * --time) + 2) + _from;
  },
  easeInCirc: (time, _from, to, duration) => {
    time /= duration;
    return -(to - _from) * (Math.sqrt(1 - time * time) - 1) + _from;
  },
  easeOutCirc: (time, _from, to, duration) => {
    time /= duration;
    time--;
    return (to - _from) * Math.sqrt(1 - time * time) + _from;
  },
  easeInOutCirc: (time, _from, to, duration) => {
    time /= duration / 2;
    if (time < 1)
      return -(to - _from) / 2 * (Math.sqrt(1 - time * time) - 1) + _from;
    time -= 2;
    return (to - _from) / 2 * (Math.sqrt(1 - time * time) + 1) + _from;
  },
  easeInElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration;
    if (time === 1)
      return to;
    if (period === 0)
      period = duration * 0.3;
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    time--;
    return -(amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period)) + _from;
  },
  easeOutElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration;
    if (time === 1)
      return to;
    if (period === 0)
      period = duration * 0.3;
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period) + (to - _from) + _from;
  },
  easeInOutElastic: (time, _from, to, duration, amplitude = 0, period = 0) => {
    if (time === 0)
      return _from;
    time /= duration / 2;
    if (time === 2)
      return to;
    if (period === 0)
      period = duration * (0.3 * 1.5);
    let s2;
    if (amplitude < Math.abs(to - _from)) {
      amplitude = to - _from;
      s2 = period / 4;
    } else {
      s2 = period / (2 * Math.PI) * Math.asin((to - _from) / amplitude);
    }
    if (time < 1) {
      time--;
      return -0.5 * (amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period)) + _from;
    }
    time--;
    return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s2) * (2 * Math.PI) / period) * 0.5 + (to - _from) + _from;
  },
  // ...
  easeInBack: (time, _from, to, duration, s2 = 1.70158) => {
    time /= duration;
    return (to - _from) * time * time * ((s2 + 1) * time - s2) + _from;
  },
  easeOutBack: (time, _from, to, duration, s2 = 1.70158) => {
    time = time / duration - 1;
    return (to - _from) * (time * time * ((s2 + 1) * time + s2) + 1) + _from;
  },
  easeInOutBack: (time, _from, to, duration, s2 = 1.70158) => {
    s2 *= 1.525;
    time /= duration / 2;
    if (time < 1)
      return (to - _from) / 2 * (time * time * ((s2 + 1) * time - s2)) + _from;
    time -= 2;
    return (to - _from) / 2 * (time * time * ((s2 + 1) * time + s2) + 2) + _from;
  },
  easeInBounce: (time, _from, to, duration) => {
    return to - _from - Ease.easeOutBounce(duration - time, 0, to - _from, duration) + _from;
  },
  easeOutBounce: (time, _from, to, duration) => {
    time /= duration;
    let multiplier = 7.5625;
    if (time < 1 / 2.75) {
      return (to - _from) * (multiplier * time * time) + _from;
    } else if (time < 2 / 2.75) {
      time -= 1.5 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.75) + _from;
    } else if (time < 2.5 / 2.75) {
      time -= 2.25 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.9375) + _from;
    } else {
      time -= 2.625 / 2.75;
      return (to - _from) * (multiplier * time * time + 0.984375) + _from;
    }
  },
  easeInOutBounce: (time, _from, to, duration) => {
    if (time < duration / 2)
      return Ease.easeInBounce(time * 2, 0, to - _from, duration) * 0.5 + _from;
    return Ease.easeOutBounce(time * 2 - duration, 0, to - _from, duration) * 0.5 + (to - _from) * 0.5 + _from;
  }
};
class Timeline {
  constructor(options2) {
    this.time = 0;
    this.animation = [];
    this.keyframes = 10;
    if (options2) {
      if (options2.keyframes)
        this.keyframes = options2.keyframes;
    }
  }
  /**
   * Allows you to create complex animations more easily. For example, to display a movement with an Easing function
   *
   * ```ts
   * import { Timeline, Ease } from '@rpgjs/client'
   *
   * new Timeline()
   *      .add(30, ({ scale }) => [{
   *          frameX: 0,
   *          frameY: 1,
   *          scale: [scale]
   *      }], {
   *          scale: {
   *              from: 0,
   *              to: 1,
   *              easing: Ease.easeOutBounce
   *          }
   *      })
   *      .add(100)
   *      .create()
   * ```
   *
   * Here we say
   *
   * - Duration in frames, allowing you to specify the duration of each animation step. If the timeline respects a specific frame rate, e.g. 60 frames per second, 40 frames correspond to an animation duration of 2/3 of a second for each step.
   * - A function that will be called every 1 frame with the `scale` property defined in transform
   * - An object of transformation. Define the properties of your choice to be passed to the callback function
   *      - `to`: the starting value
   *      - `from`: the end value
   *      - `easing`: An easing function (By default, it is a linear function)
   *
   * Note that if you just put a duration (`add(100)`), it will only put a pause on the animation
   *
   * Easing functions available but you can create your own
   *
   * ```ts
   * function myEase(t: number, b: number, c: number, d: number): number { }
   * ```
   *
   * `t`: current time
   * `b`: start value
   * `c`: end value
   * `d`: duration
   *
   * @title Add Animation in timeline
   * @enum {Function}
   *
   * Ease.linear | linear
  * Ease.easeInQuad | easeInQuad
  * Ease.easeOutQuad | easeOutQuad
  * Ease.easeInOutQuad | easeInOutQuad
  * Ease.easeInCubic | easeInCubic
  * Ease.easeOutCubic | easeOutCubic
  * Ease.easeInOutCubic | easeInOutCubic
  * Ease.easeInQuart | easeInQuart
  * Ease.easeOutQuart | easeOutQuart
  * Ease.easeInOutQuart | easeInOutQuart
  * Ease.easeInQuint | easeInQuint
  * Ease.easeOutQuint | easeOutQuint
  * Ease.easeInOutQuint | easeInOutQuint
  * Ease.easeInSine | easeInSine
  * Ease.easeOutSine | easeOutSine
  * Ease.easeInOutSine | easeInOutSine
  * Ease.easeInExpo | easeInExpo
  * Ease.easeOutExpo | easeOutExpo
  * Ease.easeInOutExpo | easeInOutExpo
  * Ease.easeInCirc | easeInCirc
  * Ease.easeOutCirc | easeOutCirc
  * Ease.easeInOutCirc | easeInOutCirc
  * Ease.easeInElastic | easeInElastic
  * Ease.easeOutElastic | easeOutElastic
  * Ease.easeInOutElastic | easeInOutElastic
  * Ease.easeInBack | easeInBack
  * Ease.easeOutBack | easeOutBack
  * Ease.easeInOutBack | easeInOutBack
  * Ease.easeInBounce | easeInBounce
  * Ease.easeOutBounce | easeOutBounce
   * @method timeline.add(duration,cb?,transform?)
   * @param {number} duration
   * @param { (obj?: number, time?: number) => TransformOptions[] } [cb]
   * @param { [property: string]: { to:number, from: number: easing?: Function } } [transform]
   * @returns {Timeline}
   * @memberof Timeline
   */
  add(duration, cb, transform) {
    if (!cb) {
      this.animation.push([{
        time: duration + this.time
      }]);
      this.time += duration;
      return this;
    }
    for (let k4 = 0; k4 < this.keyframes; k4++) {
      const i2 = Math.floor(duration / (this.keyframes - 1) * k4);
      let anim;
      const obj = {};
      for (let prop in transform) {
        const param = transform[prop];
        const cbEasing = param.easing || Ease.linear;
        obj[prop] = cbEasing(i2, param.from, param.to, duration);
      }
      const ret = cb(obj, i2);
      anim = ret.map((el) => {
        el.time = i2 + this.time;
        return el;
      });
      this.animation.push(anim);
    }
    this.time += duration;
    return this;
  }
  /**
   * Allows you to create the animation array to assign to the `animations` property in the Spritesheet
   *
   * ```ts
   * import { Spritesheet, Timeline } from '@rpgjs/server'
   *
   * @Spritesheet({
   *  id: 'sprite',
   *  image: require('./sprite.png'),
   *  width: 192,
   *  height: 228,
   *  framesHeight: 6,
   *  framesWidth: 6,
   *  anchor: [0.5],
   *  textures: {
   *      myanim: {
   *          animations: new Timeline()
   *                          .add(SEE THE ADD METHOD)
   *                          .create()
   *      }
   *  }
   * })
   * export class MyAnim {}
   * ```
   *
   * @title Create the animation array
   * @method timeline.create()
   * @returns {FrameOptions[][]} The animation array
   * @memberof Timeline
   */
  create() {
    return this.animation;
  }
}
class TransitionScene {
  constructor(context2, container) {
    this.context = context2;
    this.container = container;
    this.frameIndex = 0;
    this.animations = [];
    this.complete = () => {
    };
    this.clientEngine = this.context.inject(RpgClientEngine$4);
  }
  addFadeIn() {
    return this.addFading(1, 0);
  }
  addFadeOut() {
    return this.addFading(0, 1);
  }
  addFading(from2, to) {
    this.animations = new Timeline().add(15, ({
      opacity
    }) => [{
      opacity
    }], {
      opacity: {
        from: from2,
        to
      }
    }).create();
    return this;
  }
  onComplete(cb) {
    this.complete = cb;
    return this;
  }
  start() {
    this.updateSubscription = this.clientEngine.tick.subscribe(() => this.update());
  }
  update() {
    const animationFrame = this.animations[this.frameIndex];
    if (!animationFrame) {
      this.complete();
      this.updateSubscription.unsubscribe();
      return;
    }
    const frame = animationFrame[0];
    this.container.alpha = frame.opacity;
    this.frameIndex++;
  }
}
class SpinnerGraphic extends Graphics {
  constructor(clientEngine) {
    super();
    this.clientEngine = clientEngine;
  }
  render(renderer2) {
    super.render(renderer2);
    this.rotation += 0.12;
    const percent = Math.abs(Math.sin(Date.now() / 1e3));
    this.clear().lineStyle(4, 16777215, 1).moveTo(40, 0).arc(0, 0, 40, 0, Math.PI * 2 * percent, false);
  }
}
const {
  elementToPositionAbsolute
} = Utils$2;
var TransitionMode;
(function(TransitionMode2) {
  TransitionMode2[TransitionMode2["None"] = 0] = "None";
  TransitionMode2[TransitionMode2["Fading"] = 1] = "Fading";
})(TransitionMode || (TransitionMode = {}));
var ContainerName;
(function(ContainerName2) {
  ContainerName2["Map"] = "map";
})(ContainerName || (ContainerName = {}));
const EVENTS_MAP = {
  MouseEvent: ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "wheel"],
  KeyboardEvent: ["keydown", "keyup", "keypress", "keydownoutside", "keyupoutside", "keypressoutside"],
  PointerEvent: ["pointerdown", "pointerup", "pointermove", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointercancel"],
  TouchEvent: ["touchstart", "touchend", "touchmove", "touchcancel"]
};
class RpgRenderer {
  constructor(context2) {
    this.context = context2;
    this.gameEngine = this.context.inject(GameEngineClient);
    this.clientEngine = this.context.inject(RpgClientEngine$4);
    this.stage = new Container();
    this.sceneContainer = new Container();
    this.fadeContainer = new Graphics();
    this.spinner = new SpinnerGraphic(this.clientEngine);
    this.options = {};
    this.scene = null;
    this._width = 800;
    this._height = 400;
    this.loadingScene = {
      transitionIn: new Subject$1(),
      transitionOut: new Subject$1()
    };
    this.freeze = false;
    this.prevObjectScene = {};
    this.transitionMode = TransitionMode.Fading;
    this.clientEngine.tick.subscribe(({
      timestamp,
      deltaRatio,
      frame,
      deltaTime
    }) => {
      this.draw(timestamp, deltaTime, deltaRatio, frame);
    });
    this.transitionCompleted();
  }
  /** @internal */
  init() {
    return this.onDOMLoaded();
  }
  /** @internal */
  _resize(w2, h2) {
    if (!w2)
      w2 = this.options.canvas.width;
    if (!h2)
      h2 = this.options.canvas.height;
    const scene = this.getScene();
    if (this.scene && (scene == null ? void 0 : scene.viewport)) {
      scene.viewport.screenWidth = w2;
      scene.viewport.screenHeight = h2;
    }
    if (this.vm) {
      this.vm.$el.style = `width:${w2}px;height:${h2}px`;
    }
    this.renderer.resize(w2, h2);
    this._width = w2;
    this._height = h2;
    this.fadeContainer.beginFill(0);
    this.fadeContainer.drawRect(0, 0, w2, h2);
    this.fadeContainer.endFill();
    this.spinner.x = w2 * 0.5;
    this.spinner.y = h2 * 0.5;
  }
  get canvas() {
    return this.renderer.view;
  }
  get height() {
    return this._height;
  }
  set height(val) {
    this._resize(this._width, val);
  }
  get width() {
    return this._width;
  }
  set width(val) {
    this._resize(val, this.height);
  }
  /** @internal */
  async onDOMLoaded() {
    let options2 = {
      antialias: true,
      ...this.options.canvas
    };
    this.renderer = autoDetectRenderer(options2);
    this.selector = document.body.querySelector(this.options.selector);
    this.guiEl = this.selector.querySelector(this.options.selectorGui);
    this.canvasEl = this.selector.querySelector(this.options.selectorCanvas);
    if (!this.guiEl) {
      this.guiEl = document.createElement("div");
      this.guiEl = this.selector.appendChild(this.guiEl);
    }
    elementToPositionAbsolute(this.guiEl);
    if (!this.canvasEl) {
      this.selector.insertBefore(this.renderer.view, this.selector.firstChild);
      const [canvas] = document.querySelector(this.options.selector).children;
      canvas.style.position = "absolute";
    } else {
      this.canvasEl.appendChild(this.renderer.view);
    }
    this.stage.addChild(this.sceneContainer);
    this.stage.addChild(this.fadeContainer);
    this.fadeContainer.addChild(this.spinner);
    this.fadeContainer.visible = false;
    this.fadeContainer.alpha = 0;
    await RpgGui._initialize(this.context, this.guiEl);
    this.resize();
    this.bindMouseControls();
  }
  bindMouseControls() {
    const controlInstance = this.context.inject(KeyboardControls);
    const controls = controlInstance.getControls();
    for (let key in controls) {
      const {
        actionName
      } = controls[key];
      if (EVENTS_MAP.MouseEvent.includes(key)) {
        this.canvas.addEventListener(key, (e3) => {
          controlInstance.applyControl(actionName);
        });
      }
    }
  }
  /** @internal */
  resize() {
    const size2 = () => {
      const {
        offsetWidth,
        offsetHeight
      } = this.canvasEl || this.selector;
      this._resize(offsetWidth, offsetHeight);
      RpgPlugin.emit(HookClient.WindowResize);
    };
    window.addEventListener("resize", size2);
    size2();
  }
  /** @internal */
  getScene() {
    return this.scene;
  }
  /** @internal */
  draw(t2, deltaTime, deltaRatio, frame) {
    if (!this.renderer)
      return;
    if (this.scene && !this.freeze)
      this.scene.draw(t2, deltaTime, deltaRatio, frame);
    this.renderer.render(this.stage);
  }
  /** @internal */
  async loadScene(name2, obj) {
    var _a;
    const scene = this.getScene();
    if (scene && scene.data.id == obj.id) {
      const container = await scene.load(obj, this.prevObjectScene, true);
      this.sceneContainer.removeChildren();
      this.sceneContainer.addChild(container);
      scene.updateTilesOverlayAllSprites();
      (_a = this.scene) == null ? void 0 : _a.update();
      return;
    }
    this.loadingScene.transitionIn.next({
      name: name2,
      obj
    });
    this.loadingScene.transitionIn.complete();
  }
  async createScene(name2, obj) {
    var _a, _b;
    const container = await ((_a = this.getScene()) == null ? void 0 : _a.load(obj, this.prevObjectScene));
    this.prevObjectScene = {
      ...obj
    };
    this.sceneContainer.children.forEach((child) => {
      if (child.name === ContainerName.Map)
        this.sceneContainer.removeChild(child);
    });
    if (container) {
      container.name = ContainerName.Map;
      this.sceneContainer.addChild(container);
    }
    (_b = this.scene) == null ? void 0 : _b.update();
  }
  /** @internal */
  transitionScene(name2) {
    this.freeze = true;
    this.fadeContainer.visible = true;
    RpgPlugin.emit(HookClient.BeforeSceneLoading, {
      name: name2
    });
    this.clientEngine.controls.stopInputs();
    const finish = () => {
      this.clearScene();
      this.loadingScene.transitionOut.next(name2);
      this.loadingScene.transitionOut.complete();
    };
    if (this.transitionMode == TransitionMode.Fading) {
      new TransitionScene(this.context, this.fadeContainer).addFadeOut().onComplete(finish).start();
    } else {
      finish();
    }
  }
  /** @internal */
  transitionCompleted() {
    this.loadingScene = {
      transitionIn: new Subject$1(),
      transitionOut: new Subject$1()
    };
    this.clientEngine.roomJoin = new Subject$1();
    forkJoin({
      in: this.loadingScene.transitionIn,
      out: this.loadingScene.transitionOut,
      room: this.clientEngine.roomJoin
    }).subscribe(async (data) => {
      const {
        in: {
          obj,
          name: name2
        }
      } = data;
      const scenes = this.options.scenes || {};
      switch (name2) {
        case Scene2.Map:
          const sceneClass = scenes[Scene2.Map] || SceneMap2;
          this.scene = new sceneClass(this.context, this.renderer, {
            screenWidth: this.renderer.screen.width,
            screenHeight: this.renderer.screen.height,
            drawMap: this.options.drawMap
          });
          break;
      }
      await this.createScene(name2, obj);
      this.freeze = false;
      const finish = () => {
        this.clientEngine.controls.listenInputs();
        this.fadeContainer.visible = false;
        this.transitionCompleted();
        RpgPlugin.emit(HookClient.AfterSceneLoading, this.scene);
      };
      if (this.transitionMode == TransitionMode.Fading) {
        new TransitionScene(this.context, this.fadeContainer).addFadeIn().onComplete(finish).start();
      } else {
        finish();
      }
    });
  }
  /** @internal */
  clearScene() {
    this.scene = null;
    this.sceneContainer.removeChildren();
  }
  /**
   * @title Propagate mouse event to Viewport
   * @method propagateEvent(ev)
   * @stability 1
   * @memberof RpgRenderer
   * @returns {void}
   */
  propagateEvent(ev) {
    const rect = this.canvas.getBoundingClientRect();
    const canvasX = rect.left + window.scrollX;
    const canvasY = rect.top + window.scrollY;
    const realX = ev.clientX - canvasX;
    const realY = ev.clientY - canvasY;
    const boundary = new EventBoundary(this.stage);
    const event = new FederatedPointerEvent(boundary);
    event.global.set(realX, realY);
    event.type = ev.type;
    const hitTestTarget = boundary.hitTest(realX, realY);
    hitTestTarget == null ? void 0 : hitTestTarget.dispatchEvent(event);
    this.canvas.dispatchEvent(new MouseEvent(ev.type, ev));
  }
  /***
   * Propagate events from an HTMLElement to the canvas
   *
   * @title Propagate events
   * @method addPropagateEventsFrom(el)
   * @stability 1
   * @memberof RpgRenderer
   * @returns {void}
   */
  addPropagateEventsFrom(el) {
    for (let [_Constructor, events2] of Object.entries(EVENTS_MAP)) {
      for (let type of events2) {
        el.addEventListener(type, (e3) => {
          const _class = window[_Constructor] ?? MouseEvent;
          this.canvas.dispatchEvent(new _class(type, e3));
        });
      }
    }
  }
}
var lodash_mergewith = { exports: {} };
lodash_mergewith.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var objectCtorString = funcToString2.call(Object);
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e3) {
    }
  }();
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size2 = data.size;
    data.set(key, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assocIndexOf2(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq2(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity2), func + "");
  }
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length = buffer2.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer2.constructor(length);
    buffer2.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array2) {
    var index2 = -1, length = source.length;
    array2 || (array2 = Array(length));
    while (++index2 < length) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq2(object[index2], value);
    }
    return false;
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
      while (++index2 < length) {
        array2[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array2);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  function constant2(value) {
    return function() {
      return value;
    };
  }
  function identity2(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = mergeWith;
})(lodash_mergewith, lodash_mergewith.exports);
var lodash_mergewithExports = lodash_mergewith.exports;
const merge = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergewithExports);
let listenerQueue = [];
let atom = (initialValue, level) => {
  let currentListeners;
  let nextListeners = [];
  let store = {
    lc: 0,
    l: level || 0,
    value: initialValue,
    set(data) {
      store.value = data;
      store.notify();
    },
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    notify(changedKey) {
      currentListeners = nextListeners;
      let runListenerQueue = !listenerQueue.length;
      for (let i2 = 0; i2 < currentListeners.length; i2 += 2) {
        listenerQueue.push(
          currentListeners[i2],
          store.value,
          changedKey,
          currentListeners[i2 + 1]
        );
      }
      if (runListenerQueue) {
        for (let i2 = 0; i2 < listenerQueue.length; i2 += 4) {
          let skip = false;
          for (let j2 = i2 + 7; j2 < listenerQueue.length; j2 += 4) {
            if (listenerQueue[j2] < listenerQueue[i2 + 3]) {
              skip = true;
              break;
            }
          }
          if (skip) {
            listenerQueue.push(
              listenerQueue[i2],
              listenerQueue[i2 + 1],
              listenerQueue[i2 + 2],
              listenerQueue[i2 + 3]
            );
          } else {
            listenerQueue[i2](listenerQueue[i2 + 1], listenerQueue[i2 + 2]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    listen(listener, listenerLevel) {
      if (nextListeners === currentListeners) {
        nextListeners = nextListeners.slice();
      }
      store.lc = nextListeners.push(listener, listenerLevel || store.l) / 2;
      return () => {
        if (nextListeners === currentListeners) {
          nextListeners = nextListeners.slice();
        }
        let index2 = nextListeners.indexOf(listener);
        if (~index2) {
          nextListeners.splice(index2, 2);
          store.lc--;
        }
      };
    },
    subscribe(cb, listenerLevel) {
      let unbind = store.listen(cb, listenerLevel);
      cb(store.value);
      return unbind;
    },
    off() {
    }
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
  };
  return store;
};
const room = atom({});
let Collection$1 = class Collection {
  constructor(collectionClass) {
    this.collectionClass = collectionClass;
    this.collection = /* @__PURE__ */ new Map();
    this.removeCb = (key) => {
    };
    this.addCb = (key, data) => {
    };
  }
  registerRemoveCallback(cb) {
    this.removeCb = cb;
  }
  registerAddCallback(cb) {
    this.addCb = cb;
  }
  detectChanges(data) {
    let newObj = {};
    for (let key in data) {
      const obj = data[key];
      if (obj == null) {
        this.collection.delete(key);
        this.removeCb(key);
        continue;
      }
      const instance = this.collectionClass ? new this.collectionClass(obj, key) : obj;
      if (!this.collection.has(key)) {
        this.addCb(key, instance);
      }
      this.collection.set(key, instance);
      newObj[key] = instance;
    }
    return newObj;
  }
};
class User2 {
  constructor(data, id) {
    this.id = id;
    Object.assign(this, data);
  }
  isMe() {
    return WorldClass2.userId == this.id;
  }
}
class WorldClass2 {
  constructor() {
    this.obs$ = new BehaviorSubject$1({});
    this.users = new Collection$1(User2);
  }
  get value() {
    return this.obs$.asObservable();
  }
  /**
   * Join an existing room
   *
   * @param {string} roomId
   */
  join(roomId) {
    this.socket.emit(":join", roomId);
  }
  /**
   * Change the value of a property
   *
   * @param {string} prop
   * @param {any} value
   */
  input(prop, value) {
    this.socket.emit(":input", { prop, value });
    return {
      catchError: (cb) => this.socket.once(":error", cb)
    };
  }
  /**
  * Do an action
  *
  * @param {string} name
  * @param {any} value
  */
  action(name2, value) {
    this.socket.emit(":action", { name: name2, value });
    return {
      catchError: (cb) => this.socket.once(":error", cb)
    };
  }
  /**
   * Listen to the changes on a socket
   *
   * @param {string} socket
   * @return {World}
   */
  listen(socket, options2 = {}) {
    if (options2.encoded === void 0)
      options2.encoded = true;
    this.socket = socket;
    this.socket.on("uid", (response) => {
      WorldClass2.userId = response;
    });
    this.socket.on("connect", () => {
      this.obs$.next({});
    });
    this.socket.on("w", (response) => {
      if (options2.encoded) {
        const bufView = new Uint8Array(response);
        response = browser.decode(bufView);
      }
      const [roomId, time, data] = response;
      const lastRoomId = this.obs$.value.roomId;
      let mergeData = {};
      let resetProps = [];
      if (lastRoomId == roomId) {
        data.join = false;
        mergeData = merge(Object.assign({}, this.obs$.value.data || {}), data, (objValue, srcValue, key, object, source, stack) => {
          if (srcValue != null && typeof srcValue == "object") {
            if (Object.values(srcValue).length == 0) {
              return {};
            }
            if (srcValue.$reset) {
              resetProps.push(key);
              delete srcValue.$reset;
              return srcValue;
            }
          }
        });
      } else {
        mergeData = data;
      }
      if (data.users) {
        mergeData.users = this.users.detectChanges(mergeData.users);
      }
      this.obs$.next({
        roomId,
        data: mergeData,
        partial: data,
        time,
        resetProps
      });
      room.set(Object.assign({}, mergeData));
    });
    return this;
  }
  reset() {
    this.obs$ = new BehaviorSubject$1({});
  }
}
WorldClass2.userId = null;
const World = new WorldClass2();
function getXHRResponse(xhr) {
  switch (xhr.responseType) {
    case "json": {
      if ("response" in xhr) {
        return xhr.response;
      } else {
        var ieXHR = xhr;
        return JSON.parse(ieXHR.responseText);
      }
    }
    case "document":
      return xhr.responseXML;
    case "text":
    default: {
      if ("response" in xhr) {
        return xhr.response;
      } else {
        var ieXHR = xhr;
        return ieXHR.responseText;
      }
    }
  }
}
var AjaxResponse = function() {
  function AjaxResponse2(originalEvent, xhr, request, type) {
    if (type === void 0) {
      type = "download_load";
    }
    this.originalEvent = originalEvent;
    this.xhr = xhr;
    this.request = request;
    this.type = type;
    var status = xhr.status, responseType = xhr.responseType;
    this.status = status !== null && status !== void 0 ? status : 0;
    this.responseType = responseType !== null && responseType !== void 0 ? responseType : "";
    var allHeaders = xhr.getAllResponseHeaders();
    this.responseHeaders = allHeaders ? allHeaders.split("\n").reduce(function(headers, line) {
      var index2 = line.indexOf(": ");
      headers[line.slice(0, index2)] = line.slice(index2 + 2);
      return headers;
    }, {}) : {};
    this.response = getXHRResponse(xhr);
    var loaded = originalEvent.loaded, total = originalEvent.total;
    this.loaded = loaded;
    this.total = total;
  }
  return AjaxResponse2;
}();
var AjaxError = createErrorClass$1(function(_super) {
  return function AjaxErrorImpl(message, xhr, request) {
    this.message = message;
    this.name = "AjaxError";
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
    this.responseType = xhr.responseType;
    var response;
    try {
      response = getXHRResponse(xhr);
    } catch (err) {
      response = xhr.responseText;
    }
    this.response = response;
  };
});
var AjaxTimeoutError = function() {
  function AjaxTimeoutErrorImpl(xhr, request) {
    AjaxError.call(this, "ajax timeout", xhr, request);
    this.name = "AjaxTimeoutError";
    return this;
  }
  AjaxTimeoutErrorImpl.prototype = Object.create(AjaxError.prototype);
  return AjaxTimeoutErrorImpl;
}();
function ajaxGet(url2, headers) {
  return ajax({ method: "GET", url: url2, headers });
}
function ajaxPost(url2, body, headers) {
  return ajax({ method: "POST", url: url2, body, headers });
}
function ajaxDelete(url2, headers) {
  return ajax({ method: "DELETE", url: url2, headers });
}
function ajaxPut(url2, body, headers) {
  return ajax({ method: "PUT", url: url2, body, headers });
}
function ajaxPatch(url2, body, headers) {
  return ajax({ method: "PATCH", url: url2, body, headers });
}
var mapResponse = map$6(function(x2) {
  return x2.response;
});
function ajaxGetJSON(url2, headers) {
  return mapResponse(ajax({
    method: "GET",
    url: url2,
    headers
  }));
}
var ajax = function() {
  var create = function(urlOrConfig) {
    var config2 = typeof urlOrConfig === "string" ? {
      url: urlOrConfig
    } : urlOrConfig;
    return fromAjax(config2);
  };
  create.get = ajaxGet;
  create.post = ajaxPost;
  create.delete = ajaxDelete;
  create.put = ajaxPut;
  create.patch = ajaxPatch;
  create.getJSON = ajaxGetJSON;
  return create;
}();
var UPLOAD = "upload";
var DOWNLOAD = "download";
var LOADSTART = "loadstart";
var PROGRESS = "progress";
var LOAD = "load";
function fromAjax(init2) {
  return new Observable$1(function(destination) {
    var _a, _b;
    var config2 = __assign({ async: true, crossDomain: false, withCredentials: false, method: "GET", timeout: 0, responseType: "json" }, init2);
    var queryParams = config2.queryParams, configuredBody = config2.body, configuredHeaders = config2.headers;
    var url2 = config2.url;
    if (!url2) {
      throw new TypeError("url is required");
    }
    if (queryParams) {
      var searchParams_1;
      if (url2.includes("?")) {
        var parts = url2.split("?");
        if (2 < parts.length) {
          throw new TypeError("invalid url");
        }
        searchParams_1 = new URLSearchParams(parts[1]);
        new URLSearchParams(queryParams).forEach(function(value, key2) {
          return searchParams_1.set(key2, value);
        });
        url2 = parts[0] + "?" + searchParams_1;
      } else {
        searchParams_1 = new URLSearchParams(queryParams);
        url2 = url2 + "?" + searchParams_1;
      }
    }
    var headers = {};
    if (configuredHeaders) {
      for (var key in configuredHeaders) {
        if (configuredHeaders.hasOwnProperty(key)) {
          headers[key.toLowerCase()] = configuredHeaders[key];
        }
      }
    }
    var crossDomain = config2.crossDomain;
    if (!crossDomain && !("x-requested-with" in headers)) {
      headers["x-requested-with"] = "XMLHttpRequest";
    }
    var withCredentials = config2.withCredentials, xsrfCookieName = config2.xsrfCookieName, xsrfHeaderName = config2.xsrfHeaderName;
    if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {
      var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + xsrfCookieName + ")=([^;]*)"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : "";
      if (xsrfCookie) {
        headers[xsrfHeaderName] = xsrfCookie;
      }
    }
    var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
    var _request = __assign(__assign({}, config2), {
      url: url2,
      headers,
      body
    });
    var xhr;
    xhr = init2.createXHR ? init2.createXHR() : new XMLHttpRequest();
    {
      var progressSubscriber_1 = init2.progressSubscriber, _c = init2.includeDownloadProgress, includeDownloadProgress = _c === void 0 ? false : _c, _d = init2.includeUploadProgress, includeUploadProgress = _d === void 0 ? false : _d;
      var addErrorEvent = function(type, errorFactory) {
        xhr.addEventListener(type, function() {
          var _a2;
          var error2 = errorFactory();
          (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, error2);
          destination.error(error2);
        });
      };
      addErrorEvent("timeout", function() {
        return new AjaxTimeoutError(xhr, _request);
      });
      addErrorEvent("abort", function() {
        return new AjaxError("aborted", xhr, _request);
      });
      var createResponse_1 = function(direction, event) {
        return new AjaxResponse(event, xhr, _request, direction + "_" + event.type);
      };
      var addProgressEvent_1 = function(target, type, direction) {
        target.addEventListener(type, function(event) {
          destination.next(createResponse_1(direction, event));
        });
      };
      if (includeUploadProgress) {
        [LOADSTART, PROGRESS, LOAD].forEach(function(type) {
          return addProgressEvent_1(xhr.upload, type, UPLOAD);
        });
      }
      if (progressSubscriber_1) {
        [LOADSTART, PROGRESS].forEach(function(type) {
          return xhr.upload.addEventListener(type, function(e3) {
            var _a2;
            return (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, e3);
          });
        });
      }
      if (includeDownloadProgress) {
        [LOADSTART, PROGRESS].forEach(function(type) {
          return addProgressEvent_1(xhr, type, DOWNLOAD);
        });
      }
      var emitError_1 = function(status) {
        var msg = "ajax error" + (status ? " " + status : "");
        destination.error(new AjaxError(msg, xhr, _request));
      };
      xhr.addEventListener("error", function(e3) {
        var _a2;
        (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1, e3);
        emitError_1();
      });
      xhr.addEventListener(LOAD, function(event) {
        var _a2, _b2;
        var status = xhr.status;
        if (status < 400) {
          (_a2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a2 === void 0 ? void 0 : _a2.call(progressSubscriber_1);
          var response = void 0;
          try {
            response = createResponse_1(DOWNLOAD, event);
          } catch (err) {
            destination.error(err);
            return;
          }
          destination.next(response);
          destination.complete();
        } else {
          (_b2 = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b2 === void 0 ? void 0 : _b2.call(progressSubscriber_1, event);
          emitError_1(status);
        }
      });
    }
    var user = _request.user, method = _request.method, async = _request.async;
    if (user) {
      xhr.open(method, url2, async, user, _request.password);
    } else {
      xhr.open(method, url2, async);
    }
    if (async) {
      xhr.timeout = _request.timeout;
      xhr.responseType = _request.responseType;
    }
    if ("withCredentials" in xhr) {
      xhr.withCredentials = _request.withCredentials;
    }
    for (var key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
    if (body) {
      xhr.send(body);
    } else {
      xhr.send();
    }
    return function() {
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
}
function extractContentTypeAndMaybeSerializeBody(body, headers) {
  var _a;
  if (!body || typeof body === "string" || isFormData(body) || isURLSearchParams(body) || isArrayBuffer(body) || isFile(body) || isBlob(body) || isReadableStream(body)) {
    return body;
  }
  if (isArrayBufferView(body)) {
    return body.buffer;
  }
  if (typeof body === "object") {
    headers["content-type"] = (_a = headers["content-type"]) !== null && _a !== void 0 ? _a : "application/json;charset=utf-8";
    return JSON.stringify(body);
  }
  throw new TypeError("Unknown body type");
}
var _toString = Object.prototype.toString;
function toStringCheck(obj, name2) {
  return _toString.call(obj) === "[object " + name2 + "]";
}
function isArrayBuffer(body) {
  return toStringCheck(body, "ArrayBuffer");
}
function isFile(body) {
  return toStringCheck(body, "File");
}
function isBlob(body) {
  return toStringCheck(body, "Blob");
}
function isArrayBufferView(body) {
  return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(body);
}
function isFormData(body) {
  return typeof FormData !== "undefined" && body instanceof FormData;
}
function isURLSearchParams(body) {
  return typeof URLSearchParams !== "undefined" && body instanceof URLSearchParams;
}
function isReadableStream(body) {
  return typeof ReadableStream !== "undefined" && body instanceof ReadableStream;
}
function Spritesheet(options2) {
  return (target) => {
    if ("images" in options2)
      target["images"] = options2.images;
    if ("id" in options2)
      target["id"] = options2.id;
    for (let key in options2) {
      target.prototype[key] = options2[key];
    }
    return;
  };
}
function Sound$1(options2) {
  return (target) => {
    if ("sounds" in options2)
      target["sounds"] = options2.sounds;
    if ("id" in options2)
      target["id"] = options2.id;
    for (let key in options2) {
      target.prototype[key] = options2[key];
    }
  };
}
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
const {
  extractId,
  isString
} = Utils$2;
let RpgClientEngine$4 = class RpgClientEngine {
  constructor(context2, options2) {
    this.context = context2;
    this.options = options2;
    this.globalConfig = {};
    this._tick = new BehaviorSubject$1({
      timestamp: -1,
      deltaTime: 0,
      frame: 0,
      deltaRatio: 1
    });
    this.keyChange = new Subject$1();
    this.roomJoin = new Subject$1();
    this.hasBeenDisconnected = false;
    this.serverChanging = false;
    this.isTeleported = false;
    this.lastTimestamp = 0;
    this.clientFrames = /* @__PURE__ */ new Map();
    this.serverFrames = /* @__PURE__ */ new Map();
    this.session = null;
    this.lastConnection = "";
    this.lastScene = "";
    this.matchMakerService = null;
    this.serverFps = 60;
    this.scheduler = new Scheduler();
    this._serverUrl = "";
    this.gameEngine = this.context.inject(GameEngineClient);
    this.objects = this.gameEngine.objects;
    this.envs = {};
    this.envs = options2.envs || {};
    this.tick.subscribe(({
      timestamp,
      deltaTime
    }) => {
      if (timestamp != -1)
        this.step(timestamp, deltaTime);
    });
  }
  async _init() {
    this.renderer = this.context.inject(RpgRenderer);
    const pluginLoadResource = async (hookName, type) => {
      const resource = this.options[type] || [];
      this.options[type] = [...arrayFlat$2(await RpgPlugin.emit(hookName, resource)) || [], ...resource];
    };
    await pluginLoadResource(HookClient.AddSpriteSheet, "spritesheets");
    await pluginLoadResource(HookClient.AddGui, "gui");
    await pluginLoadResource(HookClient.AddSound, "sounds");
    this.renderer.options = {
      selector: "#rpg",
      selectorCanvas: "#canvas",
      selectorGui: "#gui",
      canvas: {},
      gui: [],
      spritesheets: [],
      sounds: [],
      ...this.options
    };
    this.io = this.options.io;
    if (this.options.serverFps)
      this.serverFps = this.options.serverFps;
    this.globalConfig = this.options.globalConfig;
    this.gameEngine.standalone = this.options.standalone;
    this.gameEngine.renderer = this.renderer;
    this.gameEngine.clientEngine = this;
    this.addSpriteSheet(this.renderer.options.spritesheets);
    (this.renderer.options.sounds || []).forEach((sound) => {
      const id = isString(sound) ? extractId(sound) : void 0;
      this.addSound(sound, id);
    });
    if (typeof __RPGJS_PRODUCTION__ != "undefined" && __RPGJS_PRODUCTION__) {
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("/service-worker.js");
        });
      }
    }
    this.controls = this.context.inject(KeyboardControls);
  }
  addResource(resourceClass, cb) {
    let array2 = resourceClass;
    if (!isArray$d(resourceClass)) {
      array2 = [resourceClass];
    }
    cb(array2, this);
  }
  /**
   * Listen to each frame
   *
   * @prop {Observable<{ timestamp: number, deltaTime: number, frame: number }>} tick
   * @readonly
   * @since 3.0.0-beta.5
   * @memberof RpgClientEngine
   * @example
   *
   * ```ts
   * client.tick.subscribe(({ timestamp, deltaTime, frame }) => {
   *
   * })
   * ```
   * */
  get tick() {
    return this.scheduler.tick;
  }
  addSpriteSheet(spritesheetClass, id) {
    if (typeof spritesheetClass === "string") {
      if (!id) {
        throw log("Please, specify the resource ID (second parameter)");
      }
      let AutoSpritesheet = class AutoSpritesheet {
      };
      AutoSpritesheet = __decorate([Spritesheet({
        id,
        image: this.getResourceUrl(spritesheetClass)
      })], AutoSpritesheet);
      spritesheetClass = AutoSpritesheet;
    }
    this.addResource(spritesheetClass, _initSpritesheet);
    return spritesheetClass;
  }
  addSound(soundClass, id) {
    if (typeof soundClass === "string") {
      if (!id) {
        throw log("Please, specify the resource ID (second parameter)");
      }
      let AutoSound = class AutoSound {
      };
      AutoSound = __decorate([Sound$1({
        id,
        sound: this.getResourceUrl(soundClass)
      })], AutoSound);
      soundClass = AutoSound;
    }
    this.addResource(soundClass, _initSound);
    return soundClass;
  }
  getResourceUrl(source) {
    if (window.urlCache && window.urlCache[source]) {
      return window.urlCache[source];
    }
    if (source.startsWith("data:")) {
      return source;
    }
    const staticDir = this.envs.VITE_BUILT;
    if (staticDir) {
      return this.assetsPath + "/" + basename$1(source);
    }
    return source;
  }
  /**
   * Starts the client side and connects to the server
   *
   * @title Start Client Engine
   * @method start()
   * @returns {Promise< RpgClientEngine >}
   * @memberof RpgClientEngine
   */
  async start(options2 = {
    renderLoop: true
  }) {
    await this._init();
    await this.renderer.init();
    const {
      maxFps
    } = this.options;
    if (options2.renderLoop) {
      this.scheduler.start({
        maxFps
      });
      setInterval(() => {
        this.processInput();
      }, fps2ms(this.serverFps));
    }
    const ret = await RpgPlugin.emit(HookClient.Start, this);
    this.matchMakerService = this.options.globalConfig.matchMakerService;
    const hasFalseValue = ret.findIndex((el) => el === false) != -1;
    if (!hasFalseValue) {
      let serverUri = {};
      if (this.matchMakerService) {
        if (isFunction$8(this.matchMakerService)) {
          serverUri = this.matchMakerService();
        } else {
          serverUri = await lastValueFrom(ajax.getJSON(this.matchMakerService));
        }
      }
      const envUrl = this.envs.VITE_SERVER_URL;
      await this.connection(serverUri.url ? serverUri.url + ":" + serverUri.port : envUrl ? envUrl : void 0);
    }
    return this;
  }
  /**
   * Display the next frame. Useful for unit tests
   *
   * @title Next Frame
   * @since 3.0.0-beta.5
   * @param {number} timestamp Indicate the timestamp of the frame
   * @method nextFrame()
   * @memberof RpgClientEngine
   */
  nextFrame(timestamp) {
    this.scheduler.nextTick(timestamp);
  }
  async sendInput(actionName) {
    const player2 = this.player;
    if (!player2)
      return;
    if (player2.canMove) {
      player2.pendingMove.push({
        input: actionName,
        frame: this.scheduler.frame
      });
    }
  }
  get player() {
    return this.gameEngine.world.getObject(this.gameEngine.playerId);
  }
  serverReconciliation(player2) {
    let garbage = [];
    this.serverFrames.forEach((serverData, frame) => {
      const {
        data: serverPos,
        time: serverTime
      } = serverData;
      const client = this.clientFrames.get(frame);
      if (!client || client && client.data.x != serverPos.x || client.data.y != serverPos.y) {
        if (serverPos.x)
          player2.position.x = serverPos.x;
        if (serverPos.y)
          player2.position.y = serverPos.y;
      }
      player2.position.z = serverPos.z;
      garbage.push(frame);
    });
    garbage.forEach((frame) => {
      this.serverFrames.delete(frame);
      this.clientFrames.delete(frame);
    });
    garbage = [];
  }
  async step(t2, dt) {
    RpgPlugin.emit(HookClient.Step, [this, t2, dt], true);
  }
  async processInput() {
    const player2 = this.player;
    this.controls.preStep();
    if (player2) {
      if (player2.pendingMove.length > 0) {
        const {
          inputs: inputEvent
        } = await this.gameEngine.processInput(this.gameEngine.playerId, this.controls.options);
        if (inputEvent.length == 0)
          return;
        const frame = Date.now();
        this.clientFrames.set(frame, {
          data: player2.position.copy(),
          time: frame
        });
        if (this.socket) {
          this.socket.emit("move", {
            input: inputEvent,
            frame
          });
        }
        RpgPlugin.emit(HookClient.SendInput, [this, inputEvent], true);
      }
      if (player2.canMove)
        this.serverReconciliation(player2);
    }
  }
  /**
   *Connect to the server
   *
   * @title Connect to server
   * @method connection()
   * @returns {void}
   * @memberof RpgClientEngine
   */
  async connection(uri) {
    const {
      standalone
    } = this.gameEngine;
    const {
      globalConfig
    } = this;
    this._serverUrl = uri || "";
    if (!standalone) {
      this.socket = this.io(uri, {
        auth: {
          token: this.session
        },
        ...globalConfig.socketIoClient || {}
      });
    } else {
      this.socket = this.io;
    }
    this.socket.on("connect", () => {
      if (RpgGui.exists(PrebuiltGui.Disconnect))
        RpgGui.hide(PrebuiltGui.Disconnect);
      RpgPlugin.emit(HookClient.Connected, [this, this.socket], true);
      this.hasBeenDisconnected = false;
    });
    this.socket.on("playerJoined", (playerEvent) => {
      this.gameEngine.playerId = playerEvent.playerId;
      this.session = playerEvent.session;
    });
    this.socket.on("connect_error", (err) => {
      RpgPlugin.emit(HookClient.ConnectedError, [this, err, this.socket], true);
    });
    this.socket.on("preLoadScene", ({
      id,
      reconnect
    }) => {
      if (this.lastScene == id) {
        return;
      }
      this.lastScene = id;
      this.renderer.transitionScene(id);
      if (reconnect) {
        this.roomJoin.next("");
        this.roomJoin.complete();
      }
    });
    this.socket.on(SocketEvents.GameReload, () => {
      window.location.reload();
    });
    this.socket.on(SocketEvents.LoadScene, ({
      name: name2,
      data
    }) => {
      this.renderer.loadScene(name2, data);
    });
    this.socket.on(SocketEvents.ChangeServer, async ({
      url: url2,
      port
    }) => {
      const connection = url2 + ":" + port;
      if (this.lastConnection == connection) {
        return;
      }
      if (this.subscriptionWorld) {
        this.subscriptionWorld.unsubscribe();
      }
      this.lastConnection = connection;
      this.serverChanging = true;
      this.socket.disconnect();
      this.connection(connection);
    });
    this.socket.on("changeTile", ({
      tiles,
      x: x2,
      y: y2
    }) => {
      const scene = this.renderer.getScene();
      scene == null ? void 0 : scene.changeTile(x2, y2, tiles);
    });
    const callMethod = ({
      objectId,
      params,
      name: name2
    }) => {
      const scene = this.renderer.getScene();
      const sprite2 = scene == null ? void 0 : scene.getPlayer(objectId);
      if (!sprite2)
        return;
      switch (name2) {
        case SocketMethods.ShowAnimation:
          scene == null ? void 0 : scene.showAnimation({
            attachTo: sprite2,
            graphic: params[0],
            animationName: params[1],
            replaceGraphic: params[2]
          });
          break;
        case SocketMethods.CameraFollow:
          const [spriteId, options2] = params;
          scene == null ? void 0 : scene.cameraFollowSprite(spriteId, options2);
          break;
        case SocketMethods.PlaySound:
          RpgSound.play(params[0]);
          break;
        case SocketMethods.ModeMove:
          const player2 = this.player;
          const {
            checkCollision
          } = params[0];
          if (player2) {
            player2.checkCollision = checkCollision;
          }
          break;
      }
    };
    this.socket.on(SocketEvents.CallMethod, callMethod);
    let lastRoomId = "";
    this.subscriptionWorld = World.listen(this.socket).value.subscribe(async (val) => {
      const scene = this.renderer.getScene();
      if (!val.data) {
        return;
      }
      const partialRoom = val.partial;
      if (val.roomId != lastRoomId) {
        this.clientFrames.clear();
        this.serverFrames.clear();
        this.gameEngine.resetObjects();
        lastRoomId = val.roomId;
        this.isTeleported = false;
      }
      const objectsChanged = {};
      const callAction = (objectId, paramsChanged) => {
        if (paramsChanged && SocketEvents.CallMethod in paramsChanged) {
          this.renderer.draw(Date.now(), 1, 1, 1);
          callMethod({
            objectId,
            ...paramsChanged[SocketEvents.CallMethod]
          });
        }
      };
      const change = (prop, root2 = val, localEvent = false) => {
        const list = root2.data[prop];
        const partial = root2.partial[prop];
        const isShape = prop == "shapes";
        if (!partial) {
          return;
        }
        if (val.resetProps.indexOf(prop) != -1) {
          const objects = isShape ? this.gameEngine.getShapes() : this.gameEngine.getObjects();
          for (let key in objects) {
            const obj = objects[key];
            if (obj) {
              this.gameEngine.removeObjectAndShape(key);
            }
          }
        }
        for (let key in partial) {
          const obj = list[key];
          const paramsChanged = partial ? partial[key] : void 0;
          if (obj == null || obj.deleted) {
            callAction(key, paramsChanged);
            this.gameEngine.removeObjectAndShape(key);
            continue;
          }
          if (!obj)
            continue;
          if (!isShape) {
            obj.type = {
              users: PlayerType.Player,
              events: PlayerType.Event
            }[prop];
          }
          if (prop == "users" && this.gameEngine.playerId == key) {
            if (obj.events) {
              const nbEvents = Object.values(obj.events);
              if (nbEvents.length == 0) {
                this.gameEngine.events = {};
              } else {
                change("events", {
                  data: obj,
                  partial: paramsChanged,
                  time: val.time,
                  roomId: val.roomId,
                  resetProps: val.resetProps
                }, true);
              }
            }
            if ((partialRoom == null ? void 0 : partialRoom.pos) && (partialRoom == null ? void 0 : partialRoom.frame) !== void 0) {
              this.serverFrames.set(partialRoom.frame, {
                data: partialRoom.pos,
                time: Date.now()
              });
            }
          }
          objectsChanged[key] = this.gameEngine.updateObject({
            playerId: key,
            params: obj,
            localEvent,
            paramsChanged,
            isShape
          });
          callAction(key, paramsChanged);
        }
      };
      if (partialRoom.join) {
        this.roomJoin.next(partialRoom);
        this.roomJoin.complete();
      }
      change("users");
      change("events");
      change("shapes");
      this.gameEngine.setObjectsChanged(objectsChanged);
      if (scene) {
        scene.update(val);
      }
    });
    this.socket.on("disconnect", (reason) => {
      if (this.serverChanging) {
        return;
      }
      if (RpgGui.exists(PrebuiltGui.Disconnect))
        RpgGui.display(PrebuiltGui.Disconnect);
      RpgPlugin.emit(HookClient.Disconnect, [this, reason, this.socket], true);
      this.hasBeenDisconnected = true;
    });
    RpgGui._setSocket(this.socket);
    if (standalone) {
      await this.socket.connection({
        auth: {
          token: this.session
        }
      });
    }
    this.serverChanging = false;
  }
  get world() {
    return World;
  }
  // shortcuts
  /**
  * VueJS Application instance
  *
  * [https://v3.vuejs.org/api/application-api.html](https://v3.vuejs.org/api/application-api.html)
  *
  * @prop {Vue} [vueApp]
  * @readonly
  * @memberof RpgClientEngine
  * */
  get vueApp() {
    return this.renderer.app;
  }
  /**
   * VueJS Parent component instance
   *
   * [https://v3.vuejs.org/api/instance-properties.html](https://v3.vuejs.org/api/instance-properties.html)
   *
   * @prop {Vue Instance} [vueInstance]
   * @readonly
   * @memberof RpgClientEngine
   * */
  get vueInstance() {
    return this.renderer.vm;
  }
  /**
   * retrieves the current scene (SceneMap if you are on a map)
   *
   * @prop {RpgScene} [scene]
   * @deprecated
   * @readonly
   * @memberof RpgClientEngine
   * */
  get scene() {
    return this.renderer.getScene();
  }
  /**
   * retrieves the current scene (SceneMap if you are on a map)
   *
   * @title Connect to server
   * @method getScene()
   * @returns {RpgScene}
   * @memberof RpgClientEngine
   */
  getScene() {
    return this.renderer.getScene();
  }
  /**
   * get PIXI class
   * @prop {PIXI} [PIXI]
   * @readonly
   * @memberof RpgClientEngine
   */
  get PIXI() {
    return PIXI;
  }
  /**
   * get player id of the current player
   * @prop {string} [playerId]
   * @readonly
   * @memberof RpgClientEngine
   */
  get playerId() {
    return this.gameEngine.playerId;
  }
  /**
   * Finds the game mode from the environment variables sent by the compiler.
   * Can be used in menus to display options according to type
   *
   * @title Game Type
   * @prop {string|undefined} [gameType] mmorpg | rpg or undefined if environment variable not found
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get gameType() {
    var _a;
    return (_a = this.envs) == null ? void 0 : _a["VITE_RPG_TYPE"];
  }
  /**
   * Find out if the game is in production or not, from the environment variables sent by the compiler.
   *
   * @title Game is dev mode
   * @prop {boolean} [isDev]
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get isDev() {
    var _a;
    return !((_a = this.envs) == null ? void 0 : _a["VITE_BUILT"]);
  }
  /**
   * Get the server url. This is the url for the websocket
   *
   * To customize the URL, use the `matchMakerService` configuration
   *
   * @title Server URL
   * @prop {string} [serverUrl] If empty string, server url is same as client url
   * @readonly
   * @memberof RpgClientEngine
   * @since 4.0.0
   */
  get serverUrl() {
    if (!this._serverUrl.startsWith("http")) {
      return "http://" + this._serverUrl;
    }
    return this._serverUrl;
  }
  get assetsPath() {
    var _a;
    return ((_a = this.envs) == null ? void 0 : _a["VITE_ASSETS_PATH"]) || "assets";
  }
  get module() {
    return RpgPlugin;
  }
  reset() {
    this.subscriptionWorld.unsubscribe();
    this.world.reset();
    spritesheets.clear();
    sounds.clear();
    Assets.reset();
    clearTextureCache();
    for (let textureUrl in BaseTextureCache) {
      delete BaseTextureCache[textureUrl];
    }
    for (let textureUrl in TextureCache) {
      delete TextureCache[textureUrl];
    }
    RpgGui.clear();
    RpgCommonMap.bufferClient.clear();
    RpgSound.clear();
  }
};
let instanceContext = null;
function inject(service, args = []) {
  return instanceContext.inject(service, args);
}
function setInject(context2) {
  instanceContext = context2;
}
const entryPointClient = (modules, options2) => {
  if (!options2.globalConfig)
    options2.globalConfig = {};
  options2 = {
    ...options2.globalConfig,
    ...options2
  };
  const relations = {
    onInit: HookClient.AddSprite,
    onDestroy: HookClient.RemoveSprite,
    onUpdate: HookClient.UpdateSprite,
    onChanges: HookClient.ChangesSprite,
    onMove: HookClient.SpriteMove
  };
  const relationsMap = {
    onAddSprite: HookClient.SceneAddSprite,
    onRemoveSprite: HookClient.SceneRemoveSprite,
    onBeforeLoading: HookClient.BeforeSceneLoading,
    onAfterLoading: HookClient.AfterSceneLoading,
    onMapLoading: HookClient.SceneMapLoading,
    onChanges: HookClient.SceneOnChanges,
    onDraw: HookClient.SceneDraw
  };
  const relationsEngine = {
    onStart: HookClient.Start,
    onStep: HookClient.Step,
    onConnected: HookClient.Connected,
    onDisconnect: HookClient.Disconnect,
    onConnectError: HookClient.ConnectedError,
    onInput: HookClient.SendInput,
    onWindowResize: HookClient.WindowResize
  };
  loadModules(modules, {
    side: "client",
    relations: {
      player: relations,
      sceneMap: relationsMap,
      engine: relationsEngine
    }
  });
  const context2 = new InjectContext();
  setInject(context2);
  return context2.inject(RpgClientEngine$4, [options2]);
};
const RMSpritesheet = (framesWidth, framesHeight, frameStand = 1) => {
  if (framesWidth <= frameStand) {
    frameStand = framesWidth - 1;
  }
  const frameY = (direction) => {
    const gap = Math.max(4 - framesHeight, 0);
    return {
      [Direction.Down]: 0,
      [Direction.Left]: Math.max(0, 1 - gap),
      [Direction.Right]: Math.max(0, 2 - gap),
      [Direction.Up]: Math.max(0, 3 - gap)
    }[direction];
  };
  const stand = (direction) => [{
    time: 0,
    frameX: frameStand,
    frameY: frameY(direction)
  }];
  const walk = (direction) => {
    const array2 = [];
    const durationFrame = 10;
    for (let i2 = 0; i2 < framesWidth; i2++) {
      array2.push({
        time: i2 * durationFrame,
        frameX: i2,
        frameY: frameY(direction)
      });
    }
    array2.push({
      time: array2[array2.length - 1].time + durationFrame
    });
    return array2;
  };
  return {
    textures: {
      [Animation$1.Stand]: {
        animations: (direction) => [stand(direction)]
      },
      [Animation$1.Walk]: {
        animations: (direction) => [walk(direction)]
      }
    },
    framesHeight,
    framesWidth
  };
};
const Presets = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RMSpritesheet
}, Symbol.toStringTag, { value: "Module" }));
const RpgResource = {
  spritesheets,
  sounds
};
const {
  serverIo,
  ClientIo
} = MockSocketIo;
function entryPoint(modules, options2 = {}) {
  const io = new ClientIo();
  class StandaloneGame {
    async start() {
      this.client = entryPointClient(modules, {
        standalone: true,
        io,
        globalConfig: options2.globalConfigClient,
        ...options2
      });
      this.server = await entryPointServer(modules, {
        io: serverIo,
        standalone: true,
        basePath: "",
        globalConfig: options2.globalConfigServer,
        ...options2
      });
      await this.server.start();
      await this.client.start();
      return this;
    }
    setHooks(hooks, side) {
      if (!isArray$d(hooks))
        modules.push({
          [side]: hooks
        });
      else
        modules.concat(hooks.map((hook) => {
          return {
            [side]: hook
          };
        }));
    }
    logicHooks(serverHooks) {
      this.setHooks(serverHooks, "server");
    }
    renderHooks(clientHooks) {
      this.setHooks(clientHooks, "client");
    }
  }
  return new StandaloneGame();
}
var EmotionBubble = /* @__PURE__ */ ((EmotionBubble2) => {
  EmotionBubble2["Like"] = "like";
  EmotionBubble2["Confusion"] = "confusion";
  EmotionBubble2["Question"] = "question";
  EmotionBubble2["LikeBreak"] = "like-break";
  EmotionBubble2["Exclamation"] = "surprise";
  EmotionBubble2["OneDot"] = "one-dot";
  EmotionBubble2["TwoDot"] = "two-dot";
  EmotionBubble2["ThreeDot"] = "three-dot";
  EmotionBubble2["Dollar"] = "dollar";
  EmotionBubble2["Stars"] = "starts";
  EmotionBubble2["Music"] = "music";
  EmotionBubble2["Exclamation2"] = "exclamation";
  EmotionBubble2["Jaded"] = "jaded";
  EmotionBubble2["Star"] = "star";
  EmotionBubble2["HaHa"] = "haha";
  EmotionBubble2["Sad"] = "sad";
  EmotionBubble2["Hangry"] = "hungry";
  EmotionBubble2["Idea"] = "idea";
  EmotionBubble2["Z"] = "z";
  EmotionBubble2["zZ"] = "zz";
  EmotionBubble2["Likes"] = "likes";
  EmotionBubble2["Empty"] = "empty";
  EmotionBubble2["Circle"] = "circle";
  EmotionBubble2["Hangry2"] = "hungry2";
  EmotionBubble2["Cross"] = "cross";
  EmotionBubble2["Bead"] = "bead";
  EmotionBubble2["Beads"] = "beads";
  EmotionBubble2["Happy"] = "happy";
  EmotionBubble2["Cloud"] = "cloud";
  EmotionBubble2["Surprise"] = "surprise";
  return EmotionBubble2;
})(EmotionBubble || {});
const vitePluginRequire_1743700425867_78632947 = "/assets/bubble-acdc3f6e.png";
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$a = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$a(target, key, result);
  return result;
};
const icon$1 = (frameX, frameY) => {
  return {
    animations: new Timeline().add(30, ({
      scale
    }) => [{
      frameX,
      frameY,
      scale: [scale]
    }], {
      scale: {
        from: 0,
        to: 1,
        easing: Ease.easeOutBounce
      }
    }).add(100).add(30, ({
      scale
    }) => [{
      frameX,
      frameY,
      scale: [scale]
    }], {
      scale: {
        from: 1,
        to: 0,
        easing: Ease.easeInBounce
      }
    }).create()
  };
};
function Emote(options2 = {}) {
  if (!options2.textures)
    options2.textures = {
      [EmotionBubble.Confusion]: [0, 0],
      [EmotionBubble.Question]: [1, 0],
      [EmotionBubble.LikeBreak]: [2, 0],
      [EmotionBubble.Exclamation]: [3, 0],
      [EmotionBubble.TwoDot]: [4, 0],
      [EmotionBubble.Dollar]: [5, 0],
      [EmotionBubble.Stars]: [0, 1],
      [EmotionBubble.Music]: [1, 1],
      [EmotionBubble.Like]: [2, 1],
      [EmotionBubble.Exclamation2]: [3, 1],
      [EmotionBubble.OneDot]: [4, 1],
      [EmotionBubble.Jaded]: [5, 1],
      [EmotionBubble.Star]: [0, 2],
      [EmotionBubble.HaHa]: [1, 2],
      [EmotionBubble.Sad]: [2, 2],
      [EmotionBubble.Beads]: [3, 2],
      [EmotionBubble.Cross]: [4, 2],
      [EmotionBubble.Hangry]: [5, 2],
      [EmotionBubble.zZ]: [0, 3],
      [EmotionBubble.Idea]: [1, 3],
      [EmotionBubble.Happy]: [2, 3],
      [EmotionBubble.Bead]: [3, 3],
      [EmotionBubble.Cloud]: [4, 3],
      [EmotionBubble.Surprise]: [5, 3],
      [EmotionBubble.Z]: [0, 4],
      [EmotionBubble.Likes]: [1, 4],
      [EmotionBubble.Empty]: [2, 4],
      [EmotionBubble.ThreeDot]: [3, 4],
      [EmotionBubble.Circle]: [4, 4],
      [EmotionBubble.Hangry2]: [5, 4]
    };
  for (let key in options2.textures) {
    options2.textures[key] = icon$1.apply(null, options2.textures[key]);
  }
  let EmoteSprite = class {
  };
  EmoteSprite = __decorateClass$a([Spritesheet({
    id: "bubble",
    image: options2.image || vitePluginRequire_1743700425867_78632947,
    width: options2.width || 192,
    height: options2.height || 190,
    framesHeight: options2.framesHeight || 5,
    framesWidth: options2.framesWidth || 6,
    anchor: options2.anchor || [0.5],
    y: options2.y || -40,
    x: options2.x || 10,
    ...options2
  })], EmoteSprite);
  return EmoteSprite;
}
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$9(target, key, result);
  return result;
};
let RpgClientModule$1 = class RpgClientModule {
};
RpgClientModule$1 = __decorateClass$9([
  RpgModule({
    engine: {
      onStart(engine) {
        engine.addSpriteSheet(Emote(engine.globalConfig.emotionBubble));
      }
    }
  })
], RpgClientModule$1);
RpgPlayer.prototype.showEmotionBubble = function(emotion) {
  this.showAnimation("bubble", emotion);
};
const _rpgjs_plugin_emotion_bubbles = {
  client: RpgClientModule$1
};
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const name = "rpg-title-screen";
const _sfc_main$n = {
  name,
  inject: ["rpgEngine", "rpgGui", "rpgGuiInteraction", "rpgKeypress", "rpgSound"],
  data() {
    return {
      menu: [{
        text: "Start Game",
        value: "start"
      }, {
        text: "Load Game",
        value: "load"
      }, {
        text: "Options",
        value: "options"
      }],
      step: "title",
      title: ""
    };
  },
  mounted() {
    const {
      titleScreen
    } = this.rpgEngine.globalConfig;
    if (titleScreen) {
      this.title = titleScreen.title;
      if (titleScreen.music) {
        this.rpgSound.get(titleScreen.music).play();
      }
    }
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      if (control.actionName == Control.Back) {
        this.step = "title";
      }
    });
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
  },
  methods: {
    selected(index2) {
      const {
        value
      } = this.menu[index2];
      switch (value) {
        case "start":
          this.rpgGuiInteraction("rpg-title-screen", "start-game");
          break;
        case "load":
          this.step = "load";
          break;
        case "options":
          this.rpgGui.hide(name);
          this.rpgGui.display("rpg-options");
          break;
      }
    }
  },
  computed: {
    menuChoice() {
      return this.menu.filter((menu) => {
        if (menu.value == "load" && !this.rpgGui.exists("rpg-load")) {
          return false;
        } else if (menu.value == "options" && !this.rpgGui.exists("rpg-options")) {
          return false;
        }
        return true;
      });
    },
    isMMO() {
      return this.rpgEngine.gameType == "mmorpg";
    }
  }
};
const title_vue_vue_type_style_index_0_scoped_55946fc4_lang = "";
const _hoisted_1$f = { class: "background" };
const _hoisted_2$c = {
  key: 0,
  class: "title"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_rpg_load = resolveComponent("rpg-load");
  const _component_rpg_login = resolveComponent("rpg-login");
  return openBlock(), createElementBlock("div", _hoisted_1$f, [
    $data.step == "title" ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
      createBaseVNode("h1", null, toDisplayString($data.title), 1)
    ])) : createCommentVNode("", true),
    !$options.isMMO ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(["full", `step-${$data.step}`])
    }, [
      $data.step == "title" ? (openBlock(), createBlock(_component_rpg_window, {
        key: 0,
        width: "200px",
        position: "bottom-middle",
        class: "margin-bottom"
      }, {
        default: withCtx(() => [
          createVNode(_component_rpg_choice, {
            choices: $options.menuChoice,
            onSelected: $options.selected
          }, null, 8, ["choices", "onSelected"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_rpg_load, { key: 1 }))
    ], 2)) : (openBlock(), createBlock(_component_rpg_login, {
      key: 2,
      class: "margin-bottom"
    }))
  ]);
}
const titleGui = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__scopeId", "data-v-55946fc4"]]);
const createAccount_vue_vue_type_style_index_0_scoped_724e64d2_lang = "";
const NICKNAME_EXISTS_MSG = "The nickname already exists, please choose another one";
const _sfc_main$m = {
  name: "rpg-login",
  inject: ["rpgEngine", "rpgGui"],
  data() {
    return {
      user: {},
      confirmPassword: "",
      nicknameExists: false
    };
  },
  computed: {
    apiUrl() {
      var _a;
      return ((_a = this.rpgEngine.globalConfig.titleScreen) == null ? void 0 : _a.apiUrl) ?? this.rpgEngine.serverUrl;
    }
  },
  methods: {
    async createAccount() {
      try {
        if (this.nicknameExists) {
          throw NICKNAME_EXISTS_MSG;
        }
        if (!this.user.nickname) {
          throw "Please enter a nickname";
        }
        if (!this.user.password) {
          throw "Please enter a password";
        }
        if (!this.user.email) {
          throw "Please enter an email";
        }
        if (this.user.password > 6) {
          throw "Set a password with at least 6 characters";
        }
        if (this.user.password != this.confirmPassword) {
          throw "The confirmed password is different from the password";
        }
        await axios$1.post(this.apiUrl + "/user/create", this.user);
        this.rpgGui.display("rpg-notification", {
          message: "Your account has been created. Log in now to play the game",
          time: 5e3,
          position: "top",
          type: "success"
        });
        this.$emit("back");
      } catch (err) {
        if (typeof err == "string") {
          this.notificationError(err);
        }
      }
    },
    notificationError(msg) {
      this.rpgGui.display("rpg-notification", {
        message: msg,
        time: 5e3,
        position: "top",
        type: "error"
      });
    },
    async checkExist() {
      const { data } = await axios$1.post(this.apiUrl + "/user/exists", {
        nickname: this.user.nickname
      });
      this.nicknameExists = data.exists;
      if (this.nicknameExists) {
        this.notificationError(NICKNAME_EXISTS_MSG);
      }
    }
  }
};
const _withScopeId$3 = (n2) => (pushScopeId("data-v-724e64d2"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$e = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("p", null, "Create account to play", -1));
const _hoisted_2$b = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("button", { class: "btn-success login" }, "Create", -1));
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createBlock(_component_rpg_window, {
    width: "300px",
    position: "bottom-middle"
  }, {
    default: withCtx(() => [
      _hoisted_1$e,
      createBaseVNode("form", {
        onSubmit: _cache[6] || (_cache[6] = withModifiers((...args) => $options.createAccount && $options.createAccount(...args), ["prevent"]))
      }, [
        withDirectives(createBaseVNode("input", {
          type: "text",
          placeholder: "Nickname",
          required: "",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.user.nickname = $event),
          onBlur: _cache[1] || (_cache[1] = (...args) => $options.checkExist && $options.checkExist(...args))
        }, null, 544), [
          [vModelText, $data.user.nickname]
        ]),
        withDirectives(createBaseVNode("input", {
          type: "email",
          placeholder: "Email",
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.user.email = $event)
        }, null, 512), [
          [vModelText, $data.user.email]
        ]),
        withDirectives(createBaseVNode("input", {
          type: "password",
          placeholder: "Password (6 characters min.)",
          required: "",
          minlength: "6",
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.user.password = $event)
        }, null, 512), [
          [vModelText, $data.user.password]
        ]),
        withDirectives(createBaseVNode("input", {
          type: "password",
          placeholder: "Confirm Password",
          required: "",
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.confirmPassword = $event)
        }, null, 512), [
          [vModelText, $data.confirmPassword]
        ]),
        _hoisted_2$b,
        createBaseVNode("button", {
          class: "css-button-3d--grey",
          type: "button",
          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("back"))
        }, "Back")
      ], 32)
    ]),
    _: 1
  });
}
const CreateAccount = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__scopeId", "data-v-724e64d2"]]);
const connect_vue_vue_type_style_index_0_scoped_a9163a4a_lang = "";
const _sfc_main$l = {
  name: "rpg-login",
  inject: ["rpgGui", "rpgGuiInteraction", "rpgSocket"],
  components: {
    CreateAccount
  },
  data() {
    return {
      page: "login",
      user: {}
    };
  },
  mounted() {
    const socket = this.rpgSocket();
    socket.on("login-fail", ({ message }) => {
      let msg = "";
      switch (message) {
        case "LOGIN_FAIL":
          msg = "Your login details are not correct!";
          break;
        case "PLAYER_IN_GAME":
          msg = "You are already playing in the game";
          break;
        default:
          msg = "An error has occurred";
      }
      this.notificationError(msg);
    });
  },
  methods: {
    login() {
      if (!this.user.nickname) {
        return this.notificationError("Please enter a nickname");
      }
      if (!this.user.password) {
        return this.notificationError("Please enter a password");
      }
      this.rpgGuiInteraction("rpg-title-screen", "login", this.user);
    },
    notificationError(msg) {
      this.rpgGui.display("rpg-notification", {
        message: msg,
        time: 5e3,
        position: "top",
        type: "error"
      });
    }
  }
};
const _withScopeId$2 = (n2) => (pushScopeId("data-v-a9163a4a"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$d = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("p", null, "Connect to server with your account", -1));
const _hoisted_2$a = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("button", { class: "btn-success login" }, "Login", -1));
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_CreateAccount = resolveComponent("CreateAccount");
  return $data.page == "login" ? (openBlock(), createBlock(_component_rpg_window, {
    key: 0,
    width: "300px",
    position: "bottom-middle"
  }, {
    default: withCtx(() => [
      _hoisted_1$d,
      createBaseVNode("form", {
        onSubmit: _cache[3] || (_cache[3] = withModifiers((...args) => $options.login && $options.login(...args), ["prevent"]))
      }, [
        withDirectives(createBaseVNode("input", {
          type: "text",
          placeholder: "Nickname",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.user.nickname = $event)
        }, null, 512), [
          [vModelText, $data.user.nickname]
        ]),
        withDirectives(createBaseVNode("input", {
          type: "password",
          placeholder: "Password",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.user.password = $event)
        }, null, 512), [
          [vModelText, $data.user.password]
        ]),
        _hoisted_2$a,
        createBaseVNode("button", {
          class: "css-button-3d--grey",
          type: "button",
          onClick: _cache[2] || (_cache[2] = ($event) => $data.page = "create")
        }, "Create account")
      ], 32)
    ]),
    _: 1
  })) : (openBlock(), createBlock(_component_CreateAccount, {
    key: 1,
    onBack: _cache[4] || (_cache[4] = ($event) => $data.page = "login")
  }));
}
const loginGui = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__scopeId", "data-v-a9163a4a"]]);
const sprite$1 = {};
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$8(target, key, result);
  return result;
};
let RpgClientEngine$3 = class RpgClientEngine2 {
};
RpgClientEngine$3 = __decorateClass$8([
  RpgModule({
    sprite: sprite$1,
    gui: [
      titleGui,
      loginGui
    ]
  })
], RpgClientEngine$3);
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$7(target, key, result);
  return result;
};
let RpgServerModule = class {
};
RpgServerModule = __decorateClass$7([
  RpgModule({
    player: {
      onConnected(player2) {
        const gui = player2.gui("rpg-title-screen");
        gui.on("load-game", ({ index: index2 }) => {
          const storage = localStorage.getItem("rpgjs-save");
          if (storage) {
            const slots = JSON.parse(storage);
            const slot = slots[index2];
            gui.close();
            player2.load(slot);
            player2.canMove = true;
          }
        });
        gui.on("start-game", () => {
          gui.close();
          player2.changeMap(player2.server.globalConfig.start.map);
        });
      }
    }
  })
], RpgServerModule);
const server = RpgServerModule;
const _rpgjs_title_screen = {
  client: RpgClientEngine$3,
  server
};
const sprite = {};
const slots_vue_vue_type_style_index_0_scoped_c729d47b_lang = "";
const STORAGE_KEYNAME = "rpgjs-save";
const _sfc_main$k = {
  props: ["mode"],
  inject: ["rpgSocket", "rpgResource", "rpgGuiInteraction"],
  data() {
    return {
      slotsStorage: {}
    };
  },
  mounted() {
    const storage = localStorage.getItem(STORAGE_KEYNAME);
    this.slotsStorage = JSON.parse(storage) || {};
    if (this.mode == "save") {
      const socket = this.rpgSocket();
      socket.on("saved", ({ slot, data, date }) => {
        this.slotsStorage[slot] = {
          ...JSON.parse(data),
          date
        };
        localStorage.setItem(STORAGE_KEYNAME, JSON.stringify(this.slotsStorage));
        this.$emit("saved");
      });
    }
  },
  methods: {
    choiceItem(index2) {
      if (this.mode == "save") {
        const socket = this.rpgSocket();
        socket.emit("save", index2);
      } else {
        this.rpgGuiInteraction("rpg-title-screen", "load-game", {
          index: index2
        });
      }
      this.$emit("slotSelected", index2);
    },
    toDate(timestamp) {
      const date = new Date(timestamp);
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const hour = date.getHours();
      const minute = date.getMinutes();
      return `${year}/${month}/${day} ${hour}:${minute}`;
    }
  },
  computed: {
    slots() {
      const array2 = [];
      for (let i2 = 0; i2 < 4; i2++) {
        const slot = this.slotsStorage[i2];
        if (slot) {
          const sprite2 = this.rpgResource.spritesheets.get(slot.graphic);
          array2.push({ text: slot.date, value: i2, isData: true, sprite: sprite2, slot });
        } else {
          array2.push({ text: "File " + (i2 + 1), value: i2 });
        }
      }
      return array2;
    }
  }
};
const _hoisted_1$c = { class: "help" };
const _hoisted_2$9 = { class: "slot" };
const _hoisted_3$6 = {
  key: 0,
  class: "slot-info"
};
const _hoisted_4$3 = { key: 1 };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createBlock(_component_rpg_window, {
    width: "100%",
    height: "100%"
  }, {
    default: withCtx(() => [
      createBaseVNode("p", _hoisted_1$c, toDisplayString($props.mode == "save" ? "Select slot to save your game" : "Select slot to load your game"), 1),
      createVNode(_component_rpg_choice, {
        choices: $options.slots,
        onSelected: $options.choiceItem
      }, {
        default: withCtx(({ choice }) => [
          createBaseVNode("div", _hoisted_2$9, [
            choice.isData ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
              createBaseVNode("div", null, [
                createBaseVNode("div", {
                  class: "sprite",
                  style: normalizeStyle({
                    height: `${choice.sprite.height / choice.sprite.framesHeight}px`,
                    width: `${choice.sprite.width / choice.sprite.framesWidth}px`,
                    "background-image": `url(${choice.sprite.images[choice.slot.graphic]})`
                  })
                }, null, 4),
                createBaseVNode("p", null, "Level " + toDisplayString(choice.slot.level), 1)
              ]),
              createBaseVNode("p", null, toDisplayString($options.toDate(choice.text)), 1)
            ])) : (openBlock(), createElementBlock("p", _hoisted_4$3, toDisplayString(choice.text), 1))
          ])
        ]),
        _: 1
      }, 8, ["choices", "onSelected"])
    ]),
    _: 1
  });
}
const Slots = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-c729d47b"]]);
const _sfc_main$j = {
  name: "rpg-load",
  components: {
    Slots
  }
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slots = resolveComponent("Slots");
  return openBlock(), createBlock(_component_Slots, { mode: "load" });
}
const loadGui = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
const _sfc_main$i = {
  name: "rpg-save",
  components: {
    Slots
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slots = resolveComponent("Slots");
  return openBlock(), createBlock(_component_Slots, {
    mode: "save",
    onSlotSelected: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("slotSelected", $event)),
    onSaved: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("saved"))
  });
}
const saveGui = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let RpgClientEngine$2 = class RpgClientEngine3 {
};
RpgClientEngine$2 = __decorateClass$6([
  RpgModule({
    sprite,
    gui: [
      loadGui,
      saveGui
    ]
  })
], RpgClientEngine$2);
const player = {
  onConnected(player2) {
    player2._socket.on("save", (index2) => {
      const json = player2.save();
      player2.emit("saved", {
        slot: index2,
        data: json,
        date: Date.now()
      });
    });
  }
};
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
let RpgServerEngine2 = class {
};
RpgServerEngine2 = __decorateClass$5([
  RpgModule({
    player,
    engine: {
      onStart(server2) {
      }
    }
  })
], RpgServerEngine2);
const _rpgjs_save = {
  client: RpgClientEngine$2,
  server: RpgServerEngine2
};
const distance = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};
const angle = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return degrees(Math.atan2(dy, dx));
};
const findCoord = (p2, d2, a8) => {
  const b3 = { x: 0, y: 0 };
  a8 = radians(a8);
  b3.x = p2.x - d2 * Math.cos(a8);
  b3.y = p2.y - d2 * Math.sin(a8);
  return b3;
};
const radians = (a8) => {
  return a8 * (Math.PI / 180);
};
const degrees = (a8) => {
  return a8 * (180 / Math.PI);
};
const isPressed = (evt) => {
  if (isNaN(evt.buttons)) {
    return evt.pressure !== 0;
  }
  return evt.buttons !== 0;
};
const timers = /* @__PURE__ */ new Map();
const throttle = (cb) => {
  if (timers.has(cb)) {
    clearTimeout(timers.get(cb));
  }
  timers.set(cb, setTimeout(cb, 100));
};
const bindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.addEventListener) {
      el.addEventListener(type, handler, false);
    } else if (el.attachEvent) {
      el.attachEvent(type, handler);
    }
  }
};
const unbindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (el.removeEventListener) {
      el.removeEventListener(type, handler);
    } else if (el.detachEvent) {
      el.detachEvent(type, handler);
    }
  }
};
const prepareEvent = (evt) => {
  evt.preventDefault();
  return evt.type.match(/^touch/) ? evt.changedTouches : evt;
};
const getScroll = () => {
  const x2 = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y2 = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return {
    x: x2,
    y: y2
  };
};
const applyPosition = (el, pos) => {
  if (pos.top || pos.right || pos.bottom || pos.left) {
    el.style.top = pos.top;
    el.style.right = pos.right;
    el.style.bottom = pos.bottom;
    el.style.left = pos.left;
  } else {
    el.style.left = pos.x + "px";
    el.style.top = pos.y + "px";
  }
};
const getTransitionStyle = (property, values, time) => {
  const obj = configStylePropertyObject(property);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (typeof values === "string") {
        obj[i2] = values + " " + time;
      } else {
        let st2 = "";
        for (let j2 = 0, max = values.length; j2 < max; j2 += 1) {
          st2 += values[j2] + " " + time + ", ";
        }
        obj[i2] = st2.slice(0, -2);
      }
    }
  }
  return obj;
};
const getVendorStyle = (property, value) => {
  const obj = configStylePropertyObject(property);
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      obj[i2] = value;
    }
  }
  return obj;
};
const configStylePropertyObject = (prop) => {
  const obj = {};
  obj[prop] = "";
  const vendors = ["webkit", "Moz", "o"];
  vendors.forEach(function(vendor) {
    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = "";
  });
  return obj;
};
const extend = (objA, objB) => {
  for (let i2 in objB) {
    if (objB.hasOwnProperty(i2)) {
      objA[i2] = objB[i2];
    }
  }
  return objA;
};
const safeExtend = (objA, objB) => {
  const obj = {};
  for (let i2 in objA) {
    if (objA.hasOwnProperty(i2) && objB.hasOwnProperty(i2)) {
      obj[i2] = objB[i2];
    } else if (objA.hasOwnProperty(i2)) {
      obj[i2] = objA[i2];
    }
  }
  return obj;
};
const map = (ar, fn) => {
  if (ar.length) {
    for (let i2 = 0, max = ar.length; i2 < max; i2 += 1) {
      fn(ar[i2]);
    }
  } else {
    fn(ar);
  }
};
const clamp = (pos, nipplePos, size2) => ({
  //                          left-clamping        right-clamping
  x: Math.min(Math.max(pos.x, nipplePos.x - size2), nipplePos.x + size2),
  //                          top-clamping         bottom-clamping
  y: Math.min(Math.max(pos.y, nipplePos.y - size2), nipplePos.y + size2)
});
var isTouch = !!("ontouchstart" in window);
var isPointer = window.PointerEvent ? true : false;
var isMSPointer = window.MSPointerEvent ? true : false;
var events = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend, touchcancel"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup"
  },
  pointer: {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup, pointercancel"
  },
  MSPointer: {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  }
};
var toBind;
var secondBind = {};
if (isPointer) {
  toBind = events.pointer;
} else if (isMSPointer) {
  toBind = events.MSPointer;
} else if (isTouch) {
  toBind = events.touch;
  secondBind = events.mouse;
} else {
  toBind = events.mouse;
}
function Super() {
}
Super.prototype.on = function(arg, cb) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    self2._handlers_[type] = self2._handlers_[type] || [];
    self2._handlers_[type].push(cb);
  }
  return self2;
};
Super.prototype.off = function(type, cb) {
  var self2 = this;
  self2._handlers_ = self2._handlers_ || {};
  if (type === void 0) {
    self2._handlers_ = {};
  } else if (cb === void 0) {
    self2._handlers_[type] = null;
  } else if (self2._handlers_[type] && self2._handlers_[type].indexOf(cb) >= 0) {
    self2._handlers_[type].splice(self2._handlers_[type].indexOf(cb), 1);
  }
  return self2;
};
Super.prototype.trigger = function(arg, data) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i2 = 0; i2 < types.length; i2 += 1) {
    type = types[i2];
    if (self2._handlers_[type] && self2._handlers_[type].length) {
      self2._handlers_[type].forEach(function(handler) {
        handler.call(self2, {
          type,
          target: self2
        }, data);
      });
    }
  }
};
Super.prototype.config = function(options2) {
  var self2 = this;
  self2.options = self2.defaults || {};
  if (options2) {
    self2.options = safeExtend(self2.options, options2);
  }
};
Super.prototype.bindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  self2._domHandlers_[type] = function() {
    if (typeof self2["on" + type] === "function") {
      self2["on" + type].apply(self2, arguments);
    } else {
      console.warn('[WARNING] : Missing "on' + type + '" handler.');
    }
  };
  bindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    bindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  return self2;
};
Super.prototype.unbindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  unbindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    unbindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  delete self2._domHandlers_[type];
  return this;
};
function Nipple(collection, options2) {
  this.identifier = options2.identifier;
  this.position = options2.position;
  this.frontPosition = options2.frontPosition;
  this.collection = collection;
  this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: false,
    lockY: false,
    shape: "circle"
  };
  this.config(options2);
  if (this.options.mode === "dynamic") {
    this.options.restOpacity = 0;
  }
  this.id = Nipple.id;
  Nipple.id += 1;
  this.buildEl().stylize();
  this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  };
  return this.instance;
}
Nipple.prototype = new Super();
Nipple.constructor = Nipple;
Nipple.id = 0;
Nipple.prototype.buildEl = function(options2) {
  this.ui = {};
  if (this.options.dataOnly) {
    return this;
  }
  this.ui.el = document.createElement("div");
  this.ui.back = document.createElement("div");
  this.ui.front = document.createElement("div");
  this.ui.el.className = "nipple collection_" + this.collection.id;
  this.ui.back.className = "back";
  this.ui.front.className = "front";
  this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id);
  this.ui.el.appendChild(this.ui.back);
  this.ui.el.appendChild(this.ui.front);
  return this;
};
Nipple.prototype.stylize = function() {
  if (this.options.dataOnly) {
    return this;
  }
  var animTime = this.options.fadeTime + "ms";
  var borderStyle = getVendorStyle("borderRadius", "50%");
  var transitStyle = getTransitionStyle("transition", "opacity", animTime);
  var styles = {};
  styles.el = {
    position: "absolute",
    opacity: this.options.restOpacity,
    display: "block",
    "zIndex": 999
  };
  styles.back = {
    position: "absolute",
    display: "block",
    width: this.options.size + "px",
    height: this.options.size + "px",
    marginLeft: -this.options.size / 2 + "px",
    marginTop: -this.options.size / 2 + "px",
    background: this.options.color,
    "opacity": ".5"
  };
  styles.front = {
    width: this.options.size / 2 + "px",
    height: this.options.size / 2 + "px",
    position: "absolute",
    display: "block",
    marginLeft: -this.options.size / 4 + "px",
    marginTop: -this.options.size / 4 + "px",
    background: this.options.color,
    "opacity": ".5",
    transform: "translate(0px, 0px)"
  };
  extend(styles.el, transitStyle);
  if (this.options.shape === "circle") {
    extend(styles.back, borderStyle);
  }
  extend(styles.front, borderStyle);
  this.applyStyles(styles);
  return this;
};
Nipple.prototype.applyStyles = function(styles) {
  for (var i2 in this.ui) {
    if (this.ui.hasOwnProperty(i2)) {
      for (var j2 in styles[i2]) {
        this.ui[i2].style[j2] = styles[i2][j2];
      }
    }
  }
  return this;
};
Nipple.prototype.addToDom = function() {
  if (this.options.dataOnly || document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.appendChild(this.ui.el);
  return this;
};
Nipple.prototype.removeFromDom = function() {
  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.removeChild(this.ui.el);
  return this;
};
Nipple.prototype.destroy = function() {
  clearTimeout(this.removeTimeout);
  clearTimeout(this.showTimeout);
  clearTimeout(this.restTimeout);
  this.trigger("destroyed", this.instance);
  this.removeFromDom();
  this.off();
};
Nipple.prototype.show = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.addToDom();
  self2.restCallback();
  setTimeout(function() {
    self2.ui.el.style.opacity = 1;
  }, 0);
  self2.showTimeout = setTimeout(function() {
    self2.trigger("shown", self2.instance);
    if (typeof cb === "function") {
      cb.call(this);
    }
  }, self2.options.fadeTime);
  return self2;
};
Nipple.prototype.hide = function(cb) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  self2.ui.el.style.opacity = self2.options.restOpacity;
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.removeTimeout = setTimeout(
    function() {
      var display = self2.options.mode === "dynamic" ? "none" : "block";
      self2.ui.el.style.display = display;
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.trigger("hidden", self2.instance);
    },
    self2.options.fadeTime
  );
  if (self2.options.restJoystick) {
    const rest = self2.options.restJoystick;
    const newPosition = {};
    newPosition.x = rest === true || rest.x !== false ? 0 : self2.instance.frontPosition.x;
    newPosition.y = rest === true || rest.y !== false ? 0 : self2.instance.frontPosition.y;
    self2.setPosition(cb, newPosition);
  }
  return self2;
};
Nipple.prototype.setPosition = function(cb, position) {
  var self2 = this;
  self2.frontPosition = {
    x: position.x,
    y: position.y
  };
  var animTime = self2.options.fadeTime + "ms";
  var transitStyle = {};
  transitStyle.front = getTransitionStyle(
    "transition",
    ["transform"],
    animTime
  );
  var styles = { front: {} };
  styles.front = {
    transform: "translate(" + self2.frontPosition.x + "px," + self2.frontPosition.y + "px)"
  };
  self2.applyStyles(transitStyle);
  self2.applyStyles(styles);
  self2.restTimeout = setTimeout(
    function() {
      if (typeof cb === "function") {
        cb.call(self2);
      }
      self2.restCallback();
    },
    self2.options.fadeTime
  );
};
Nipple.prototype.restCallback = function() {
  var self2 = this;
  var transitStyle = {};
  transitStyle.front = getTransitionStyle("transition", "none", "");
  self2.applyStyles(transitStyle);
  self2.trigger("rested", self2.instance);
};
Nipple.prototype.resetDirection = function() {
  this.direction = {
    x: false,
    y: false,
    angle: false
  };
};
Nipple.prototype.computeDirection = function(obj) {
  var rAngle = obj.angle.radian;
  var angle45 = Math.PI / 4;
  var angle90 = Math.PI / 2;
  var direction, directionX, directionY;
  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {
    direction = "up";
  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {
    direction = "left";
  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {
    direction = "down";
  } else if (!obj.lockY) {
    direction = "right";
  }
  if (!obj.lockY) {
    if (rAngle > -angle90 && rAngle < angle90) {
      directionX = "left";
    } else {
      directionX = "right";
    }
  }
  if (!obj.lockX) {
    if (rAngle > 0) {
      directionY = "up";
    } else {
      directionY = "down";
    }
  }
  if (obj.force > this.options.threshold) {
    var oldDirection = {};
    var i2;
    for (i2 in this.direction) {
      if (this.direction.hasOwnProperty(i2)) {
        oldDirection[i2] = this.direction[i2];
      }
    }
    var same = {};
    this.direction = {
      x: directionX,
      y: directionY,
      angle: direction
    };
    obj.direction = this.direction;
    for (i2 in oldDirection) {
      if (oldDirection[i2] === this.direction[i2]) {
        same[i2] = true;
      }
    }
    if (same.x && same.y && same.angle) {
      return obj;
    }
    if (!same.x || !same.y) {
      this.trigger("plain", obj);
    }
    if (!same.x) {
      this.trigger("plain:" + directionX, obj);
    }
    if (!same.y) {
      this.trigger("plain:" + directionY, obj);
    }
    if (!same.angle) {
      this.trigger("dir dir:" + direction, obj);
    }
  } else {
    this.resetDirection();
  }
  return obj;
};
function Collection2(manager, options2) {
  var self2 = this;
  self2.nipples = [];
  self2.idles = [];
  self2.actives = [];
  self2.ids = [];
  self2.pressureIntervals = {};
  self2.manager = manager;
  self2.id = Collection2.id;
  Collection2.id += 1;
  self2.defaults = {
    zone: document.body,
    multitouch: false,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    lockX: false,
    lockY: false,
    shape: "circle",
    dynamicPage: false,
    follow: false
  };
  self2.config(options2);
  if (self2.options.mode === "static" || self2.options.mode === "semi") {
    self2.options.multitouch = false;
  }
  if (!self2.options.multitouch) {
    self2.options.maxNumberOfNipples = 1;
  }
  const computedStyle = getComputedStyle(self2.options.zone.parentElement);
  if (computedStyle && computedStyle.display === "flex") {
    self2.parentIsFlex = true;
  }
  self2.updateBox();
  self2.prepareNipples();
  self2.bindings();
  self2.begin();
  return self2.nipples;
}
Collection2.prototype = new Super();
Collection2.constructor = Collection2;
Collection2.id = 0;
Collection2.prototype.prepareNipples = function() {
  var self2 = this;
  var nips = self2.nipples;
  nips.on = self2.on.bind(self2);
  nips.off = self2.off.bind(self2);
  nips.options = self2.options;
  nips.destroy = self2.destroy.bind(self2);
  nips.ids = self2.ids;
  nips.id = self2.id;
  nips.processOnMove = self2.processOnMove.bind(self2);
  nips.processOnEnd = self2.processOnEnd.bind(self2);
  nips.get = function(id) {
    if (id === void 0) {
      return nips[0];
    }
    for (var i2 = 0, max = nips.length; i2 < max; i2 += 1) {
      if (nips[i2].identifier === id) {
        return nips[i2];
      }
    }
    return false;
  };
};
Collection2.prototype.bindings = function() {
  var self2 = this;
  self2.bindEvt(self2.options.zone, "start");
  self2.options.zone.style.touchAction = "none";
  self2.options.zone.style.msTouchAction = "none";
};
Collection2.prototype.begin = function() {
  var self2 = this;
  var opts = self2.options;
  if (opts.mode === "static") {
    var nipple = self2.createNipple(
      opts.position,
      self2.manager.getIdentifier()
    );
    nipple.add();
    self2.idles.push(nipple);
  }
};
Collection2.prototype.createNipple = function(position, identifier) {
  var self2 = this;
  var scroll = self2.manager.scroll;
  var toPutOn = {};
  var opts = self2.options;
  var offset = {
    x: self2.parentIsFlex ? scroll.x : scroll.x + self2.box.left,
    y: self2.parentIsFlex ? scroll.y : scroll.y + self2.box.top
  };
  if (position.x && position.y) {
    toPutOn = {
      x: position.x - offset.x,
      y: position.y - offset.y
    };
  } else if (position.top || position.right || position.bottom || position.left) {
    var dumb = document.createElement("DIV");
    dumb.style.display = "hidden";
    dumb.style.top = position.top;
    dumb.style.right = position.right;
    dumb.style.bottom = position.bottom;
    dumb.style.left = position.left;
    dumb.style.position = "absolute";
    opts.zone.appendChild(dumb);
    var dumbBox = dumb.getBoundingClientRect();
    opts.zone.removeChild(dumb);
    toPutOn = position;
    position = {
      x: dumbBox.left + scroll.x,
      y: dumbBox.top + scroll.y
    };
  }
  var nipple = new Nipple(self2, {
    color: opts.color,
    size: opts.size,
    threshold: opts.threshold,
    fadeTime: opts.fadeTime,
    dataOnly: opts.dataOnly,
    restJoystick: opts.restJoystick,
    restOpacity: opts.restOpacity,
    mode: opts.mode,
    identifier,
    position,
    zone: opts.zone,
    frontPosition: {
      x: 0,
      y: 0
    },
    shape: opts.shape
  });
  if (!opts.dataOnly) {
    applyPosition(nipple.ui.el, toPutOn);
    applyPosition(nipple.ui.front, nipple.frontPosition);
  }
  self2.nipples.push(nipple);
  self2.trigger("added " + nipple.identifier + ":added", nipple);
  self2.manager.trigger("added " + nipple.identifier + ":added", nipple);
  self2.bindNipple(nipple);
  return nipple;
};
Collection2.prototype.updateBox = function() {
  var self2 = this;
  self2.box = self2.options.zone.getBoundingClientRect();
};
Collection2.prototype.bindNipple = function(nipple) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  nipple.on("destroyed", self2.onDestroyed.bind(self2));
  nipple.on("shown hidden rested dir plain", handler);
  nipple.on("dir:up dir:right dir:down dir:left", handler);
  nipple.on("plain:up plain:right plain:down plain:left", handler);
};
Collection2.prototype.pressureFn = function(touch, nipple, identifier) {
  var self2 = this;
  var previousPressure = 0;
  clearInterval(self2.pressureIntervals[identifier]);
  self2.pressureIntervals[identifier] = setInterval(function() {
    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;
    if (pressure !== previousPressure) {
      nipple.trigger("pressure", pressure);
      self2.trigger("pressure " + nipple.identifier + ":pressure", pressure);
      previousPressure = pressure;
    }
  }.bind(self2), 100);
};
Collection2.prototype.onstart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var origEvt = evt;
  evt = prepareEvent(evt);
  self2.updateBox();
  var process2 = function(touch) {
    if (self2.actives.length < opts.maxNumberOfNipples) {
      self2.processOnStart(touch);
    } else if (origEvt.type.match(/^touch/)) {
      Object.keys(self2.manager.ids).forEach(function(k4) {
        if (Object.values(origEvt.touches).findIndex(function(t2) {
          return t2.identifier === k4;
        }) < 0) {
          var e3 = [evt[0]];
          e3.identifier = k4;
          self2.processOnEnd(e3);
        }
      });
      if (self2.actives.length < opts.maxNumberOfNipples) {
        self2.processOnStart(touch);
      }
    }
  };
  map(evt, process2);
  self2.manager.bindDocument();
  return false;
};
Collection2.prototype.processOnStart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var indexInIdles;
  var identifier = self2.manager.getIdentifier(evt);
  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
  var position = {
    x: evt.pageX,
    y: evt.pageY
  };
  var nipple = self2.getOrCreate(identifier, position);
  if (nipple.identifier !== identifier) {
    self2.manager.removeIdentifier(nipple.identifier);
  }
  nipple.identifier = identifier;
  var process2 = function(nip) {
    nip.trigger("start", nip);
    self2.trigger("start " + nip.id + ":start", nip);
    nip.show();
    if (pressure > 0) {
      self2.pressureFn(evt, nip, nip.identifier);
    }
    self2.processOnMove(evt);
  };
  if ((indexInIdles = self2.idles.indexOf(nipple)) >= 0) {
    self2.idles.splice(indexInIdles, 1);
  }
  self2.actives.push(nipple);
  self2.ids.push(nipple.identifier);
  if (opts.mode !== "semi") {
    process2(nipple);
  } else {
    var distance$1 = distance(position, nipple.position);
    if (distance$1 <= opts.catchDistance) {
      process2(nipple);
    } else {
      nipple.destroy();
      self2.processOnStart(evt);
      return;
    }
  }
  return nipple;
};
Collection2.prototype.getOrCreate = function(identifier, position) {
  var self2 = this;
  var opts = self2.options;
  var nipple;
  if (/(semi|static)/.test(opts.mode)) {
    nipple = self2.idles[0];
    if (nipple) {
      self2.idles.splice(0, 1);
      return nipple;
    }
    if (opts.mode === "semi") {
      return self2.createNipple(position, identifier);
    }
    console.warn("Coudln't find the needed nipple.");
    return false;
  }
  nipple = self2.createNipple(position, identifier);
  return nipple;
};
Collection2.prototype.processOnMove = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var scroll = self2.manager.scroll;
  if (!isPressed(evt)) {
    this.processOnEnd(evt);
    return;
  }
  if (!nipple) {
    console.error("Found zombie joystick with ID " + identifier);
    self2.manager.removeIdentifier(identifier);
    return;
  }
  if (opts.dynamicPage) {
    var elBox = nipple.el.getBoundingClientRect();
    nipple.position = {
      x: scroll.x + elBox.left,
      y: scroll.y + elBox.top
    };
  }
  nipple.identifier = identifier;
  var size2 = nipple.options.size / 2;
  var pos = {
    x: evt.pageX,
    y: evt.pageY
  };
  if (opts.lockX) {
    pos.y = nipple.position.y;
  }
  if (opts.lockY) {
    pos.x = nipple.position.x;
  }
  var dist = distance(pos, nipple.position);
  var angle$1 = angle(pos, nipple.position);
  var rAngle = radians(angle$1);
  var force = dist / size2;
  var raw = {
    distance: dist,
    position: pos
  };
  var clamped_dist;
  var clamped_pos;
  if (nipple.options.shape === "circle") {
    clamped_dist = Math.min(dist, size2);
    clamped_pos = findCoord(nipple.position, clamped_dist, angle$1);
  } else {
    clamped_pos = clamp(pos, nipple.position, size2);
    clamped_dist = distance(clamped_pos, nipple.position);
  }
  if (opts.follow) {
    if (dist > size2) {
      let delta_x = pos.x - clamped_pos.x;
      let delta_y = pos.y - clamped_pos.y;
      nipple.position.x += delta_x;
      nipple.position.y += delta_y;
      nipple.el.style.top = nipple.position.y - (self2.box.top + scroll.y) + "px";
      nipple.el.style.left = nipple.position.x - (self2.box.left + scroll.x) + "px";
      dist = distance(pos, nipple.position);
    }
  } else {
    pos = clamped_pos;
    dist = clamped_dist;
  }
  var xPosition = pos.x - nipple.position.x;
  var yPosition = pos.y - nipple.position.y;
  nipple.frontPosition = {
    x: xPosition,
    y: yPosition
  };
  if (!opts.dataOnly) {
    nipple.ui.front.style.transform = "translate(" + xPosition + "px," + yPosition + "px)";
  }
  var toSend = {
    identifier: nipple.identifier,
    position: pos,
    force,
    pressure: evt.force || evt.pressure || evt.webkitForce || 0,
    distance: dist,
    angle: {
      radian: rAngle,
      degree: angle$1
    },
    vector: {
      x: xPosition / size2,
      y: -yPosition / size2
    },
    raw,
    instance: nipple,
    lockX: opts.lockX,
    lockY: opts.lockY
  };
  toSend = nipple.computeDirection(toSend);
  toSend.angle = {
    radian: radians(180 - angle$1),
    degree: 180 - angle$1
  };
  nipple.trigger("move", toSend);
  self2.trigger("move " + nipple.id + ":move", toSend);
};
Collection2.prototype.processOnEnd = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var removedIdentifier = self2.manager.removeIdentifier(nipple.identifier);
  if (!nipple) {
    return;
  }
  if (!opts.dataOnly) {
    nipple.hide(function() {
      if (opts.mode === "dynamic") {
        nipple.trigger("removed", nipple);
        self2.trigger("removed " + nipple.id + ":removed", nipple);
        self2.manager.trigger("removed " + nipple.id + ":removed", nipple);
        nipple.destroy();
      }
    });
  }
  clearInterval(self2.pressureIntervals[nipple.identifier]);
  nipple.resetDirection();
  nipple.trigger("end", nipple);
  self2.trigger("end " + nipple.id + ":end", nipple);
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (/(semi|static)/.test(opts.mode)) {
    self2.idles.push(nipple);
  } else if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  self2.manager.unbindDocument();
  if (/(semi|static)/.test(opts.mode)) {
    self2.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
  }
};
Collection2.prototype.onDestroyed = function(evt, nipple) {
  var self2 = this;
  if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (self2.idles.indexOf(nipple) >= 0) {
    self2.idles.splice(self2.idles.indexOf(nipple), 1);
  }
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  self2.manager.removeIdentifier(nipple.identifier);
  self2.manager.unbindDocument();
};
Collection2.prototype.destroy = function() {
  var self2 = this;
  self2.unbindEvt(self2.options.zone, "start");
  self2.nipples.forEach(function(nipple) {
    nipple.destroy();
  });
  for (var i2 in self2.pressureIntervals) {
    if (self2.pressureIntervals.hasOwnProperty(i2)) {
      clearInterval(self2.pressureIntervals[i2]);
    }
  }
  self2.trigger("destroyed", self2.nipples);
  self2.manager.unbindDocument();
  self2.off();
};
function Manager(options2) {
  var self2 = this;
  self2.ids = {};
  self2.index = 0;
  self2.collections = [];
  self2.scroll = getScroll();
  self2.config(options2);
  self2.prepareCollections();
  var resizeHandler = function() {
    var pos;
    self2.collections.forEach(function(collection) {
      collection.forEach(function(nipple) {
        pos = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: self2.scroll.x + pos.left,
          y: self2.scroll.y + pos.top
        };
      });
    });
  };
  bindEvt(window, "resize", function() {
    throttle(resizeHandler);
  });
  var scrollHandler = function() {
    self2.scroll = getScroll();
  };
  bindEvt(window, "scroll", function() {
    throttle(scrollHandler);
  });
  return self2.collections;
}
Manager.prototype = new Super();
Manager.constructor = Manager;
Manager.prototype.prepareCollections = function() {
  var self2 = this;
  self2.collections.create = self2.create.bind(self2);
  self2.collections.on = self2.on.bind(self2);
  self2.collections.off = self2.off.bind(self2);
  self2.collections.destroy = self2.destroy.bind(self2);
  self2.collections.get = function(id) {
    var nipple;
    self2.collections.every(function(collection) {
      nipple = collection.get(id);
      return nipple ? false : true;
    });
    return nipple;
  };
};
Manager.prototype.create = function(options2) {
  return this.createCollection(options2);
};
Manager.prototype.createCollection = function(options2) {
  var self2 = this;
  var collection = new Collection2(self2, options2);
  self2.bindCollection(collection);
  self2.collections.push(collection);
  return collection;
};
Manager.prototype.bindCollection = function(collection) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  collection.on("destroyed", self2.onDestroyed.bind(self2));
  collection.on("shown hidden rested dir plain", handler);
  collection.on("dir:up dir:right dir:down dir:left", handler);
  collection.on("plain:up plain:right plain:down plain:left", handler);
};
Manager.prototype.bindDocument = function() {
  var self2 = this;
  if (!self2.binded) {
    self2.bindEvt(document, "move").bindEvt(document, "end");
    self2.binded = true;
  }
};
Manager.prototype.unbindDocument = function(force) {
  var self2 = this;
  if (!Object.keys(self2.ids).length || force === true) {
    self2.unbindEvt(document, "move").unbindEvt(document, "end");
    self2.binded = false;
  }
};
Manager.prototype.getIdentifier = function(evt) {
  var id;
  if (!evt) {
    id = this.index;
  } else {
    id = evt.identifier === void 0 ? evt.pointerId : evt.identifier;
    if (id === void 0) {
      id = this.latest || 0;
    }
  }
  if (this.ids[id] === void 0) {
    this.ids[id] = this.index;
    this.index += 1;
  }
  this.latest = id;
  return this.ids[id];
};
Manager.prototype.removeIdentifier = function(identifier) {
  var removed = {};
  for (var id in this.ids) {
    if (this.ids[id] === identifier) {
      removed.id = id;
      removed.identifier = this.ids[id];
      delete this.ids[id];
      break;
    }
  }
  return removed;
};
Manager.prototype.onmove = function(evt) {
  var self2 = this;
  self2.onAny("move", evt);
  return false;
};
Manager.prototype.onend = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.oncancel = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.onAny = function(which, evt) {
  var self2 = this;
  var id;
  var processFn = "processOn" + which.charAt(0).toUpperCase() + which.slice(1);
  evt = prepareEvent(evt);
  var processColl = function(e3, id2, coll) {
    if (coll.ids.indexOf(id2) >= 0) {
      coll[processFn](e3);
      e3._found_ = true;
    }
  };
  var processEvt = function(e3) {
    id = self2.getIdentifier(e3);
    map(self2.collections, processColl.bind(null, e3, id));
    if (!e3._found_) {
      self2.removeIdentifier(id);
    }
  };
  map(evt, processEvt);
  return false;
};
Manager.prototype.destroy = function() {
  var self2 = this;
  self2.unbindDocument(true);
  self2.ids = {};
  self2.index = 0;
  self2.collections.forEach(function(collection) {
    collection.destroy();
  });
  self2.off();
};
Manager.prototype.onDestroyed = function(evt, coll) {
  var self2 = this;
  if (self2.collections.indexOf(coll) < 0) {
    return false;
  }
  self2.collections.splice(self2.collections.indexOf(coll), 1);
};
const factory = new Manager();
const nipplejs = {
  create: function(options2) {
    return factory.create(options2);
  },
  factory
};
const DIRECTIONS$1 = {
  [Direction.Left]: "left",
  [Direction.Right]: "right",
  [Direction.Up]: "up",
  [Direction.Down]: "down"
};
const DIRECTIONS_INVERSE = {
  left: Direction.Left,
  right: Direction.Right,
  up: Direction.Up,
  down: Direction.Down
};
const _sfc_main$h = {
  name: "rpg-controls",
  inject: ["rpgEngine"],
  mounted() {
    const manager = nipplejs.create({
      zone: this.$refs.dPad
    });
    let directions2 = {};
    let moving2 = false;
    manager.on("added", (evt, nipple) => {
      const keyup = (key) => {
        this.rpgEngine.controls.applyControl(key, false);
      };
      const end = () => {
        moving2 = false;
        for (let key in DIRECTIONS$1) {
          keyup(key);
        }
      };
      const move = () => {
        if (moving2) {
          for (let dir in directions2) {
            this.rpgEngine.controls.applyControl(DIRECTIONS_INVERSE[dir], true);
          }
        }
      };
      nipple.on("end", end);
      nipple.on("move", (evt2, data) => {
        if (data.direction) {
          const degree = data.angle.degree;
          const {
            x: x2,
            y: y2,
            angle: angle2
          } = data.direction;
          directions2 = {
            [angle2]: true
          };
          for (let i2 = 0; i2 < 4; i2++) {
            const corner = 90 * i2 + 45;
            if (degree < corner + 20 && degree > corner - 20) {
              directions2 = {
                [x2]: true,
                [y2]: true
              };
            }
          }
          for (let dir in DIRECTIONS$1) {
            const directionName = DIRECTIONS$1[dir];
            if (!directions2[directionName]) {
              keyup(dir);
            }
          }
          moving2 = true;
          move();
        }
      });
      setInterval(move, 400);
    });
  },
  methods: {
    openMenu() {
      this.rpgEngine.controls.applyControl(Control.Back);
    },
    action() {
      this.rpgEngine.controls.applyControl(Control.Action);
    }
  }
};
const main_vue_vue_type_style_index_0_scoped_b0ad1b2d_lang = "";
const _hoisted_1$b = { class: "controls" };
const _hoisted_2$8 = {
  class: "d-pad",
  ref: "dPad"
};
const _hoisted_3$5 = { class: "actions" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_propagate = resolveDirective("propagate");
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$b, [
    createBaseVNode("div", _hoisted_2$8, null, 512),
    createBaseVNode("div", _hoisted_3$5, [
      createBaseVNode("div", {
        class: "action",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.action && $options.action(...args))
      })
    ]),
    createBaseVNode("div", {
      class: "menu-access",
      onClick: _cache[1] || (_cache[1] = (...args) => $options.openMenu && $options.openMenu(...args))
    })
  ])), [
    [_directive_propagate]
  ]);
}
const ControlGui = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-b0ad1b2d"]]);
const sceneMap = {
  onAfterLoading() {
    RpgGui.display(PrebuiltGui.Controls);
  }
};
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
let RpgClientEngine$1 = class RpgClientEngine4 {
};
RpgClientEngine$1 = __decorateClass$4([
  RpgModule({
    gui: [
      ControlGui
    ],
    scenes: {
      map: sceneMap
    }
  })
], RpgClientEngine$1);
const _rpgjs_mobile_gui = {
  client: RpgClientEngine$1
};
const arrow_vue_vue_type_style_index_0_scoped_6e21b8b8_lang = "";
const _sfc_main$g = {
  props: {
    direction: {
      type: String,
      default: "down"
    },
    size: {
      type: Number,
      default: 0.5
    },
    center: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    style() {
      return {
        "border-width": `0 ${this.size}em`,
        "border-top": `${this.size}em solid white`
      };
    }
  }
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", {
    class: normalizeClass(["arrow", { [$props.direction]: true, center: $props.center }]),
    style: normalizeStyle($options.style)
  }, null, 6);
}
const Arrow = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-6e21b8b8"]]);
const window_vue_vue_type_style_index_0_lang = "";
const window_vue_vue_type_style_index_1_scoped_118d4441_lang = "";
const _sfc_main$f = {
  name: "rpg-window",
  props: ["width", "height", "message", "position", "fullWidth", "arrow"],
  data() {
    return {
      loading: false
    };
  },
  computed: {
    classPosition() {
      return {
        [this.position]: true
      };
    },
    css() {
      return {
        "full-width": this.fullWidth
      };
    }
  },
  mounted() {
    this.loading = true;
  },
  components: {
    Arrow
  }
};
const _hoisted_1$a = { key: 0 };
const _hoisted_2$7 = { key: 1 };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Arrow = resolveComponent("Arrow");
  return openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      $data.loading ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["window", $options.classPosition]),
        style: normalizeStyle({ height: $props.height })
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["window-content", $options.css]),
          style: normalizeStyle({ width: $props.width })
        }, [
          $props.arrow == "up" ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
            createVNode(_component_Arrow, {
              center: true,
              direction: "up"
            })
          ])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default", {}, void 0, true),
          $props.arrow == "down" ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
            createVNode(_component_Arrow, {
              center: true,
              direction: "down"
            })
          ])) : createCommentVNode("", true)
        ], 6)
      ], 6)) : createCommentVNode("", true)
    ]),
    _: 3
  });
}
const WindowUi = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-118d4441"]]);
const _sfc_main$e = {
  name: "rpg-choice",
  inject: ["rpgKeypress"],
  data() {
    return {
      selected: 0,
      scrollHeight: 0
    };
  },
  props: {
    choices: {
      type: Array,
      default: []
    },
    column: {
      type: Number,
      default: 1
    },
    align: {
      type: String,
      default: "left"
    },
    active: {
      type: Boolean,
      default: true
    }
  },
  mounted() {
    this.obsKeyPress = this.rpgKeypress.pipe(debounceTime(100)).subscribe(({
      control
    }) => {
      if (!this.active || !control)
        return;
      const name2 = control.actionName;
      if (this.column > 1) {
        if (name2 == Control.Left) {
          this.selected = Math.floor(this.selected - this.choices.length / this.column);
          this.moveCursor();
        } else if (name2 == Control.Right) {
          this.selected = Math.floor(this.choices.length / this.column + this.selected);
          this.moveCursor();
        }
      }
      if (name2 == Control.Down)
        this.moveCursor(1);
      else if (name2 == Control.Up)
        this.moveCursor(-1);
      else if (name2 == Control.Action)
        this.$emit("selected", this.selected);
      return false;
    });
  },
  methods: {
    moveCursor(move = 0) {
      if (this.choices.length == 0)
        return;
      let diff = 0;
      const checkInView = (container, element, partial) => {
        let cTop = container.scrollTop;
        let cBottom = cTop + container.clientHeight;
        let eTop = element.offsetTop;
        let eBottom = eTop + element.clientHeight + 20;
        let isTotal = eTop >= cTop && eBottom <= cBottom;
        let isPartial = partial && (eTop < cTop && eBottom > cTop || eBottom > cBottom && eTop < cBottom);
        diff = eBottom - cBottom;
        return isTotal || isPartial;
      };
      if (this.selected + move >= this.choices.length) {
        this.selected = 0;
      } else if (this.selected + move < 0) {
        this.selected = this.choices.length - 1;
      } else {
        this.selected = this.selected + move;
      }
      this.$emit("change", this.selected);
      const li = this.$refs[`li-${this.selected}`];
      const ul = this.$parent.$el;
      checkInView(ul, li, false);
      if (diff > 0) {
        this.scrollHeight = `-${diff}px`;
        this.$emit("canScroll", "up");
      } else {
        this.scrollHeight = 0;
        this.$emit("canScroll", null);
      }
      this.$nextTick(() => {
        const lastLi = this.$refs[`li-${this.choices.length - 1}`];
        const inView = checkInView(ul, lastLi, false);
        if (!inView)
          this.$emit("canScroll", "down");
      });
    },
    mouseOver(index2) {
      this.selected = index2;
      this.moveCursor();
    }
  },
  computed: {
    css() {
      return {
        "column-count": this.column > 1 ? this.column : void 0,
        "height": "100%",
        "margin-top": this.scrollHeight,
        "text-align": this.align
      };
    }
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
  },
  components: {
    Arrow
  }
};
const choice_vue_vue_type_style_index_0_scoped_36b53cc0_lang = "";
const _hoisted_1$9 = { class: "choice-container" };
const _hoisted_2$6 = ["onClick", "onMouseover"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    createBaseVNode("ul", {
      style: normalizeStyle($options.css),
      ref: "ul"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.choices, (choice, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2,
          class: normalizeClass({ active: $data.selected == index2 }),
          onClick: ($event) => _ctx.$emit("selected", index2),
          onMouseover: ($event) => $options.mouseOver(index2),
          ref_for: true,
          ref: `li-${index2}`
        }, [
          renderSlot(_ctx.$slots, "default", { choice }, () => [
            createBaseVNode("p", null, [
              createBaseVNode("span", null, toDisplayString(choice.text), 1)
            ])
          ], true)
        ], 42, _hoisted_2$6);
      }), 128))
    ], 4)
  ]);
}
const ChoiceUi = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-36b53cc0"]]);
const _sfc_main$d = {
  name: "rpg-dialog",
  inject: ["rpgEngine", "rpgKeypress", "rpgGuiClose", "rpgGui"],
  props: ["message", "choices", "position", "fullWidth", "autoClose", "typewriterEffect"],
  data() {
    return {
      msg: ""
    };
  },
  async mounted() {
    let interval;
    this.rpgEngine.controls.stopInputs();
    if (!this.isChoice && !this.autoClose) {
      this.obsKeyPress = this.rpgKeypress.subscribe(({
        control
      }) => {
        if (control && control.actionName == Control.Action) {
          this.close();
        }
      });
    }
    let index2 = 0;
    const typewriter = () => {
      if (index2 >= this.message.length) {
        clearInterval(interval);
      } else {
        this.msg = this.msg + this.message[index2];
        index2++;
      }
    };
    if (!this.typewriterEffect) {
      this.msg = this.message;
    } else {
      interval = setInterval(typewriter, 20);
    }
  },
  computed: {
    isChoice() {
      return this.choices && this.choices.length > 0;
    }
  },
  methods: {
    close(indexSelect) {
      this.rpgGuiClose("rpg-dialog", indexSelect);
      this.rpgEngine.controls.listenInputs();
    }
  },
  unmounted() {
    if (this.obsKeyPress)
      this.obsKeyPress.unsubscribe();
  },
  components: {
    Window: WindowUi,
    Choices: ChoiceUi,
    Arrow
  }
};
const dialog_vue_vue_type_style_index_0_scoped_0ee896f9_lang = "";
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_choices = resolveComponent("choices");
  const _component_Arrow = resolveComponent("Arrow");
  const _component_window = resolveComponent("window");
  return openBlock(), createBlock(_component_window, {
    position: $props.position,
    fullWidth: $props.fullWidth,
    class: "dialog"
  }, {
    default: withCtx(() => [
      createBaseVNode("p", null, toDisplayString($data.msg), 1),
      $options.isChoice ? (openBlock(), createBlock(_component_choices, {
        key: 0,
        choices: $props.choices,
        onSelected: $options.close
      }, null, 8, ["choices", "onSelected"])) : !$props.autoClose ? (openBlock(), createBlock(_component_Arrow, {
        key: 1,
        direction: "down",
        center: true
      })) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["position", "fullWidth"]);
}
const DialogUi = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-0ee896f9"]]);
const bar_vue_vue_type_style_index_0_scoped_45d00ca4_lang = "";
const _sfc_main$c = {
  props: ["nb", "max", "color", "name"],
  computed: {
    percent() {
      return this.nb / this.max * 100;
    }
  }
};
const _hoisted_1$8 = { class: "bar" };
const _hoisted_2$5 = { class: "bar-info space-between" };
const _hoisted_3$4 = { class: "param-name" };
const _hoisted_4$2 = { class: "bar-full" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    createBaseVNode("div", _hoisted_2$5, [
      createBaseVNode("span", _hoisted_3$4, toDisplayString($props.name), 1),
      createBaseVNode("span", null, toDisplayString($props.nb) + " / " + toDisplayString($props.max), 1)
    ]),
    createBaseVNode("div", _hoisted_4$2, [
      createBaseVNode("div", {
        class: normalizeClass(["bar-content", { [$props.color]: true }]),
        style: normalizeStyle({ width: `${$options.percent}%` })
      }, null, 6)
    ])
  ]);
}
const Bar = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-45d00ca4"]]);
const hero_vue_vue_type_style_index_0_scoped_45f12dbd_lang = "";
const _sfc_main$b = {
  props: ["face"],
  inject: ["rpgCurrentPlayer"],
  data() {
    return {
      name: "",
      hp: 0,
      sp: 0,
      maxHp: 0,
      maxSp: 0,
      expForNextlevel: 0,
      exp: 0,
      level: 0,
      _class: {}
    };
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      this.name = object.name;
      this.hp = object.hp;
      this.sp = object.sp;
      this.maxHp = object.param.maxHp;
      this.maxSp = object.param.maxSp;
      this.expForNextlevel = object.expForNextlevel;
      this.exp = object.exp;
      this.level = object.level;
    });
  },
  computed: {
    image() {
      return {
        backgroundImage: `url(${this.face})`
      };
    }
  },
  unmounted() {
    this.obsCurrentPlayer.unsubscribe();
  },
  components: {
    Bar
  }
};
const _withScopeId$1 = (n2) => (pushScopeId("data-v-45f12dbd"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7 = { class: "hero" };
const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "face-column" }, [
  /* @__PURE__ */ createBaseVNode("div")
], -1));
const _hoisted_3$3 = { class: "name-column" };
const _hoisted_4$1 = { class: "space-between" };
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "param-name" }, "Level", -1));
const _hoisted_6$1 = { class: "bars-column" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = resolveComponent("bar");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    _hoisted_2$4,
    createBaseVNode("div", _hoisted_3$3, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, toDisplayString($data.name), 1),
        createBaseVNode("li", _hoisted_4$1, [
          _hoisted_5$1,
          createTextVNode(),
          createBaseVNode("span", null, toDisplayString($data.level), 1)
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.exp,
            max: $data.expForNextlevel,
            name: "EXP",
            color: "gray"
          }, null, 8, ["nb", "max"])
        ])
      ])
    ]),
    createBaseVNode("div", _hoisted_6$1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, toDisplayString($data._class.name), 1),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.hp,
            max: $data.maxHp,
            name: "HP",
            color: "orange"
          }, null, 8, ["nb", "max"])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_bar, {
            nb: $data.sp,
            max: $data.maxSp,
            name: "SP",
            color: "blue"
          }, null, 8, ["nb", "max"])
        ])
      ])
    ])
  ]);
}
const Hero = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-45f12dbd"]]);
const main_vue_vue_type_style_index_0_lang = "";
const main_vue_vue_type_style_index_1_scoped_506e8ae0_lang = "";
const _sfc_main$a = {
  props: {
    goldName: {
      type: String,
      default: "Gold"
    }
  },
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgEngine", "rpgStage", "rpgGuiClose", "rpgGui"],
  data() {
    const menu = [
      {
        text: "Items",
        value: "item",
        layout: "ItemsLayout"
      }
      /*  {
          text: 'Skills',
          value: 'skill'
      },  {
          text: 'Equipment',
          value: 'equipment',
          layout: 'EquipmentLayout'
      }, 
      {
          text: 'Status',
          value: 'status',
          layout: 'StatusLayout'
      } */
    ];
    if (this.rpgGui.exists("rpg-save")) {
      menu.push({
        text: "Save",
        value: "save",
        layout: "SaveLayout"
      });
    }
    return {
      player: {},
      active: true,
      gold: 0,
      menu
    };
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      this.gold = object.gold;
    });
    this.obsKeyPress = this.rpgKeypress.subscribe(({ control }) => {
      if (!this.active || !control)
        return;
      if (control.actionName == "back") {
        this.rpgStage.filters = [];
        if (this.rpgGui.exists("rpg-controls"))
          this.rpgGui.display("rpg-controls");
        this.rpgGuiClose("rpg-main-menu");
        this.rpgEngine.controls.listenInputs();
      }
    });
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  },
  methods: {
    selectMenu(index2) {
      this.$emit("changeLayout", this.menu[index2].layout);
    }
  },
  components: {
    Hero
  }
};
const _hoisted_1$6 = { class: "menu-row" };
const _hoisted_2$3 = { class: "menu-left" };
const _hoisted_3$2 = { class: "menu-right" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_Hero = resolveComponent("Hero");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$3, [
      createVNode(_component_rpg_window, {
        fullWidth: true,
        class: "menu-choice"
      }, {
        default: withCtx(() => [
          createVNode(_component_rpg_choice, {
            choices: $data.menu,
            onSelected: $options.selectMenu,
            ref: "menu"
          }, null, 8, ["choices", "onSelected"])
        ]),
        _: 1
      }),
      createVNode(_component_rpg_window, {
        fullWidth: true,
        class: "gold"
      }, {
        default: withCtx(() => [
          createBaseVNode("p", null, toDisplayString($data.gold) + " " + toDisplayString($props.goldName), 1)
        ]),
        _: 1
      })
    ]),
    createBaseVNode("div", _hoisted_3$2, [
      createVNode(_component_rpg_window, {
        fullWidth: true,
        height: "100%"
      }, {
        default: withCtx(() => [
          createVNode(_component_Hero, { class: "hero-face" })
        ]),
        _: 1
      })
    ])
  ]);
}
const MainLayout = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-506e8ae0"]]);
const icon_vue_vue_type_style_index_0_scoped_c3768ae4_lang = "";
const _sfc_main$9 = {
  props: ["name"]
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", {
    class: normalizeClass($props.name)
  }, null, 2);
}
const Icon = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-c3768ae4"]]);
const _sfc_main$8 = {
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgSocket"],
  data() {
    return {
      description: "",
      items: [],
      arrow: null
    };
  },
  computed: {
    mapItems() {
      return this.items.filter((it2) => it2).map((it2) => ({
        text: it2.item.name,
        nb: it2.nb,
        consumable: it2.item.consumable
      }));
    }
  },
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({
      object
    }) => {
      this.items = Object.values(object.items || []);
    });
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      if (control.actionName == Control.Back) {
        this.$emit("changeLayout", "MainLayout");
      }
    });
    this.selected(0);
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  },
  methods: {
    selected(index2) {
      if (!this.items[index2])
        return;
      this.description = this.items[index2].item.description;
    },
    choiceItem(index2) {
      if (!this.items[index2])
        return;
      const {
        id,
        consumable
      } = this.items[index2].item;
      if (!consumable)
        return;
      this.rpgSocket().emit("gui.interaction", {
        guiId: "rpg-main-menu",
        name: "useItem",
        data: id
      });
    }
  },
  components: {
    Icon
  }
};
const item_vue_vue_type_style_index_0_scoped_bc1f995f_lang = "";
const _hoisted_1$5 = { class: "item-menu" };
const _hoisted_2$2 = { class: "row" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%",
      arrow: $data.arrow
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_2$2, [
          createVNode(_component_rpg_choice, {
            choices: $options.mapItems,
            column: 1,
            onChange: $options.selected,
            onSelected: $options.choiceItem,
            ref: "choice",
            onCanScroll: _cache[0] || (_cache[0] = ($event) => $data.arrow = $event)
          }, {
            default: withCtx(({ choice }) => [
              createBaseVNode("p", {
                class: normalizeClass(["space-between item", { "not-consumable": !choice.consumable }])
              }, [
                createBaseVNode("span", null, toDisplayString(choice.text), 1),
                createBaseVNode("span", null, toDisplayString(choice.nb), 1)
              ], 2)
            ]),
            _: 1
          }, 8, ["choices", "onChange", "onSelected"])
        ])
      ]),
      _: 1
    }, 8, ["arrow"]),
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "20%"
    }, {
      default: withCtx(() => [
        createBaseVNode("p", null, toDisplayString($data.description), 1)
      ]),
      _: 1
    })
  ]);
}
const ItemsLayout = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-bc1f995f"]]);
const _sfc_main$7 = {
  components: {
    Bar
  }
};
const _hoisted_1$4 = { class: "status-menu" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Bar = resolveComponent("Bar");
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%"
    }, {
      default: withCtx(() => [
        createVNode(_component_Bar, {
          nb: 6500,
          max: 9999,
          name: "MaxHP"
        })
      ]),
      _: 1
    })
  ]);
}
const StatusLayout = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = {
  inject: ["rpgCurrentPlayer"],
  mounted() {
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({ object }) => {
      console.log(object);
    });
  }
};
const _hoisted_1$3 = { class: "equipment-menu" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_window = resolveComponent("rpg-window");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "80%"
    })
  ]);
}
const EquipmentLayout = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _sfc_main$5 = {
  inject: ["rpgKeypress"],
  mounted() {
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      if (control.actionName == Control.Back) {
        this.back();
      }
    });
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
  },
  methods: {
    back() {
      this.$emit("changeLayout", "MainLayout");
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_save = resolveComponent("rpg-save");
  return openBlock(), createBlock(_component_rpg_save, { onSaved: $options.back }, null, 8, ["onSaved"]);
}
const SaveLayout = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const back_vue_vue_type_style_index_0_scoped_a7b6b651_lang = "";
const _sfc_main$4 = {
  inject: ["rpgEngine"],
  methods: {
    back() {
      this.rpgEngine.controls.applyControl("back");
    }
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "back",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.back && $options.back(...args))
  });
}
const BackButton = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-a7b6b651"]]);
const main_vue_vue_type_style_index_0_scoped_98ee6de6_lang = "";
const _sfc_main$3 = {
  name: "rpg-main-menu",
  inject: ["rpgEngine", "rpgStage", "rpgGui"],
  data() {
    return {
      layout: "MainLayout"
    };
  },
  mounted() {
    if (this.rpgGui.exists("rpg-controls"))
      this.rpgGui.hide("rpg-controls");
    this.rpgEngine.controls.stopInputs();
    const blur = new this.rpgEngine.PIXI.BlurFilter();
    this.rpgStage.filters = [blur];
  },
  methods: {
    change(name2) {
      this.layout = name2;
    }
  },
  components: {
    MainLayout,
    ItemsLayout,
    StatusLayout,
    BackButton,
    EquipmentLayout,
    SaveLayout
  }
};
const _hoisted_1$2 = { class: "menu-main" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BackButton = resolveComponent("BackButton");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    (openBlock(), createBlock(resolveDynamicComponent($data.layout), {
      onChangeLayout: $options.change,
      ref: "layout"
    }, null, 40, ["onChangeLayout"])),
    createVNode(_component_BackButton)
  ]);
}
const MenuUi = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-98ee6de6"]]);
const _sfc_main$2 = {
  name: "rpg-shop",
  inject: ["rpgCurrentPlayer", "rpgKeypress", "rpgGuiClose", "rpgSocket", "rpgEngine", "rpgGui"],
  props: ["items"],
  data() {
    return {
      player: {},
      inventory: [],
      menuActive: true,
      menu: [{
        text: "Buy",
        value: "buy"
      }, {
        text: "Sell",
        value: "sell"
      }, {
        text: "Cancel",
        value: "cancel"
      }],
      currentItem: {},
      mode: "",
      goldName: "Gold",
      step: 0,
      quantity: 1,
      indexSelected: 0,
      doAction: false
    };
  },
  mounted() {
    if (this.rpgGui.exists("rpg-controls"))
      this.rpgGui.hide("rpg-controls");
    this.rpgEngine.controls.stopInputs();
    this.obsCurrentPlayer = this.rpgCurrentPlayer.subscribe(({
      object
    }) => {
      this.player = object;
      this.inventory = Object.values(this.player.items).filter((item) => item);
      if (this.doAction) {
        this.step = 0;
        this.quantity = 1;
        this.doAction = false;
      }
      this.selected(this.indexSelected);
    });
    const interactionBuy = (name2) => {
      if (name2 == Control.Back) {
        this.step = 0;
      } else if (name2 == Control.Up) {
        const nextPrice = this.currentItem.price * (this.quantity + 1);
        if (nextPrice > this.player.gold) {
          return false;
        }
        this.quantity += 1;
      } else if (name2 == Control.Down) {
        if (this.quantity - 1 == 0) {
          return false;
        }
        this.quantity -= 1;
      } else if (name2 == Control.Action) {
        this.doAction = true;
        this.rpgSocket().emit("gui.interaction", {
          guiId: "rpg-shop",
          name: "buyItem",
          data: {
            id: this.currentItem.id,
            nb: this.quantity
          }
        });
      }
    };
    const interactionSell = (name2) => {
      if (name2 == Control.Back) {
        this.step = 0;
      } else if (name2 == Control.Up) {
        if (this.quantity + 1 > this.currentItem.nb) {
          return false;
        }
        this.quantity += 1;
      } else if (name2 == Control.Down) {
        if (this.quantity - 1 == 0) {
          return false;
        }
        this.quantity -= 1;
      } else if (name2 == Control.Action) {
        this.doAction = true;
        this.rpgSocket().emit("gui.interaction", {
          guiId: "rpg-shop",
          name: "sellItem",
          data: {
            id: this.currentItem.id,
            nb: this.quantity
          }
        });
      }
    };
    this.obsKeyPress = this.rpgKeypress.subscribe(({
      control
    }) => {
      if (!control)
        return;
      const name2 = control.actionName;
      if (!this.mode) {
        if (name2 == Control.Back) {
          this.close();
        }
      } else if (this.mode) {
        if (this.step == 1) {
          if (this.mode == "buy")
            interactionBuy(name2);
          if (this.mode == "sell")
            interactionSell(name2);
        } else {
          if (name2 == Control.Back) {
            this.mode = "";
            this.description = "";
            this.menuActive = true;
          }
        }
      }
    });
  },
  computed: {
    buyerItems() {
      return this.items.map((item) => {
        const playerItem = this.playerItems.find((playerItem2) => playerItem2.id == item.id) || {
          nb: 0
        };
        return {
          ...item,
          nb: playerItem.nb
        };
      });
    },
    listItems() {
      return this.mode == "buy" ? this.buyerItems : this.playerItems;
    },
    totalPrice() {
      let nb = this.currentItem.price * this.quantity;
      if (this.mode == "sell") {
        return Math.floor(nb / 2);
      }
      return nb;
    },
    playerItems() {
      return this.inventory.map(({
        item,
        nb
      }) => ({
        ...item,
        nb
      }));
    }
  },
  methods: {
    selected(index2) {
      if (!this.listItems[index2]) {
        this.currentItem = {};
        this.indexSelected = 0;
        if (this.listItems.length == 0)
          this.mode = "";
        return;
      }
      this.currentItem = this.listItems[index2];
      this.indexSelected = index2;
    },
    changeMenu(index2) {
      const mode = this.menu[index2].value;
      if (mode == "cancel") {
        this.close();
        return;
      }
      this.menuActive = false;
      this.mode = mode;
      this.selected(0);
    },
    choiceItem(index2) {
      const item = this.listItems[index2];
      if (item.price > this.player.gold)
        return;
      this.step = 1;
    },
    price(nb) {
      if (this.mode == "sell") {
        return Math.floor(nb / 2);
      } else {
        return nb;
      }
    },
    close() {
      this.rpgGuiClose();
      this.rpgEngine.controls.listenInputs();
      if (this.rpgGui.exists("rpg-controls"))
        this.rpgGui.display("rpg-controls");
    }
  },
  components: {
    BackButton
  },
  unmounted() {
    this.obsKeyPress.unsubscribe();
    this.obsCurrentPlayer.unsubscribe();
  }
};
const main_vue_vue_type_style_index_0_scoped_ef1d8785_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-ef1d8785"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1 = { class: "row" };
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
const _hoisted_3$1 = {
  key: 0,
  class: "shop-content"
};
const _hoisted_4 = { key: 1 };
const _hoisted_5 = { class: "space-between" };
const _hoisted_6 = { class: "cursor" };
const _hoisted_7 = { class: "space-between" };
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, null, -1));
const _hoisted_9 = { class: "total" };
const _hoisted_10 = {
  key: 0,
  class: "shop-info"
};
const _hoisted_11 = { class: "space-between" };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "Possession", -1));
const _hoisted_13 = {
  key: 1,
  class: "bottom"
};
const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_choice = resolveComponent("rpg-choice");
  const _component_rpg_window = resolveComponent("rpg-window");
  const _component_BackButton = resolveComponent("BackButton");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_rpg_window, {
      fullWidth: true,
      height: "100%",
      class: "shop-menu"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_1$1, [
          createVNode(_component_rpg_choice, {
            choices: $data.menu,
            column: 3,
            onSelected: $options.changeMenu,
            align: "center",
            active: $data.menuActive
          }, null, 8, ["choices", "onSelected", "active"]),
          createBaseVNode("div", null, [
            createBaseVNode("p", null, toDisplayString($data.player.gold) + " " + toDisplayString($data.goldName), 1)
          ])
        ]),
        _hoisted_2$1,
        $data.mode ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
          createBaseVNode("div", {
            class: normalizeClass({ "item-quantity": $data.step == 1 })
          }, [
            $data.step == 0 ? (openBlock(), createBlock(_component_rpg_choice, {
              key: 0,
              choices: $options.listItems,
              column: 1,
              onChange: $options.selected,
              onSelected: $options.choiceItem,
              ref: "list"
            }, {
              default: withCtx(({ choice }) => [
                createBaseVNode("p", {
                  class: normalizeClass(["space-between item", { "can-not-buy": choice.price > $data.player.gold }])
                }, [
                  createBaseVNode("span", null, toDisplayString(choice.name), 1),
                  createBaseVNode("span", null, toDisplayString($options.price(choice.price)), 1)
                ], 2)
              ]),
              _: 1
            }, 8, ["choices", "onChange", "onSelected"])) : (openBlock(), createElementBlock("div", _hoisted_4, [
              createBaseVNode("p", _hoisted_5, [
                createBaseVNode("span", null, toDisplayString($data.currentItem.name), 1),
                createBaseVNode("span", _hoisted_6, [
                  createBaseVNode("span", null, "x " + toDisplayString($data.quantity), 1)
                ])
              ]),
              createBaseVNode("p", _hoisted_7, [
                _hoisted_8,
                createBaseVNode("span", _hoisted_9, toDisplayString($options.totalPrice) + " " + toDisplayString($data.goldName), 1)
              ])
            ]))
          ], 2),
          $data.currentItem.name ? (openBlock(), createElementBlock("div", _hoisted_10, [
            createBaseVNode("p", _hoisted_11, [
              _hoisted_12,
              createBaseVNode("span", null, toDisplayString($data.currentItem.nb), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        $data.mode ? (openBlock(), createElementBlock("div", _hoisted_13, [
          _hoisted_14,
          createBaseVNode("p", null, toDisplayString($data.currentItem.description), 1)
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }),
    createVNode(_component_BackButton)
  ], 64);
}
const ShopUi = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-ef1d8785"]]);
const _sfc_main$1 = {
  name: "rpg-disconnect",
  inject: ["rpgStage", "rpgEngine"],
  mounted() {
    const blur = new this.rpgEngine.PIXI.BlurFilter();
    this.rpgStage.filters = [blur];
  },
  unmounted() {
    this.rpgStage.filters = [];
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rpg_dialog = resolveComponent("rpg-dialog");
  return openBlock(), createBlock(_component_rpg_dialog, {
    message: "Oops, you are disconnected. Please wait!",
    position: "middle",
    autoClose: true
  });
}
const DisconnectUi = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const alert_vue_vue_type_style_index_0_lang = "";
const guiName = "rpg-notification";
const _sfc_main = {
  props: {
    icon: {
      defaut: ""
    },
    sound: {
      defaut: ""
    },
    message: {
      default: ""
    },
    time: {
      default: 2e3
    },
    position: {
      default: "bottom"
    },
    type: {
      default: ""
    }
  },
  name: guiName,
  inject: ["rpgGui", "rpgResource", "rpgSound", "rpgEngine"],
  data() {
    return {
      show: false
    };
  },
  computed: {
    image() {
      const resourceImage = this.rpgResource.spritesheets.get(this.icon);
      if (!resourceImage) {
        return this.icon;
      }
      return resourceImage.image;
    }
  },
  mounted() {
    setTimeout(() => {
      this.show = true;
      const globalConfig = this.rpgEngine.globalConfig.notification;
      const globalSound = globalConfig && globalConfig.sound;
      const sound = this.sound || globalSound || (this.type == "error" ? "error" : "alert");
      if (sound && globalSound !== null) {
        this.rpgSound.get(sound).play();
      }
    }, 10);
    setTimeout(() => {
      this.show = false;
      setTimeout(() => {
        this.rpgGui.hide(guiName);
      }, 500);
    }, this.time);
  }
};
const _hoisted_1 = {
  key: 0,
  class: "icon"
};
const _hoisted_2 = ["src"];
const _hoisted_3 = { class: "msg" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["alert-panel", $props.position])
  }, [
    createBaseVNode("div", {
      class: normalizeClass(["alert", { show: $data.show, [$props.position]: true, [$props.type]: true }])
    }, [
      $options.image ? (openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("img", { src: $options.image }, null, 8, _hoisted_2)
      ])) : createCommentVNode("", true),
      createBaseVNode("span", _hoisted_3, toDisplayString($props.message), 1)
    ], 2)
  ], 2);
}
const NotificationUi = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const vitePluginRequire_1743700425497_64379561 = "/assets/error_002-76810ec3.ogg";
const vitePluginRequire_1743700425496_40847553 = "/assets/confirmation_002-33b17a9a.ogg";
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let GuiSounds = class {
};
GuiSounds = __decorateClass$3([Sound$1({
  sounds: {
    alert: vitePluginRequire_1743700425496_40847553,
    error: vitePluginRequire_1743700425497_64379561
  }
})], GuiSounds);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let RpgClientEngine5 = class {
};
RpgClientEngine5 = __decorateClass$2([
  RpgModule({
    gui: [
      DialogUi,
      MenuUi,
      WindowUi,
      ChoiceUi,
      DisconnectUi,
      ShopUi,
      NotificationUi
    ],
    sounds: [
      GuiSounds
    ]
  })
], RpgClientEngine5);
const _rpgjs_default_gui = {
  client: RpgClientEngine5
};
var a = { events: {}, publish: function a2(b3, c3) {
  if (this.events.hasOwnProperty(b3))
    this.events[b3].forEach(function(a8) {
      return a8(c3);
    });
}, subscribe: function a3(b3, c3) {
  if (!this.events.hasOwnProperty(b3))
    this.events[b3] = [];
  this.events[b3].push(c3);
  return { unsubscribe: function() {
    var a8 = this.events[b3].indexOf(c3);
    if (-1 !== a8)
      this.events[b3].splice(a8, 1);
  }.bind(this) };
} };
var a1 = { CONNECT: { NATIVE: "gamepadconnected", ALIAS: "connect" }, DISCONNECT: { NATIVE: "gamepaddisconnected", ALIAS: "disconnect" }, BUTTON_PRESS: { NATIVE: null, ALIAS: "button_press" }, BUTTON_RELEASE: { NATIVE: null, ALIAS: "button_release" }, AXIS_MOVEMENT: { NATIVE: null, ALIAS: "axis_move" } };
var b = { LEFT: { NAME: "left_stick", AXES: { X: 0, Y: 1 } }, RIGHT: { NAME: "right_stick", AXES: { X: 2, Y: 3 } } };
var c = { LEFT: "left", RIGHT: "right", TOP: "top", BOTTOM: "bottom" };
var d = { button_0: 0, button_1: 1, button_2: 2, button_3: 3, button_4: 4, button_5: 5, button_6: 6, button_7: 7, button_8: 8, button_9: 9, button_10: 10, button_11: 11, button_12: 12, button_13: 13, button_14: 14, button_15: 15, button_16: 16, button_17: 17 };
var e = 0.8;
var a22 = function(a8) {
  if (console.warn && "function" == typeof console.warn)
    console.warn(a8);
  else
    console.log(a8);
};
var b1 = function(a8, b3) {
  var c3 = [];
  Object.keys(b3).forEach(function(d2) {
    if (b3[d2] === a8)
      c3.push(d2);
    else if (Array.isArray(b3[d2]) && -1 !== b3[d2].indexOf(a8))
      c3.push(d2);
  });
  return c3;
};
var c1 = function(a8) {
  return !!a8 && !!a8.type && !!a8.playEffect && "function" == typeof a8.playEffect || false;
};
var d1 = function() {
  return !!window.navigator.getGamepads && "function" == typeof window.navigator.getGamepads || false;
};
var f2 = { loopStarted: false, instances: {}, buttonEvents: { joypad: [] }, settings: { axisMovementThreshold: e }, remove: function a4(b3) {
  return delete this.instances[b3];
}, on: function c2(d2, e3) {
  switch (d2) {
    case a1.CONNECT.ALIAS:
      return a.subscribe(a1.CONNECT.ALIAS, e3);
    case a1.DISCONNECT.ALIAS:
      return a.subscribe(a1.DISCONNECT.ALIAS, e3);
    case a1.BUTTON_PRESS.ALIAS:
      return a.subscribe(a1.BUTTON_PRESS.ALIAS, e3);
    case a1.BUTTON_RELEASE.ALIAS:
      return a.subscribe(a1.BUTTON_RELEASE.ALIAS, e3);
    case a1.AXIS_MOVEMENT.ALIAS:
      return a.subscribe(a1.AXIS_MOVEMENT.ALIAS, e3);
  }
}, vibrate: function a5(b3, c3) {
  var f3 = b3.vibrationActuator;
  var g2 = c3 || this.settings.vibration;
  if (c1(f3)) {
    var h2 = f3.type;
    return b3.vibrationActuator.playEffect(h2, g2);
  }
  a22("No vibration actuator interface found - https://developer.mozilla.org/en-US/docs/Web/API/GamepadHapticActuator");
}, set: function a6(b3) {
  var c3 = b3.axisMovementThreshold, d2 = b3.vibration, e3 = b3.customButtonMapping;
  var f3 = parseFloat(c3);
  if (!isNaN(f3))
    this.settings.axisMovementThreshold = f3;
  this.settings.vibration = d2;
  this.settings.customButtonMapping = e3;
}, trigger: function b2(c3, d2) {
  return a.publish(c3, d2);
} };
var j = function(a8) {
  a8.buttons.forEach(function(c3, d12) {
    var e3 = f2.settings.customButtonMapping;
    var f1 = e3 || d;
    var i2 = b1(d12, f1);
    var j2 = f2.buttonEvents;
    if (i2 && i2.length)
      i2.forEach(function(b3) {
        if (c3.pressed) {
          if (!j2.joypad[a8.index][b3])
            j2.joypad[a8.index][b3] = { pressed: true, hold: false, released: false };
          j2.joypad[a8.index][b3].button = c3;
          j2.joypad[a8.index][b3].index = d12;
          j2.joypad[a8.index][b3].gamepad = a8;
        } else if (!c3.pressed && j2.joypad[a8.index][b3]) {
          j2.joypad[a8.index][b3].released = true;
          j2.joypad[a8.index][b3].hold = false;
        }
      });
  });
};
var k3 = function(a8) {
  var c12 = function(a9) {
    return new CustomEvent(a1.AXIS_MOVEMENT.ALIAS, { detail: a9 });
  };
  var g2 = f2.settings.axisMovementThreshold;
  var h2 = a8.axes;
  var i2 = h2.length;
  var j2 = i2 / 2;
  h2.forEach(function(b12, d2) {
    if (Math.abs(b12) > g2) {
      var h3 = null;
      var i3 = null;
      var k4 = b12;
      h3 = d2 < j2 ? b.LEFT.NAME : b.RIGHT.NAME;
      if (d2 === b.LEFT.AXES.X || d2 === b.RIGHT.AXES.X)
        i3 = b12 < 0 ? c.LEFT : c.RIGHT;
      if (d2 === b.LEFT.AXES.Y || d2 === b.RIGHT.AXES.Y)
        i3 = b12 < 0 ? c.TOP : c.BOTTOM;
      var l2 = { gamepad: a8, totalSticks: j2, stickMoved: h3, directionOfMovement: i3, axisMovementValue: k4, axis: d2 };
      return window.dispatchEvent(c12(l2));
    }
  });
};
var m = function(a8, b3) {
  if (b3[a8].pressed) {
    l(a1.BUTTON_PRESS.ALIAS, b3, a8);
    b3[a8].pressed = false;
    b3[a8].hold = true;
    b3[a8].last_event = a1.BUTTON_PRESS.ALIAS;
  } else if (b3[a8].hold)
    ;
  else if (b3[a8].released && b3[a8].last_event === a1.BUTTON_PRESS.ALIAS) {
    l(a1.BUTTON_RELEASE.ALIAS, b3, a8);
    delete b3[a8];
  }
};
var e1 = { id: null, start: function e2() {
  var f1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
  var g2 = f2.buttonEvents;
  var h2 = window.navigator.getGamepads();
  h2 = Array.prototype.slice.call(h2);
  h2.forEach(function(d2, e3) {
    if (d2) {
      if (!g2.joypad[e3])
        g2.joypad[e3] = {};
      f2.instances[e3] = d2;
      j(d2);
      k3(d2);
    }
  });
  g2.joypad.forEach(function(a8) {
    if (a8)
      Object.keys(a8).forEach(function(b3) {
        m(b3, a8);
      });
  });
  this.id = f1(this.start.bind(this));
}, stop: function a7(b3) {
  var c3 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
  return c3(b3);
} };
var i = function() {
  window.addEventListener(a1.CONNECT.NATIVE, function(e3) {
    a.publish(a1.CONNECT.ALIAS, e3);
    if (!f2.loopStarted) {
      f2.loopStarted = true;
      return e1.start();
    }
  });
  window.addEventListener(a1.DISCONNECT.NATIVE, function(e3) {
    a.publish(a1.DISCONNECT.ALIAS, e3);
    f2.remove(e3.gamepad.index);
    f2.buttonEvents.joypad[e3.gamepad.index] = null;
    if (!Object.keys(f2.instances).length) {
      f2.loopStarted = false;
      return e1.stop(e1.id);
    }
  });
  window.addEventListener(a1.BUTTON_PRESS.ALIAS, function(b3) {
    return a.publish(a1.BUTTON_PRESS.ALIAS, b3);
  });
  window.addEventListener(a1.BUTTON_RELEASE.ALIAS, function(b3) {
    return a.publish(a1.BUTTON_RELEASE.ALIAS, b3);
  });
  window.addEventListener(a1.AXIS_MOVEMENT.ALIAS, function(b3) {
    return a.publish(a1.AXIS_MOVEMENT.ALIAS, b3);
  });
};
var l = function(a8, b3, c3) {
  var d2 = function(b4) {
    return new CustomEvent(a8, { detail: b4 });
  };
  var e3 = b3[c3], f3 = e3.index, g2 = e3.gamepad;
  var h2 = { buttonName: c3, button: b3[c3].button, index: f3, gamepad: g2 };
  window.dispatchEvent(d2(h2));
};
i();
if (d1())
  window.joypad = f2;
else {
  window.joypad = {};
  a22("Your browser does not support the Gamepad API - https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API");
}
const vitePluginRequire_1743700425864_37921269 = "/assets/error_002-76810ec3.ogg";
const vitePluginRequire_1743700425863_98433406 = "/assets/confirmation_002-33b17a9a.ogg";
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
let GamePadSounds = class {
};
GamePadSounds = __decorateClass$1([Sound$1({
  sounds: {
    connect: vitePluginRequire_1743700425863_98433406,
    disconnect: vitePluginRequire_1743700425864_37921269
  }
})], GamePadSounds);
const icon = "/assets/gamepad-e5a5597c.svg";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const joypad = window["joypad"];
let moving = false;
let directions = {};
let axisDate = 0;
const DIRECTIONS = [Direction.Left, Direction.Right, Direction.Up, Direction.Down];
let RpgClientModule2 = class {
};
RpgClientModule2 = __decorateClass([
  RpgModule({
    engine: {
      onStart(engine) {
        const globalConfig = engine.globalConfig.gamepad || {};
        if (!globalConfig.connect)
          globalConfig.connect = {};
        if (!globalConfig.disconnect)
          globalConfig.disconnect = {};
        const optionsConnect = {
          message: "Your gamepad is connected !",
          time: 2e3,
          icon,
          sound: "connect",
          ...globalConfig.connect
        };
        const optionsDisconnect = {
          message: "Your gamepad is disconnected !",
          time: 2e3,
          icon,
          sound: "disconnect",
          ...globalConfig.disconnect
        };
        const move = () => {
          if (moving) {
            for (let dir in directions) {
              engine.controls.applyControl(dir, true);
            }
          }
        };
        joypad.on("connect", (e3) => {
          RpgGui.display("rpg-notification", optionsConnect);
          setInterval(move, 400);
        });
        joypad.on("disconnect", (e3) => {
          RpgGui.display("rpg-notification", optionsDisconnect);
        });
        joypad.on("button_press", (e3) => {
          const { buttonName } = e3.detail;
          switch (buttonName) {
            case "button_0":
              engine.controls.applyControl(Control.Action);
              break;
            case "button_1":
            case "button_9":
              engine.controls.applyControl(Control.Back);
              break;
          }
        });
        joypad.on("axis_move", async (e3) => {
          moving = true;
          axisDate = Date.now();
          let direction = e3.detail.directionOfMovement;
          if (direction == "bottom")
            direction = Direction.Down;
          else if (direction == "top")
            direction = Direction.Up;
          else if (direction == "left")
            direction = Direction.Left;
          else if (direction == "right")
            direction = Direction.Right;
          directions = {
            [direction]: true
          };
          for (let dir of DIRECTIONS) {
            if (!directions[dir]) {
              engine.controls.applyControl(dir, false);
            }
          }
          move();
        });
      },
      onStep(engine) {
        let now = Date.now();
        if (now - axisDate > 100 && moving) {
          for (let dir of DIRECTIONS) {
            directions = {};
            moving = false;
            engine.controls.applyControl(dir, false);
          }
        }
      }
    },
    sounds: [
      GamePadSounds
    ]
  })
], RpgClientModule2);
const _rpgjs_gamepad = {
  client: RpgClientModule2
};
export {
  Animation$1 as A,
  BehaviorSubject$1 as B,
  Class as C,
  Direction as D,
  EventData as E,
  MapData as M,
  Presets as P,
  RpgGui as R,
  Spritesheet as S,
  _export_sfc as _,
  RpgModule as a,
  RpgMap as b,
  createElementBlock as c,
  Skill as d,
  Actor as e,
  Presets$1 as f,
  Control as g,
  RpgEvent as h,
  Move as i,
  Components as j,
  State$1 as k,
  _rpgjs_plugin_emotion_bubbles as l,
  _rpgjs_title_screen as m,
  _rpgjs_save as n,
  openBlock as o,
  _rpgjs_mobile_gui as p,
  _rpgjs_default_gui as q,
  _rpgjs_gamepad as r,
  entryPoint as s,
  toDisplayString as t,
  map$6 as u,
  tap as v,
  inject as w,
  EVENTS_MAP as x,
  RpgPlugin as y,
  RpgRenderer as z
};
